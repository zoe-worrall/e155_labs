[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Link to the E155 Lab Website\nLink to the HMC Biophotonics Lab"
  },
  {
    "objectID": "contacts/index.html",
    "href": "contacts/index.html",
    "title": "Contact Me",
    "section": "",
    "text": "Social Media\nMy Github can be found here!\nFollow me on LinkedIn here\nIf you’d like to reach out to me via email, please direct it to zworrall@g.hmc.edu"
  },
  {
    "objectID": "projects/open_ivis.html",
    "href": "projects/open_ivis.html",
    "title": "openIVIS",
    "section": "",
    "text": "OpenIVIS is one of the research projects run by Mudd Professor Josh Brake at Harvey Mudd College, in conjunction with Colorado School of Mines and with the additional support of the National Science Foundation and the Zuckerburg Chan Trust. Having aided in its progression towards increased imaging modularity, I helped to publish a paper on the topic.\nThis research is still in progress, although I am no longer working in this lab."
  },
  {
    "objectID": "projects/open_ivis.html#what-is-the-goal",
    "href": "projects/open_ivis.html#what-is-the-goal",
    "title": "openIVIS",
    "section": "What is the Goal?",
    "text": "What is the Goal?\nMuch of the in-vivo imaging research available to small universities and labs is too expensive to use, or may be too risky to pursue, most machines costing hundreds of thousands of dollars and only being available or more accessible to larger organizations. The purpose of openIVIS is to construct a cheap in-vivo imaging system with easily accessible materials. Although openIVIS will not replace the current, expensive opportunities that exist, the goal of this project is to design an alternative stepping stone that will allow labratories to perform fundamental, proof of concept tests that they would otherwise find difficult to attain. All of this will be done in an open-source context, with an accessible GUI, CAD designs, computer systems, and types of imaging."
  },
  {
    "objectID": "projects/open_ivis.html#what-i-worked-on",
    "href": "projects/open_ivis.html#what-i-worked-on",
    "title": "openIVIS",
    "section": "What I Worked On",
    "text": "What I Worked On\nI worked with the openIVIS project from Fall 2023 to Fall 2024. Within that time, I created a new CAD design for the system’s shell, and worked on its imaging capabilities using laser speckle contrast imaging (LSCI).\n\nCAD Designs – Originally, the designs supplied by Colorado School of Mines had straight edges for the box, which did not provide for easy assembly. I worked within SolidWorks to build a new box model of the same dimensions that would use puzzle-piece layout to fit the pieces more snuggly, and to prevent light from entering the box.\nMachining – Using the HMC Machine Shop and Makerspace, I used a lathe, drill, laser cutter, and 3D printers to create the parts necessary for the assembly of the system.\nLaser Speckle Contrast Imaging – Based on the idea of low exposure time leading to increased blurriness of moving objects, my main focus was to create LSCI capabilities for the openIVIS system. This was done by programming of 20+ Python models of different fourier transforms and cross correlations of both simulated and actual data. By the end of summer, 2023, the system was performing rudimentary imaging of moving liquid encased in diffusing material that was otherwise invisible to the naked eye and the camara.\nFluorescent Imaging – I created a basic CAD design for implementing LED lights on top of the box that would be kept out of the box to prevent overheating. This design was 3D printed, and is currently one of the prototypes that have aided in the progression of the project."
  },
  {
    "objectID": "projects/open_ivis.html#want-to-learn-more",
    "href": "projects/open_ivis.html#want-to-learn-more",
    "title": "openIVIS",
    "section": "Want to Learn More?",
    "text": "Want to Learn More?\nSee the HMC Biophotonics Lab page, as well as the Colorado School of Mines research paper on which I am listed."
  },
  {
    "objectID": "projects/e-155_website/index.html",
    "href": "projects/e-155_website/index.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 2, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5 Initial Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6 Initial Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7 Initial Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/e-155_website/posts/001_post_2024-08-28.html",
    "href": "projects/e-155_website/posts/001_post_2024-08-28.html",
    "title": "Is ‘Smart’ Really a Thing?",
    "section": "",
    "text": "Is “Smart” really a thing?\nI have a distinct memory from my time in elementary school of realizing that being smart is a very relative thing. The fact is, even elementary school students can understand that there’s a grey area when it comes to “intellectual prowess”: it is weird, in that way, that we try to decide and define who is smart and who isn’t. Sometimes, there are outliers of course - no one would ever really try to fight me if I said that Einstein was a genius. And yet, to me “smart” remains a very loaded word.\nThe main aspect of “smartness” I was thinking about in lower school was smartness in a multitude of categories: even if I may be book smart, for example, I have a very difficult time understanding people, and when it comes to social interactions I’m relatively hopeless. Smartness, from my perspective, ought to be considered more like (and forgive my references here) a Dungeons and Dragons character sheet rather than as some individual thing that measures solely how much someone has memorized flash card.\nAs a society, we’ve definitely been moving in the correct direction – standardized testing becoming optional for many schools is one of the first steps to recognizing the multitude of “smart” categories of students, and it will likely bring about a great degree of change for the better in multiple institutions. There obviously remains a long path to this recognition, however, and to that extent I’ve come up with a few paths I think might be able to be followed. The primary goal of these paths, or initiatives, would be to actively support the “smartness” of students not only in their intelligence, but in their five other categories as well (although I will mainly want to focus on Constitution, Wisdom, and Charisma).\nFor those unitiated in Dungeons and Dragons, I’ve provided a short, handy example of each of the six stats explained using tomatoes.\n\n\n\nImage of Tomato DnD Chart\n\n\nBased off of the DnD chart:\n\n(Constitution): How often has there been a friend that is just inherently in tune with their own body? This applies particularly to athletes and to dancers; the reason why I’d say that this falls under my terminology for “smart” is that this is a skill, based in understanding, that must be incessently worked at. Over time, you need enough experience with moving, working out, or playing games to understand yourself. The best way that we might begin incorporating a greater degree of respect for this “smartness” would likely be similar to the gym classes we have now; however, it relies on the coaches or teachers leading these activities encouraging learning about physical improvement, and applauding personal growth (not just natural skill)\n(Wisdom): This is street smarts, and although it can’t really be taught, it is always good to introduce new material to kids in class. I think running small sessions of activities that have unexpected or unrecognizable projects would aid in improving “wisdom smartness”.\n(Charisma): This one is quite important, and quite often overlooked. Charisma is a trait that is often built up from a very young age, and I know that I for one struggle with it. This smartness was my primary inspiration for thinking this in elementary school; knowing social interactions, when to speak, what is funny to say, when to say it, is difficult. As adults we’ve honed in on proper timing in converstaions, or proper topics to discuss, but as children most of the time this is only learned through peer-to-peer interaction. I’d say that in this case, the problem is less about teaching Charisma “smartness” and more about acknowledging it; potentially in school, especially lower levels of schooling, taking time to acknowledge feats of charisma, or running small programs where students share what they admire about how other people interact with them. The main point here is cognizance of the importance of social awareness.\n\nThere’s something to be said for teachers and mentors being involved outside of the classroom. I think at the end of the day, what I really wanted to get across with this post is the fact that students should acknowledge a variety of talents that they have, not just the ones that they demonstrate via memorization or in class."
  },
  {
    "objectID": "projects/e-155_website/posts/initial_learning_goals.html",
    "href": "projects/e-155_website/posts/initial_learning_goals.html",
    "title": "E155: Learning Goals",
    "section": "",
    "text": "My final goals for MicroP’s mainly revolve around getting more familiar with FPGA boards, as well as practicing my time management skills. This semester is set up to be packed with a lot of material, but it is all material that focuses mainly on projects rather than problem sets: resultantly, it’s an excellent way to hone in on my organization and my calendar skills.\nAdditionally, it has been about a year since I took E85, which means that many of my Verilog skills that I built up are rusty; this ought to be an excellent way to get back into programming in SystemVerilog. Additionally, FPGA’s are heavily used within the radio transmitting and signal processing world, and so I think it’s very important that I learn how to interact with them, even at their most basic level.\nFinally, I’m excited that this course incorporates Quarto and Github! It was not something that I was anticipating, but I believe that one of my final goals with this course is to build some additional professional skills that will allow me to present my work better, whether in academia or in industry."
  },
  {
    "objectID": "projects/e-155_website/posts/initial_learning_goals.html#my-thoughts",
    "href": "projects/e-155_website/posts/initial_learning_goals.html#my-thoughts",
    "title": "E155: Learning Goals",
    "section": "",
    "text": "My final goals for MicroP’s mainly revolve around getting more familiar with FPGA boards, as well as practicing my time management skills. This semester is set up to be packed with a lot of material, but it is all material that focuses mainly on projects rather than problem sets: resultantly, it’s an excellent way to hone in on my organization and my calendar skills.\nAdditionally, it has been about a year since I took E85, which means that many of my Verilog skills that I built up are rusty; this ought to be an excellent way to get back into programming in SystemVerilog. Additionally, FPGA’s are heavily used within the radio transmitting and signal processing world, and so I think it’s very important that I learn how to interact with them, even at their most basic level.\nFinally, I’m excited that this course incorporates Quarto and Github! It was not something that I was anticipating, but I believe that one of my final goals with this course is to build some additional professional skills that will allow me to present my work better, whether in academia or in industry."
  },
  {
    "objectID": "projects/e-155_website/posts/002_post_2024-09-05.html",
    "href": "projects/e-155_website/posts/002_post_2024-09-05.html",
    "title": "The Swamp That Stands Between",
    "section": "",
    "text": "The Swamp That Stands Between: Engineering and (Studio) Art\n\nTo Be Honest…\nI’m extremely surprised that more artists don’t turn up inside engineering. Looking at it pragmatically, engineering and art share quite a bit of cross-dialogue. Engineering, for example, has ill-defined points where a prototype becomes a “finished” article; in many of the same ways that a painter will look at a piece and not be able to say with absolute certainty “this is done”, an engineer will normally look at their circuit design and say “this is up to caliper”. Now, obviously, that isn’t to say there are some distinct divides; no one will be killed if a painting is missing a few lines or drawing in an odd way, but a bridge built with miscalculations or a power plant that’s not assembled up to a great degree of specific calibrations is bound to at least endanger many lives.\nSide note, I’d like to make it clear that much of the art I’ll be talking about in this blog post is the artform I’m most familiar with, being studio and digital art; normally very traditional, and falls well before many of the early 20th century movements that began questioning what exactly defines what art is; I refer to art here in a pretty classical, unnuanced sense, and plan on discussing Dadaism, Surrealism, Pop Art, etc. for a later day\nBut the fact remains that fundamentally, many of the same ideas we see in art appear in engineering. Diagrams, for example. Multiple drafts. Working at resembling real world structures and rendering them, sometimes twisting them or simplifying them, to either get a better understanding or a new interpretation. Both are inherently human, and require large degrees of creativity.\nI believe the fundamental differences between these two, and the reason that so few artists turn up as engineers, or so few engineers turn up as artists, is two fold: 1. Engineering and (studio) art’s high bar for entry 2. Engineering’s restrictions\nI don’t think many people would argue with me when I say that engineering has a high bar for entry; you need a lot of STEM background, an appreciation for systems often, and you need to not only enjoy being a problem solver but have been encouraged to do so; much of engineering, at least as a student, is as much about will power, perserverance, and a drive to succeed, as it is a series of mathematical expressions and designs.\nBut why would I say that art has a high bar for entry? This one, I think, is more a mental high bar than a physical one. To any artists reading this, I want you to fill in the following blank in my imaginary scenario:\nPerson A: [showing an artwork] This is a cat that I drew! I based it off of a photo of my cat, but I used oil pastel and changed the colors around to make it appear neon and change color under UV lighting.\nPerson B: Oh my gosh, I could never draw something like that! I can’t even draw a ____.\nIf your answer to that is stick figure, you are one of the many artists who are seeing live the high-bar for entry that is artistry, and very similar to engineering, its a mental one. Where engineering is exhausting while being learned, and requires a large amount of devotion (sometimes at expense of social life, for example), artistry requries a will to improve; it is self driven, at the end of the day, similar to engineering, but unlike engineering it requires constant, subjective comparison. It requires the artist to ask themselves “where did I go wrong”, “how could I improve this”, or “why doesn’t my artwork look like theirs”. The internal battle within artwork creates a high bar for entry that many people are scared to face and overcome, particularly later in life.\nAll that is to say, that there are high bars to enter both engineering and art, both of them mental, and both of them requiring either early interest in the subject or the drive to pursue them later in life despite societal opposition (less-so is this true for engineering). Resultantly, the chance of meeting someone who has been able to do both art and engineering is lower than you would think.\nMoving onto the second bullet, being Engineering’s restrictions, I think that this is one of the things that holds artists back from joining engineering - the fact that engineering is an artform with a great degree of restrictions applied. From my perspective, engineering’s prototyping is a reflection of how it exists as a form of art. The difference from prototyping in art, however, and prototyping in engineering, is that as I said before if you make a prototype the final design, someone could get hurt in engineering. Engineering has built of a long history of rules and regulations (and logically so), but I think that to the average artist, who is so familiar with the ability to build what they want and do what they want with their artform, without rules, engineering likely feels quite restrictive. In many ways its like putting blinders on a horse; it focuses your energy, it keeps you focused on the road ahead; it keeps you and the people around you safe. But I think that at the same time, it’s just as good to let the horse roam a little bit, see the world, get spooked etc (I’m not a horse girl, if you couldn’t tell, and I’m sure many horse people got very mad at me for saying that just now). My main point is that engineering’s restrictions are unfortunately somewhat contradictory to what some artists want to do with their artforms, and resultantly engineering only applies to a few select artists who enjoy challenging themselves by placing restrictions on their own art forms. Engineering, then, is almost a practice in artistic expression that faces many requisites in order to ensure a sense of safety and coherence for its majors.\n\n\n\n\n\n\nInspiration\n\n\n\nCall it a happy accident. While I was breadboarding for Lab 2 of HMC E155, I noticed that the wires and the way everything was coming together looks very similar to abstract art. In general, a lot of engineering (especially in its early stages) looks more like an art project than anything else. It made me think a bit about how to define the divide between the two."
  },
  {
    "objectID": "projects/e-155_website/labs/lab3/lab3.html",
    "href": "projects/e-155_website/labs/lab3/lab3.html",
    "title": "Lab 3 Writeup",
    "section": "",
    "text": "Hours Spent: 56 hours, Mapped with Toggl Track\n\n\nThe main point of this laboratory was to use asynchronous components and a finite state machine to control a keypad connected to an FPGA. The Finite state machine would keep track of both the values of the states, as well as have a recorded memory of both the most recent and the last pin pressed. The difficulties of this lab lay within creating a way to handle metastability; in order to ensure that no random metastability occured within the system while it was running, you need to have a set of flip flops through which you run the column input.\n\n\n\nI first began by drawing a rudimentary FSM chart:\n\nThis is based on the fundamental logic that there should be four parts to this problem: 1. A section of the code/hardware that sends a voltage through each row as it goes, waiting to detect a signal. If it does detect something, it sends us to the next state.\n\nA section of the code/hardware that logs the corresponding rows and columns so that we can compute what the letter we need to light up is\nA section of the code/hardware that cycles for about 1ms to prevent bounceback caused by any of the keys\nA section of the code/hardware that waits until the original button (or what I coined the RX Signal) that was pressed is no longer pressed down (i.e. can’t say “nothing is pressed”, but rather that the original button is no longer pressed); thus, you wait till the RX signal stops.\n\nI additionally decided to define a row state machine, although this would reside within the actual program as combinational logic, not as a module.\n\n\n\n\n\n\n\n\n\n\n\nSome challenges with this lab are implementing a way to handle metastability; in this case, it was necessary to add a set of flip flops about the column input logic so that asyncronous signals could become synchronous; in my case, I chose to send the columns through two flipflops. I integrated this step within my FSM block, after I had initially made the logic for it, which resulted in the large amount of code that it contains; in the future, I’d like to trim this FSM block down so that it looks simpler and shows the outputs and inputs easier to the causal viewer. However, for now the flip flops have been implemented to run right after the waiting period, within the “LOG” state; the LOG state will wait for two cycles of flip flops, before taking the output of the flip flop (mat_stab), and using it as if it were the column. During this process, the intial row that the column was saved to has been stored, and I am powering it so that the upcoming TILL_RX_STOP step can run.\nMy debouncing approach is likely more rudimentary than it could be: I could additionally have added a way to track how many one’s in a row the machine had received, and use that to determine if the button was actually pushed. This would have required a longer loop, but would likely have been more accurate, as currently some a quick tap of the key makes it repeat (even though I’ve made the CYCLE stage extremely long relatively speaking). I think that the looking at the 1’s strategy would be very effective for eliminating debouncing. I think that in particular, I could have implemented more flip-flops to really make sure that the state was what the board originally thought it was.\n\n\n\nUsing my initial approach as well as some blocking of the modules that I would need for this program, I was then able to construct a finalized FSM with defined output variables.\nThis gives the following diagram and set of tables for inputs and outputs.\n\n\n\n\nTable 1: State Transition Table\n\n\n\n\n\nstate\nscenario/inputs\nnext_state\noutput values: row, past_letter, curr_letter, state, waiter\n\n\n\n\nWAIT\ncol == 0\nWAIT\nrow = ROW (see the row state machine), past_letter remains, curr_letter remains, state = WAIT, waiter = 0\n\n\nWAIT\ncol != 0\nLOG\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = WAIT, next_waiter = 2^19\n\n\nLOG\nmat_stab != (4’b0001 or 4’b0010 or 4’b0100 or 4’b1000)\nWAIT\nrow = R_RESET (see the row state machine), next_past_letter = curr_letter, next_curr_letter = next_letter (output of letter_receiver module), state = LOG, next_waiter = waiter\n\n\nLOG\nmat_stab == (4’b0001 or 4’b0010 or 4’b0100 or 4’b1000)\nCYCLE\nnext_row = row (see the row state machine), past_letter remains, curr_letter remains, state = WAIT, waiter = waiter - 1\n\n\nCYCLE\nwaiter != 0\nCYCLE\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = waiter - 1\n\n\nCYCLE\nwaiter == 0\nTX_RX_STOP\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = 0\n\n\nTILL_RX_STOP\ncol[col_index] != 0\nTILL_RX_STOP\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0\n\n\nTILL_RX_STOP\ncol[col_index] == 0\nLOG\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0\n\n\n\n\n\n\nI have additionally depicted below what the table for the row states looks like.\n\n\n\nTable 2: State Transition Table for the Row States\n\n\n\n\n\nrow\nscenario/inputs\nnext_row\n\n\n\n\nR_RESET\nX\nR_0\n\n\nR_0\ncol == 0\nR_1\n\n\nR_1\ncol == 0\nR_2\n\n\nR_2\ncol == 0\nR_3\n\n\nR_3\ncol == 0\nR_0\n\n\nR_X\ncol != 0\nR_X\n\n\n\n\n\n\nCurrently in the works, I decided to try revamping my FSM so that I wasn’t doing everything at once inside of my FSM function; it initially made the most sense to me to try doing it in one place, but this made it hard to see all of the logic that was happening to an outside observer (i.e. Kavi)\n\n\n\n\nMy final product of code looks like the following. The program primarily consists of the top module, which contains the clock, the lab03 module, which holds the fsm and the dual segment display modules, and finally the individual modules inside them. Describing them below,\n\nlab03_fsm: uses an internal flipflop from my flop_me module and a combinational logic block called letter_receiver to iterate through the defined states and return the desired values of interest.\ndual_seven_seg: the same as from lab02, where it uses multiplexing to light up both of the arrays with two defined numbers; this time, the numbers are supplied by the fsm.\nflop_me: a flip flop of some defined length that runs every time within the function in order to solve any metastability that may be present with a button push.\nletter_receiver: a combinational logic block that combines the saved indices of the rows and columns in order to solve for whatever letter/number was pressed. This is how I get the next_letter variable within my finite state machine.\n\n\nI confirmed using Questa that I was able to get the right values for all potential row inputs that I would have by iterating through the fsm (see the testbench below)\n\nIn order to form a comprehensive test, I initially begin by making sure that every row can be cycled through while we reside inside the Waiting state. No column was entered, and the testbench was used to track that the past letters, current letters, and finally the row cycling; since this is the waiting state, and nothing’s been pressed, the rows should cycle, and the output letters (0 and 0) stay the same (Figure 2)\n\n\n\n\n\n\n\n\n\nAfter this has been done, the system is then reset. This is confirmed by the testbench, and then the testbench enters a long for-loop that is used to confirm that every letter can be received and updated. For each loop of the table, the row and column are updated; the letter that has been generated is confirmed to be correct in the testbench, as well as the current lit rows and columns. The FSM additionally outputs its state, which is not used in the lab03 overall, but is used in the testbench to confirm that the proper state has also been entered. These cycles run through every row and every potential combination of row and column (Figure 3).\n\n\n\n\n\n\n\n\n\nWhen we zoom out in full, we can confirm that all letters can be reached, and that they can be stored (Figure 4).\n\n\n\n\n\n\n\n\n\nNext, I made another test bench to test my lab03 module as a whole, which looks like the following;\n\n\n\n\n\n\n\n\n\nThis testbench acts very similar to the fsm testbench, but in this case it confirms that the segment oscillates back and forth between the past letter and the current letter. Similar to the previous testbench for the fsm, the values were compared with expected values in the test bench, and when no errors were thrown, and the for-loop was completed without any errors or red lines becoming apparent, the testbench was considered a success.\nAs can be seen in Figure 5, the full test could be run, and the expected oscillations between segments occured as lab03 was run.\nIn both of these cases, I used a testbench to initialize and push inputs into the modules, and made sure that the expected values matched what I anticipated (indicated by no errors appearing in the terminal window).\nThe final schematic of my system was very simple to make. I used four GPIO pins from the FPGA E155 adapter board as an output into the rows, and four GPIO pins from this same board as inputs. Of additional note, becuase I considered 1’s as “high” on my board, I turned off the pull-up resistors inside the column pins, and implemented pulldown resistors of 47kOhm impedance on my board, with the knowledge that the keypad’s resistors range between 60 and 200 Ohms (found by testing in lab with an oscilloscope); resultantly, any voltage drop caused by the voltage-divider setup I had made would be negligable over the keypad, and would allow for proper reading of the signal. All other parts of this schematic, as a reader may likely recognize, are the same as from Lab2; the seven segment display as well as it PNP transistors are all plugged into the same pins, and depend on the same inputs.\n\n\n\n\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed. The main issue encountered in this lab were the following: * Implementation of pull-down resistors, and turning off the pull-up resistors within the keypads. * Implementation of a clock division that prevented the double-readout of a button push, which caused keys that sometimes held values a bit longer (on my keypad, keys E, 7, and 2) to be falsely read as a second input.\nIf future development desired, I’d like to add more flipflops, as well as simplify the state machine layout within Verilog to make debugging easier and make it more understandable to new viewers; potentially if I have time over winter break, I’ll do that and make it extremely nice looking so that it looks better in GitHub.\n\n\n\nThis lab was extremely difficult. I recommend in the future sending out a post about where the keypads are in the beginning of lab, because many people had a hard time finding them: I’d additionally warn people about how some of the keypads don’t match their anticipated row and column values, and that people should plan on bringing in multimeters in order to test which buttons are connected where. Finally, I’d suggest that people start by thinking about the flip flops, and don’t ignore them until later on; it became much harder to implement once I had my program set up, and if I had had the ability to go back and redo it with the knowledge that multipathing would require me to wait periods of time within a module, etc., I likely would have set it up nicer and it would have been in separate modules.\nAdditionally, I believe a note should be put somewhere about the speed of the clock, and to consider that as well when implementing your code. Although it is something that can be realized with the aid of an oscilloscope, it didn’t cross my mind because I was so fixated on the bugs that may be causing the issue. It may be nice to put a mention, maybe even a vague sentence, somewhere that says to keep an eye on not only the timing issues of your circuit, but in what time scale your circuit is running - that way it doesn’t spell out the answer, but still is informative to people like me who get stuck."
  },
  {
    "objectID": "projects/e-155_website/labs/lab3/lab3.html#lab-3-keypad-scanner",
    "href": "projects/e-155_website/labs/lab3/lab3.html#lab-3-keypad-scanner",
    "title": "Lab 3 Writeup",
    "section": "",
    "text": "Hours Spent: 56 hours, Mapped with Toggl Track\n\n\nThe main point of this laboratory was to use asynchronous components and a finite state machine to control a keypad connected to an FPGA. The Finite state machine would keep track of both the values of the states, as well as have a recorded memory of both the most recent and the last pin pressed. The difficulties of this lab lay within creating a way to handle metastability; in order to ensure that no random metastability occured within the system while it was running, you need to have a set of flip flops through which you run the column input.\n\n\n\nI first began by drawing a rudimentary FSM chart:\n\nThis is based on the fundamental logic that there should be four parts to this problem: 1. A section of the code/hardware that sends a voltage through each row as it goes, waiting to detect a signal. If it does detect something, it sends us to the next state.\n\nA section of the code/hardware that logs the corresponding rows and columns so that we can compute what the letter we need to light up is\nA section of the code/hardware that cycles for about 1ms to prevent bounceback caused by any of the keys\nA section of the code/hardware that waits until the original button (or what I coined the RX Signal) that was pressed is no longer pressed down (i.e. can’t say “nothing is pressed”, but rather that the original button is no longer pressed); thus, you wait till the RX signal stops.\n\nI additionally decided to define a row state machine, although this would reside within the actual program as combinational logic, not as a module.\n\n\n\n\n\n\n\n\n\n\n\nSome challenges with this lab are implementing a way to handle metastability; in this case, it was necessary to add a set of flip flops about the column input logic so that asyncronous signals could become synchronous; in my case, I chose to send the columns through two flipflops. I integrated this step within my FSM block, after I had initially made the logic for it, which resulted in the large amount of code that it contains; in the future, I’d like to trim this FSM block down so that it looks simpler and shows the outputs and inputs easier to the causal viewer. However, for now the flip flops have been implemented to run right after the waiting period, within the “LOG” state; the LOG state will wait for two cycles of flip flops, before taking the output of the flip flop (mat_stab), and using it as if it were the column. During this process, the intial row that the column was saved to has been stored, and I am powering it so that the upcoming TILL_RX_STOP step can run.\nMy debouncing approach is likely more rudimentary than it could be: I could additionally have added a way to track how many one’s in a row the machine had received, and use that to determine if the button was actually pushed. This would have required a longer loop, but would likely have been more accurate, as currently some a quick tap of the key makes it repeat (even though I’ve made the CYCLE stage extremely long relatively speaking). I think that the looking at the 1’s strategy would be very effective for eliminating debouncing. I think that in particular, I could have implemented more flip-flops to really make sure that the state was what the board originally thought it was.\n\n\n\nUsing my initial approach as well as some blocking of the modules that I would need for this program, I was then able to construct a finalized FSM with defined output variables.\nThis gives the following diagram and set of tables for inputs and outputs.\n\n\n\n\nTable 1: State Transition Table\n\n\n\n\n\nstate\nscenario/inputs\nnext_state\noutput values: row, past_letter, curr_letter, state, waiter\n\n\n\n\nWAIT\ncol == 0\nWAIT\nrow = ROW (see the row state machine), past_letter remains, curr_letter remains, state = WAIT, waiter = 0\n\n\nWAIT\ncol != 0\nLOG\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = WAIT, next_waiter = 2^19\n\n\nLOG\nmat_stab != (4’b0001 or 4’b0010 or 4’b0100 or 4’b1000)\nWAIT\nrow = R_RESET (see the row state machine), next_past_letter = curr_letter, next_curr_letter = next_letter (output of letter_receiver module), state = LOG, next_waiter = waiter\n\n\nLOG\nmat_stab == (4’b0001 or 4’b0010 or 4’b0100 or 4’b1000)\nCYCLE\nnext_row = row (see the row state machine), past_letter remains, curr_letter remains, state = WAIT, waiter = waiter - 1\n\n\nCYCLE\nwaiter != 0\nCYCLE\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = waiter - 1\n\n\nCYCLE\nwaiter == 0\nTX_RX_STOP\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = 0\n\n\nTILL_RX_STOP\ncol[col_index] != 0\nTILL_RX_STOP\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0\n\n\nTILL_RX_STOP\ncol[col_index] == 0\nLOG\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0\n\n\n\n\n\n\nI have additionally depicted below what the table for the row states looks like.\n\n\n\nTable 2: State Transition Table for the Row States\n\n\n\n\n\nrow\nscenario/inputs\nnext_row\n\n\n\n\nR_RESET\nX\nR_0\n\n\nR_0\ncol == 0\nR_1\n\n\nR_1\ncol == 0\nR_2\n\n\nR_2\ncol == 0\nR_3\n\n\nR_3\ncol == 0\nR_0\n\n\nR_X\ncol != 0\nR_X\n\n\n\n\n\n\nCurrently in the works, I decided to try revamping my FSM so that I wasn’t doing everything at once inside of my FSM function; it initially made the most sense to me to try doing it in one place, but this made it hard to see all of the logic that was happening to an outside observer (i.e. Kavi)\n\n\n\n\nMy final product of code looks like the following. The program primarily consists of the top module, which contains the clock, the lab03 module, which holds the fsm and the dual segment display modules, and finally the individual modules inside them. Describing them below,\n\nlab03_fsm: uses an internal flipflop from my flop_me module and a combinational logic block called letter_receiver to iterate through the defined states and return the desired values of interest.\ndual_seven_seg: the same as from lab02, where it uses multiplexing to light up both of the arrays with two defined numbers; this time, the numbers are supplied by the fsm.\nflop_me: a flip flop of some defined length that runs every time within the function in order to solve any metastability that may be present with a button push.\nletter_receiver: a combinational logic block that combines the saved indices of the rows and columns in order to solve for whatever letter/number was pressed. This is how I get the next_letter variable within my finite state machine.\n\n\nI confirmed using Questa that I was able to get the right values for all potential row inputs that I would have by iterating through the fsm (see the testbench below)\n\nIn order to form a comprehensive test, I initially begin by making sure that every row can be cycled through while we reside inside the Waiting state. No column was entered, and the testbench was used to track that the past letters, current letters, and finally the row cycling; since this is the waiting state, and nothing’s been pressed, the rows should cycle, and the output letters (0 and 0) stay the same (Figure 2)\n\n\n\n\n\n\n\n\n\nAfter this has been done, the system is then reset. This is confirmed by the testbench, and then the testbench enters a long for-loop that is used to confirm that every letter can be received and updated. For each loop of the table, the row and column are updated; the letter that has been generated is confirmed to be correct in the testbench, as well as the current lit rows and columns. The FSM additionally outputs its state, which is not used in the lab03 overall, but is used in the testbench to confirm that the proper state has also been entered. These cycles run through every row and every potential combination of row and column (Figure 3).\n\n\n\n\n\n\n\n\n\nWhen we zoom out in full, we can confirm that all letters can be reached, and that they can be stored (Figure 4).\n\n\n\n\n\n\n\n\n\nNext, I made another test bench to test my lab03 module as a whole, which looks like the following;\n\n\n\n\n\n\n\n\n\nThis testbench acts very similar to the fsm testbench, but in this case it confirms that the segment oscillates back and forth between the past letter and the current letter. Similar to the previous testbench for the fsm, the values were compared with expected values in the test bench, and when no errors were thrown, and the for-loop was completed without any errors or red lines becoming apparent, the testbench was considered a success.\nAs can be seen in Figure 5, the full test could be run, and the expected oscillations between segments occured as lab03 was run.\nIn both of these cases, I used a testbench to initialize and push inputs into the modules, and made sure that the expected values matched what I anticipated (indicated by no errors appearing in the terminal window).\nThe final schematic of my system was very simple to make. I used four GPIO pins from the FPGA E155 adapter board as an output into the rows, and four GPIO pins from this same board as inputs. Of additional note, becuase I considered 1’s as “high” on my board, I turned off the pull-up resistors inside the column pins, and implemented pulldown resistors of 47kOhm impedance on my board, with the knowledge that the keypad’s resistors range between 60 and 200 Ohms (found by testing in lab with an oscilloscope); resultantly, any voltage drop caused by the voltage-divider setup I had made would be negligable over the keypad, and would allow for proper reading of the signal. All other parts of this schematic, as a reader may likely recognize, are the same as from Lab2; the seven segment display as well as it PNP transistors are all plugged into the same pins, and depend on the same inputs.\n\n\n\n\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed. The main issue encountered in this lab were the following: * Implementation of pull-down resistors, and turning off the pull-up resistors within the keypads. * Implementation of a clock division that prevented the double-readout of a button push, which caused keys that sometimes held values a bit longer (on my keypad, keys E, 7, and 2) to be falsely read as a second input.\nIf future development desired, I’d like to add more flipflops, as well as simplify the state machine layout within Verilog to make debugging easier and make it more understandable to new viewers; potentially if I have time over winter break, I’ll do that and make it extremely nice looking so that it looks better in GitHub.\n\n\n\nThis lab was extremely difficult. I recommend in the future sending out a post about where the keypads are in the beginning of lab, because many people had a hard time finding them: I’d additionally warn people about how some of the keypads don’t match their anticipated row and column values, and that people should plan on bringing in multimeters in order to test which buttons are connected where. Finally, I’d suggest that people start by thinking about the flip flops, and don’t ignore them until later on; it became much harder to implement once I had my program set up, and if I had had the ability to go back and redo it with the knowledge that multipathing would require me to wait periods of time within a module, etc., I likely would have set it up nicer and it would have been in separate modules.\nAdditionally, I believe a note should be put somewhere about the speed of the clock, and to consider that as well when implementing your code. Although it is something that can be realized with the aid of an oscilloscope, it didn’t cross my mind because I was so fixated on the bugs that may be causing the issue. It may be nice to put a mention, maybe even a vague sentence, somewhere that says to keep an eye on not only the timing issues of your circuit, but in what time scale your circuit is running - that way it doesn’t spell out the answer, but still is informative to people like me who get stuck."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/lab1.html",
    "href": "projects/e-155_website/labs/lab1/lab1.html",
    "title": "Lab 1 Writeup",
    "section": "",
    "text": "Hours Spent: 21.3, Mapped with Toggl Track\n\n\nThe goal of this lab was to program an FPGA board to do two things: 1. Control a set of 3 on-board LEDs to follow XOR, AND, and clock counter logic 2. Control a seven-segment array using the E155 Breadboard Adapter v4 The clock was configured to run at 48MHz, and connected to an LED such that it blinked at ~2.4 Hz. Additional details about the first goal may be foudn in (Section 1.4).\n\n\n\nThe goal of this lab was initial setup and confirmation of FPGA control of on-board LEDs and attached GPIO pin. This was done through the control of three leds: D6, D7, and D8, as well as seven GPIO pins: 45, 3, 44, 9, 13, 12, and 20 through the readout of on-board 4-pin DIP switch.\n\n\nThe first stage of this lab involved the soldering of the MCU and the FPGA, as well as all additional SMD and THT pins. To do this, the E155 FA23 Development Board schematic was used. To begin, the SMD components were soldered. Careful consideration was given to make sure that the diodes were soldered in the right order and facing the correct direction. After these were soldered, THT components were then soldered, including the 4-pin DIP switch, the 8-pin DIP switch, and the female headers (Figure 1).\n\n\n\n\n\n\nFigure 1: SMD and THT pins soldered\n\n\n\nA board was connected via ribbon cable to the main Development board to allow for control of a breadboard via on-board GPIO pins (Figure 2). Once all pieces had been put together, the board was tested via a voltmeter via the screw terminal to ensure that the board could be properly powered (Figure 3)(Figure 4). The board through the screw terminal required +6 - +20 V; testing was done using 6V, and the board was confirmed to be running. The breadboard was tested using a multimeter to ensure that the 3.3V, 5.0V, and GND pins were properly generating the right voltage.\n\n\n\n\n\n\n\n\n\nFigure 2: Board assembled with ribbon cable\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Powering the board with the screw terminal at +6V\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: The Voltmeter while powering the screw terminal\n\n\n\n\n\nAll soldered pins and the required impedance values and relevant pin numbers can be found in the E155 FA23 Development Board pdf, linked in “Other Links” on this page. Once confirmation was had that the board was properly powering all pins using the screw terminal, the transition was then made to powering the board using both the MCU and the FPGA individually via a micro-USB cable.\nThe final schematic for this design can be seen below.\n\n\n\n\n\n\n\n\n\n\n\n\nWhen attaching the seven segment display, I took care to note the design specifications. My board was a common-anode, single-seven segment display, which means that it was a MAN6460 on the data sheet. All segments had a test operating current of 20mA, and a dynamic resistance of 26 ohms when running. Additionally, I found that the average test voltage drop across was 2.1 V; I did not want to design for the maximum voltage scenario (which was 2.8 V), as I’d rather avoid getting too close to any risk of burning the matrix out. Considering that the current draw ought to be 20 mA, and that the voltage drop across a given segment is 2.1 V, I know that the resistors have to remove 1.2V at 20mA of current; when calculating according to the equation V/I = R, this means that the final resistance ought to be about 60 ohms. For the sake of safety and with confirmation from Kavi, I used 220 ohm resistors to connect each of the cathodes of the board to their relative pins, and supplied both of the common anode pins with 3.3 V from the GPIO board. This means that each segment, when powered, has a current of 1.2/220 ohms or about 5 mA of current, which would map to 0.5 relative luminosity on their supplied data sheet (Figure 6)\n\n\n\n\n\n\n\n\n\nThis leads to the question of why I didn’t put a single resistor at the common anode, and chose instead to use seven different ones. The answer to this lies within the design constraints; we want each of the segments to light up equal amounts every time. If the resistor came before the diode’s power drop, the current through each diode would vary as the number of diodes lighting up varied. A very simple example can be seen with the setup seen in Figure 7.\n\n\n\n\n\n\n\n\n\nIf we compare A and B, we can see how the current through the diodes will differ between each situation. In case A, the one that I used, if one diode isn’t lit up, it has no impact on the current traveling through the other diode: in every case, the voltage drop will assuredly be either 0V or 2.1 V across a given diode, irrelevant to any other segment within this case. However in case B, the same can not be said. If two diodes are lit up, they will be using double the amount of current, and resultantly the voltage drop caused by the single resistor will double. This means that there will be a smaller voltage drop across the diodes, which means that the more segments that are lit up, the less bright the matrix will glow - if it glows at all. This is why all of the resistors were attached to each cathode in the final design, rather than one resistor being connected to the common anode.\nThe FPGA board maps to all pins starting with P; the MCU maps to all pins starting with PA. In order to accomplish the correct mapping, I drew a diagram (Figure 8) that mapped the pin number, the segment controlled, and then the GPIO pin I intended for each part of the device. I knew that seg[0] was assigned to segA, seg[6] to segG, etc., and resultantly I was able to make a basic table that I then implemented on my breadboard (Table 1)\n\n\n\n\n\n\n\n\n\n\n\n\nTable 1: Mapping of Pins to Segments\n\n\n\n\n\nsegment number\nGPIO Pin\n\n\n\n\n0\nP20\n\n\n1\nP12\n\n\n2\nP13\n\n\n3\nP45\n\n\n4\nP9\n\n\n5\nP44\n\n\n6\nP3\n\n\n\n\n\n\n\n\n\n\nI own a Mac computer, so I needed to go through a broad array of necessary preparation in order to begin generating the code for my computer. First, I installed SEGGER Embedded Studio 8.16a on my computer. Following the SEGGER Embedded Studio Tutorial, I confirmed that I was able to load designs onto my MCU board.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nUnfortunately, because I don’t have a Windows, it was necessary to run to the laboratory and use an actual Windows computer in order to install J-Link. The only thing you need to download is the third link on the download links, specifically the one called “SEGGER STLinkReflash utility”. You shouldn’t need to install anything additional, since the supplied boards already had J-Link installed.\n\n\nThe FPGA proved to be a little more difficult. This was a multiple step process, and required a bit of troubleshooting.\nFirst, I installed Parallels on my computer: I know that not everyone has $80 lined up to pay for a virtual Windows Machine. I recommend, if possible, use a student discount; when I got it, I managed to find a 50% student discount, which meant in the end I only spent $40. Parallels is one of the best ways to interact with your FPGA besides being in-lab, and I highly recommend it after using it for the past few days.\nOnce I had that downloaded, I installed Lattice Radiant for Windows 64 inside of the Parallels machine. In all, this process took me about two hours, so make sure to budget some time beforehand if you’re planning on doing this on a Mac. As noted by Professor Brake on his page explaining how to use Lattice Radiant, if you build a design within this program you won’t be able to run it like you would on a Windows, even if you are able to Synthesize the board. Instead, you need to go back to your home screen and find the correct pathing to the file on your Windows computer.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nNot many people seem to know this, but if you have a folder or file open in your File Manager, you can drag the file into an open terminal window in order to get the complete file path; I’m sure there are other ways to do this, but this is the fastest way for me to open most programs.\n\n\nAlthough you could run the same terminal code that Professor Brake advises, I personally have been using code given to my by Kavi Dey, which works better most of the time because I don’t need to figure out pathing to the .bin file on my computer. If you’re interested, follow this tutorial.\n\n\n\nBy the end of the laboratory, the three switches were controlled as defined as seen in Tables 1(a) and 1(b), and the seven segment LED matrix as defined in the set of tables below:\n\n\n\n\n\nTable 2: LED Logic for Table {#tbl-first}\n\n\n\n\n\n\n\n(a) LED 1 (D7)\n\n\n\n\n\ns[3]\ns[2]\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) LED 0 (D6)\n\n\n\n\n\ns[1]\ns[0]\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\n\n\n\n\n\nThe logic tables that were used for the led to switch mapping. Table 2 (a) refers to s[3] and s[2]; on the board, these are switches 1 and 2 (pins P32 and P31 respectively) to match where the highest order digits would be in a four digit number. By extensino, Table 2 (b) uses the two right-most switches (P35 and P32)\n\n\n\n\n\nTable 3: Seven Segment LED Matrix Logic\n\n\n\n\n\nSwitch Base 10 Value\nSeven Segment Display\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n2\n\n\n3\n3\n\n\n4\n4\n\n\n5\n5\n\n\n6\n6\n\n\n7\n7\n\n\n8\n8\n\n\n9\n9\n\n\n10\nA\n\n\n11\nB\n\n\n12\nC\n\n\n13\nD\n\n\n14\nE\n\n\n15\nF\n\n\n\n\n\n\nThe mapping from the decimal readout of the switches in hexadecimal.\n\n\nThese table, in turn, will follow the schematic drawing seen in Figure 5.\nThe lab is composed of three modules, one test bench, and one basic text file of test vectors. The modules are assumbled such that there is one for the combinational logic used for the LEDs called led_control.sv, and another that is used for the combinational logic of the seven segment array, called seven_segments.sv. The connection of these modules can be visualized in the block diagram below.\n\n\n\nIn this design approach, I noted that the led’s followed very basic boolean logic; LED 0 followed XOR logic with the lowest order two bits supplied by the DIP switch, and LED 1 followed AND logic with the two highest bits (see table in Section 1.4). LED 2 was very simple to program, as it followed similar logic to that used in the iCE_40.sv tutorial.\nResultantly, the led_control module consists of three assign statements. The first two are combination logic for XOR and AND gates. The final part takes in a counter input, and uses it to decide whether to turn on/off the LED based on its most prominent bit in a 2^24 bit counter.\n\n\n\nThe design approach for the seven segment array required some more thoughtful setup. First, I constructed a table for each of the 16 possible arrangements of the DIP switch. Following the general logic that 0 should be mapped to 0x0, 1 to 0x1, etc. etc. until 15 was mapped to 0xF, I then created a table Table 4 that mapped out which parts of the segment would need to turn on to display the correct number. This gave me a list of seven bits arrange in 16 ways, which I then used inside a case statement when assigning according to the decimal value held by the DIP switch. Note that in the following table, segA was seg[0], or the least significant bit of the seven_segment array inside of the module; I initially had an issue debugging where I reversed the values on accident, and it created some odd shapes on the seven-segment matrix.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\nTable 4: Table of Switches Mapped to Segments\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ns[3]\ns[2]\ns[2]\ns[0]\n0x___\nsegA\nsegB\nsegC\nsegD\nsegE\nsegF\nsegG\n\n\n\n\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n0\n0\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n\n\n0\n0\n1\n0\n2\n0\n0\n1\n0\n0\n1\n0\n\n\n0\n0\n1\n1\n3\n0\n0\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n0\n4\n1\n0\n0\n1\n1\n0\n0\n\n\n0\n1\n0\n1\n5\n0\n1\n0\n0\n1\n0\n0\n\n\n0\n1\n1\n0\n6\n0\n1\n0\n0\n0\n0\n0\n\n\n0\n1\n1\n1\n7\n0\n0\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n8\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n0\n0\n1\n9\n0\n0\n0\n0\n1\n0\n0\n\n\n1\n0\n1\n0\n“A”\n0\n0\n0\n1\n0\n0\n0\n\n\n1\n0\n1\n1\n“b”\n1\n1\n0\n0\n0\n0\n0\n\n\n1\n1\n0\n0\n“C”\n0\n1\n1\n0\n0\n0\n1\n\n\n1\n1\n0\n1\n“d”\n1\n0\n0\n0\n0\n1\n0\n\n\n1\n1\n1\n0\n“E”\n0\n1\n1\n0\n0\n0\n0\n\n\n1\n1\n1\n1\n“F”\n0\n1\n1\n1\n0\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\nIn all, the combinational logic for this program was very straight forward. The next challenge came when mapping pins to the GPIO pins, and subsequent mapping to each individual segment on the matrix. The two modules for controlling the LEDs and the seven-segment matrix were both placed into a module called “lab01.sv”. On a top layer, the Python file “top.sv” generated a clock using an instatiation of an HSOSC module, which it fed into an instance of lab01.\n\n\n\n\nTo confirm that the system worked, a very basic testbench was written that ran through every potential arrangement of the 4-Pin system, checking expected LED values and seven-segment outputs. The value of led[2] was ignored in this testbench, as it was assumed to be working given that it had worked in the previous lab, and is extremely difficult to check (with my current knowledge as of September 2024) within a Questa Testbench.\nWhen writing a testbench, I ran into several problems with using test vectors, to the point where I initially just wanted to program a for-loop to check my results. However, I realized after multiple hours of debugging and talking with Kavi that I had saved the file as the wrong type of text file, and resultantly my code couldn’t find the file (not for lack of me putting the textfile in every place)\n\n\n\n\n\n\nCan’t Find *.tv File\n\n\n\nBecause Windows doesn’t show the full extension, it wasn’t until I was looking through Windows via Terminal that I saw that the .tv file was, in fact, not a .tv file but a .tv.rtf file; this meant that when the program looked for the file that it wanted to run to test the vectors, it was unable to load it, even if the pathing to the text file was correct. Be very careful in Windows that the extension you see in the Finder window may not be the complete extension.\n\n\nThe final test bench that I made controlled the four bit input of the switches, and the cross checked the output of top with the values I knew ought to be in the led and seven segment array. The simulation takes a long time to run: I believe in order for it to complete all test vectors, I need to use the command run 1000000 (with six 0’s) in order to see the full thing and confirm that it is working. I removed $finish from the initial testbench file I was using as a baseline, as I wanted to be able to see the finished Waveform generator in Questa.\n\nThis final design meets all the requirements for this lab. The bits are arranged in increasing order, left to right, on the DIP switches, and correspond to the LED’s when everything is oriented the same way (i.e. the seven segment array is facing the correct direction, and the ribbon cable keeps everything close to the development board) without any twisting. Listing the requirements, and going over each one, we see that: 1. The development board is fully assembled and all its components are soldered. This was confirmed for the screw panel as well as the GPIO pins using a multimeter in lab. 2. There are three verilog modules written, one that serves at the top wrapper module, and two the serve to individually control the LEDs and control the 7-segment display 3. The FPGA has been programmed to run with this Verilog code. 4. The 7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF 5. All digits for the board are unique, with no repeats 6. The DIP switches are sequentially ordered, with P37 being the highest order and P32 the lowest. This is true for both the LED logic and the seven segment logic. 7. The LEDs display the specified logic operations properly. 8. I have provided calculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions, as 1.2V/220ohms = about 20 mA, which is within the device’s marked operating current. 9. I have generated a ModelSim (or specifically Questa) simulation with an automatic test bench that walks through each potential switch combination and ensures that the design is working properly. 10. Finally, I have performed the necessary calcualtions to ensure that all digits, specifically of the seven-segment array, are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "projects/e-155_website/labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "Lab 1 Writeup",
    "section": "",
    "text": "Hours Spent: 21.3, Mapped with Toggl Track\n\n\nThe goal of this lab was to program an FPGA board to do two things: 1. Control a set of 3 on-board LEDs to follow XOR, AND, and clock counter logic 2. Control a seven-segment array using the E155 Breadboard Adapter v4 The clock was configured to run at 48MHz, and connected to an LED such that it blinked at ~2.4 Hz. Additional details about the first goal may be foudn in (Section 1.4).\n\n\n\nThe goal of this lab was initial setup and confirmation of FPGA control of on-board LEDs and attached GPIO pin. This was done through the control of three leds: D6, D7, and D8, as well as seven GPIO pins: 45, 3, 44, 9, 13, 12, and 20 through the readout of on-board 4-pin DIP switch.\n\n\nThe first stage of this lab involved the soldering of the MCU and the FPGA, as well as all additional SMD and THT pins. To do this, the E155 FA23 Development Board schematic was used. To begin, the SMD components were soldered. Careful consideration was given to make sure that the diodes were soldered in the right order and facing the correct direction. After these were soldered, THT components were then soldered, including the 4-pin DIP switch, the 8-pin DIP switch, and the female headers (Figure 1).\n\n\n\n\n\n\nFigure 1: SMD and THT pins soldered\n\n\n\nA board was connected via ribbon cable to the main Development board to allow for control of a breadboard via on-board GPIO pins (Figure 2). Once all pieces had been put together, the board was tested via a voltmeter via the screw terminal to ensure that the board could be properly powered (Figure 3)(Figure 4). The board through the screw terminal required +6 - +20 V; testing was done using 6V, and the board was confirmed to be running. The breadboard was tested using a multimeter to ensure that the 3.3V, 5.0V, and GND pins were properly generating the right voltage.\n\n\n\n\n\n\n\n\n\nFigure 2: Board assembled with ribbon cable\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Powering the board with the screw terminal at +6V\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: The Voltmeter while powering the screw terminal\n\n\n\n\n\nAll soldered pins and the required impedance values and relevant pin numbers can be found in the E155 FA23 Development Board pdf, linked in “Other Links” on this page. Once confirmation was had that the board was properly powering all pins using the screw terminal, the transition was then made to powering the board using both the MCU and the FPGA individually via a micro-USB cable.\nThe final schematic for this design can be seen below.\n\n\n\n\n\n\n\n\n\n\n\n\nWhen attaching the seven segment display, I took care to note the design specifications. My board was a common-anode, single-seven segment display, which means that it was a MAN6460 on the data sheet. All segments had a test operating current of 20mA, and a dynamic resistance of 26 ohms when running. Additionally, I found that the average test voltage drop across was 2.1 V; I did not want to design for the maximum voltage scenario (which was 2.8 V), as I’d rather avoid getting too close to any risk of burning the matrix out. Considering that the current draw ought to be 20 mA, and that the voltage drop across a given segment is 2.1 V, I know that the resistors have to remove 1.2V at 20mA of current; when calculating according to the equation V/I = R, this means that the final resistance ought to be about 60 ohms. For the sake of safety and with confirmation from Kavi, I used 220 ohm resistors to connect each of the cathodes of the board to their relative pins, and supplied both of the common anode pins with 3.3 V from the GPIO board. This means that each segment, when powered, has a current of 1.2/220 ohms or about 5 mA of current, which would map to 0.5 relative luminosity on their supplied data sheet (Figure 6)\n\n\n\n\n\n\n\n\n\nThis leads to the question of why I didn’t put a single resistor at the common anode, and chose instead to use seven different ones. The answer to this lies within the design constraints; we want each of the segments to light up equal amounts every time. If the resistor came before the diode’s power drop, the current through each diode would vary as the number of diodes lighting up varied. A very simple example can be seen with the setup seen in Figure 7.\n\n\n\n\n\n\n\n\n\nIf we compare A and B, we can see how the current through the diodes will differ between each situation. In case A, the one that I used, if one diode isn’t lit up, it has no impact on the current traveling through the other diode: in every case, the voltage drop will assuredly be either 0V or 2.1 V across a given diode, irrelevant to any other segment within this case. However in case B, the same can not be said. If two diodes are lit up, they will be using double the amount of current, and resultantly the voltage drop caused by the single resistor will double. This means that there will be a smaller voltage drop across the diodes, which means that the more segments that are lit up, the less bright the matrix will glow - if it glows at all. This is why all of the resistors were attached to each cathode in the final design, rather than one resistor being connected to the common anode.\nThe FPGA board maps to all pins starting with P; the MCU maps to all pins starting with PA. In order to accomplish the correct mapping, I drew a diagram (Figure 8) that mapped the pin number, the segment controlled, and then the GPIO pin I intended for each part of the device. I knew that seg[0] was assigned to segA, seg[6] to segG, etc., and resultantly I was able to make a basic table that I then implemented on my breadboard (Table 1)\n\n\n\n\n\n\n\n\n\n\n\n\nTable 1: Mapping of Pins to Segments\n\n\n\n\n\nsegment number\nGPIO Pin\n\n\n\n\n0\nP20\n\n\n1\nP12\n\n\n2\nP13\n\n\n3\nP45\n\n\n4\nP9\n\n\n5\nP44\n\n\n6\nP3\n\n\n\n\n\n\n\n\n\n\nI own a Mac computer, so I needed to go through a broad array of necessary preparation in order to begin generating the code for my computer. First, I installed SEGGER Embedded Studio 8.16a on my computer. Following the SEGGER Embedded Studio Tutorial, I confirmed that I was able to load designs onto my MCU board.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nUnfortunately, because I don’t have a Windows, it was necessary to run to the laboratory and use an actual Windows computer in order to install J-Link. The only thing you need to download is the third link on the download links, specifically the one called “SEGGER STLinkReflash utility”. You shouldn’t need to install anything additional, since the supplied boards already had J-Link installed.\n\n\nThe FPGA proved to be a little more difficult. This was a multiple step process, and required a bit of troubleshooting.\nFirst, I installed Parallels on my computer: I know that not everyone has $80 lined up to pay for a virtual Windows Machine. I recommend, if possible, use a student discount; when I got it, I managed to find a 50% student discount, which meant in the end I only spent $40. Parallels is one of the best ways to interact with your FPGA besides being in-lab, and I highly recommend it after using it for the past few days.\nOnce I had that downloaded, I installed Lattice Radiant for Windows 64 inside of the Parallels machine. In all, this process took me about two hours, so make sure to budget some time beforehand if you’re planning on doing this on a Mac. As noted by Professor Brake on his page explaining how to use Lattice Radiant, if you build a design within this program you won’t be able to run it like you would on a Windows, even if you are able to Synthesize the board. Instead, you need to go back to your home screen and find the correct pathing to the file on your Windows computer.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nNot many people seem to know this, but if you have a folder or file open in your File Manager, you can drag the file into an open terminal window in order to get the complete file path; I’m sure there are other ways to do this, but this is the fastest way for me to open most programs.\n\n\nAlthough you could run the same terminal code that Professor Brake advises, I personally have been using code given to my by Kavi Dey, which works better most of the time because I don’t need to figure out pathing to the .bin file on my computer. If you’re interested, follow this tutorial.\n\n\n\nBy the end of the laboratory, the three switches were controlled as defined as seen in Tables 1(a) and 1(b), and the seven segment LED matrix as defined in the set of tables below:\n\n\n\n\n\nTable 2: LED Logic for Table {#tbl-first}\n\n\n\n\n\n\n\n(a) LED 1 (D7)\n\n\n\n\n\ns[3]\ns[2]\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) LED 0 (D6)\n\n\n\n\n\ns[1]\ns[0]\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\n\n\n\n\n\nThe logic tables that were used for the led to switch mapping. Table 2 (a) refers to s[3] and s[2]; on the board, these are switches 1 and 2 (pins P32 and P31 respectively) to match where the highest order digits would be in a four digit number. By extensino, Table 2 (b) uses the two right-most switches (P35 and P32)\n\n\n\n\n\nTable 3: Seven Segment LED Matrix Logic\n\n\n\n\n\nSwitch Base 10 Value\nSeven Segment Display\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n2\n\n\n3\n3\n\n\n4\n4\n\n\n5\n5\n\n\n6\n6\n\n\n7\n7\n\n\n8\n8\n\n\n9\n9\n\n\n10\nA\n\n\n11\nB\n\n\n12\nC\n\n\n13\nD\n\n\n14\nE\n\n\n15\nF\n\n\n\n\n\n\nThe mapping from the decimal readout of the switches in hexadecimal.\n\n\nThese table, in turn, will follow the schematic drawing seen in Figure 5.\nThe lab is composed of three modules, one test bench, and one basic text file of test vectors. The modules are assumbled such that there is one for the combinational logic used for the LEDs called led_control.sv, and another that is used for the combinational logic of the seven segment array, called seven_segments.sv. The connection of these modules can be visualized in the block diagram below.\n\n\n\nIn this design approach, I noted that the led’s followed very basic boolean logic; LED 0 followed XOR logic with the lowest order two bits supplied by the DIP switch, and LED 1 followed AND logic with the two highest bits (see table in Section 1.4). LED 2 was very simple to program, as it followed similar logic to that used in the iCE_40.sv tutorial.\nResultantly, the led_control module consists of three assign statements. The first two are combination logic for XOR and AND gates. The final part takes in a counter input, and uses it to decide whether to turn on/off the LED based on its most prominent bit in a 2^24 bit counter.\n\n\n\nThe design approach for the seven segment array required some more thoughtful setup. First, I constructed a table for each of the 16 possible arrangements of the DIP switch. Following the general logic that 0 should be mapped to 0x0, 1 to 0x1, etc. etc. until 15 was mapped to 0xF, I then created a table Table 4 that mapped out which parts of the segment would need to turn on to display the correct number. This gave me a list of seven bits arrange in 16 ways, which I then used inside a case statement when assigning according to the decimal value held by the DIP switch. Note that in the following table, segA was seg[0], or the least significant bit of the seven_segment array inside of the module; I initially had an issue debugging where I reversed the values on accident, and it created some odd shapes on the seven-segment matrix.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\nTable 4: Table of Switches Mapped to Segments\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ns[3]\ns[2]\ns[2]\ns[0]\n0x___\nsegA\nsegB\nsegC\nsegD\nsegE\nsegF\nsegG\n\n\n\n\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n0\n0\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n\n\n0\n0\n1\n0\n2\n0\n0\n1\n0\n0\n1\n0\n\n\n0\n0\n1\n1\n3\n0\n0\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n0\n4\n1\n0\n0\n1\n1\n0\n0\n\n\n0\n1\n0\n1\n5\n0\n1\n0\n0\n1\n0\n0\n\n\n0\n1\n1\n0\n6\n0\n1\n0\n0\n0\n0\n0\n\n\n0\n1\n1\n1\n7\n0\n0\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n8\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n0\n0\n1\n9\n0\n0\n0\n0\n1\n0\n0\n\n\n1\n0\n1\n0\n“A”\n0\n0\n0\n1\n0\n0\n0\n\n\n1\n0\n1\n1\n“b”\n1\n1\n0\n0\n0\n0\n0\n\n\n1\n1\n0\n0\n“C”\n0\n1\n1\n0\n0\n0\n1\n\n\n1\n1\n0\n1\n“d”\n1\n0\n0\n0\n0\n1\n0\n\n\n1\n1\n1\n0\n“E”\n0\n1\n1\n0\n0\n0\n0\n\n\n1\n1\n1\n1\n“F”\n0\n1\n1\n1\n0\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\nIn all, the combinational logic for this program was very straight forward. The next challenge came when mapping pins to the GPIO pins, and subsequent mapping to each individual segment on the matrix. The two modules for controlling the LEDs and the seven-segment matrix were both placed into a module called “lab01.sv”. On a top layer, the Python file “top.sv” generated a clock using an instatiation of an HSOSC module, which it fed into an instance of lab01.\n\n\n\n\nTo confirm that the system worked, a very basic testbench was written that ran through every potential arrangement of the 4-Pin system, checking expected LED values and seven-segment outputs. The value of led[2] was ignored in this testbench, as it was assumed to be working given that it had worked in the previous lab, and is extremely difficult to check (with my current knowledge as of September 2024) within a Questa Testbench.\nWhen writing a testbench, I ran into several problems with using test vectors, to the point where I initially just wanted to program a for-loop to check my results. However, I realized after multiple hours of debugging and talking with Kavi that I had saved the file as the wrong type of text file, and resultantly my code couldn’t find the file (not for lack of me putting the textfile in every place)\n\n\n\n\n\n\nCan’t Find *.tv File\n\n\n\nBecause Windows doesn’t show the full extension, it wasn’t until I was looking through Windows via Terminal that I saw that the .tv file was, in fact, not a .tv file but a .tv.rtf file; this meant that when the program looked for the file that it wanted to run to test the vectors, it was unable to load it, even if the pathing to the text file was correct. Be very careful in Windows that the extension you see in the Finder window may not be the complete extension.\n\n\nThe final test bench that I made controlled the four bit input of the switches, and the cross checked the output of top with the values I knew ought to be in the led and seven segment array. The simulation takes a long time to run: I believe in order for it to complete all test vectors, I need to use the command run 1000000 (with six 0’s) in order to see the full thing and confirm that it is working. I removed $finish from the initial testbench file I was using as a baseline, as I wanted to be able to see the finished Waveform generator in Questa.\n\nThis final design meets all the requirements for this lab. The bits are arranged in increasing order, left to right, on the DIP switches, and correspond to the LED’s when everything is oriented the same way (i.e. the seven segment array is facing the correct direction, and the ribbon cable keeps everything close to the development board) without any twisting. Listing the requirements, and going over each one, we see that: 1. The development board is fully assembled and all its components are soldered. This was confirmed for the screw panel as well as the GPIO pins using a multimeter in lab. 2. There are three verilog modules written, one that serves at the top wrapper module, and two the serve to individually control the LEDs and control the 7-segment display 3. The FPGA has been programmed to run with this Verilog code. 4. The 7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF 5. All digits for the board are unique, with no repeats 6. The DIP switches are sequentially ordered, with P37 being the highest order and P32 the lowest. This is true for both the LED logic and the seven segment logic. 7. The LEDs display the specified logic operations properly. 8. I have provided calculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions, as 1.2V/220ohms = about 20 mA, which is within the device’s marked operating current. 9. I have generated a ModelSim (or specifically Questa) simulation with an automatic test bench that walks through each potential switch combination and ensures that the design is working properly. 10. Finally, I have performed the necessary calcualtions to ensure that all digits, specifically of the seven-segment array, are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/lab1.html#suggestions-for-future-improvements",
    "href": "projects/e-155_website/labs/lab1/lab1.html#suggestions-for-future-improvements",
    "title": "Lab 1 Writeup",
    "section": "Suggestions for Future Improvements",
    "text": "Suggestions for Future Improvements\nOverall, this lab was a very good introduction for MicroP’s, and really gets the ball rolling so that the student can get back into the frame of mind they were accustomed to in E85. Overall, I think very few edits should be made to this laboratory. However, if I had to suggest a change, I believe the main one would be that the lab writeup should include, at some point, a reference to the MCU board, in case the lab user either skipped the section or forgot about it. In particular, since the MCU will be used in the future, it seems important that the user demonstrate that they know how to use it before it is used to a much greater degree further into the semester.\nAdditionally, a reference to an example of a block diagram within the References page would have aided in clearing up exactly what was expected to be seen in the first lab writeup, as I had many questions that needed to be answered in person, and couldn’t be found online."
  },
  {
    "objectID": "projects/mcf_lci.html",
    "href": "projects/mcf_lci.html",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "",
    "text": "Brain imaging capabilities such as fMRI scans, although broad in capability, normally face issues when it comes to creating images with spatial and temporal resolution. Light increases the capabilities of both of these, but is limited by conventional lenses, which though non-intrusive causes a great degree of scatter, and GRIN lenses, which are wide, stiff intrusions in the context of optical imaging and risk damaging the subject while preventing in-situ imaging. Multicore fibers lie in the middle of these two. Capable of in-situ imaging and minimally invasive, this system would allow for the high temporal and spatial resolution of light and the benefits of non optical system."
  },
  {
    "objectID": "projects/mcf_lci.html#what-is-the-goal",
    "href": "projects/mcf_lci.html#what-is-the-goal",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "",
    "text": "Brain imaging capabilities such as fMRI scans, although broad in capability, normally face issues when it comes to creating images with spatial and temporal resolution. Light increases the capabilities of both of these, but is limited by conventional lenses, which though non-intrusive causes a great degree of scatter, and GRIN lenses, which are wide, stiff intrusions in the context of optical imaging and risk damaging the subject while preventing in-situ imaging. Multicore fibers lie in the middle of these two. Capable of in-situ imaging and minimally invasive, this system would allow for the high temporal and spatial resolution of light and the benefits of non optical system."
  },
  {
    "objectID": "projects/mcf_lci.html#what-i-worked-on",
    "href": "projects/mcf_lci.html#what-i-worked-on",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "What I Worked On",
    "text": "What I Worked On\n\nSimulations – …\nSLM Calibrations – …\nInterferometry – …\nSoftware Connections – U1800 Camera, pco.panda Camera, NiDAQmx…"
  },
  {
    "objectID": "projects/mcf_lci.html#want-to-learn-more",
    "href": "projects/mcf_lci.html#want-to-learn-more",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "Want to Learn More?",
    "text": "Want to Learn More?\nSee the HMC Biophotonics Lab page.\nMulticore Fiber Bundle LCI is one of the research projects run by Mudd Professor Josh Brake at Harvey Mudd College."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html",
    "href": "projects/e-155_website/labs/lab1/running_labs.html",
    "title": "How to Run FPGA Code",
    "section": "",
    "text": "The first thing that you need to do is write your code. Easy enough; let’s pretend that you’ve done that already.\nI follow Professor Brake’s tutorial for most of this, and it was quite comprehensive. However, if you’d like even more photos, and specifically information on how I personally load onto my FPGA board, read on. The next thing that you need to do is a bit more difficult if you aren’t connected to your board properly, and that’s to Synthesize your code, like the pretty image below.\n\n\n\n\n\nStart by installing Lattice Radiant. It’s straightforward, especially if you are following Professor Brake’s tutorial. I will talk specifically about installing the FTDI driver afterwards, as that was what was more difficult on my end.\nUnfortunately, unless you’ve done it before you’ll probably need to install the FTDI Drivers that Professor Brake mentions. I’ll give you a tip, though, that you shouldn’t just go blindly clicking and installing every zip file that you see – for example, clicking the linke for “setup executable” will give a file that is meant for Windows computers (x86), not for your arm64 chip. Here are the proper steps:\n\nRead through the Installation Guide for your situation. If you are like me, and are running a Windows Driver on your Mac, then use this Installation Guide. If you are even more like me, and you’re on a Mac with an M1 chip, you should carefully read and then ignore all of Sections 3.1 and 3.2 in this guide, and focuse solely on Section 3.3. As the document says, “Note: This is the only method to install the ARM64 or universal versions of the driver.”.\nThe rest of this process is quite straight forward, so long as you follow Section 3.3. The process will mainly be that you will first need to link your device into Parallels so that you can see it from inside the Parallels Device.\n\n\n\n\n\n\n\nYou will then be told that you should be able to open Device Manager within Windows (just use the search bar at the bottom to find it) and immediately see the relevant Ports. If you are like me, you don’t see this and panic. Don’t worry: it’s just hidden from you because it’s currently broken. To rectify this, you need to click View &gt; show hidden devices inside your Device Manager. Miraculously, you will suddenly see the same Ports file that they are talking about in the installation guide.\n\n\n\n\n\n\n\nContinue following their recommended steps. Note that when you install the FTDI driver, you should install it on the Parallels Window Machine and not on your home Mac, as this will cause errors when the program tries finding it (at least, it did for me)."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#first-steps",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#first-steps",
    "title": "How to Run FPGA Code",
    "section": "",
    "text": "The first thing that you need to do is write your code. Easy enough; let’s pretend that you’ve done that already.\nI follow Professor Brake’s tutorial for most of this, and it was quite comprehensive. However, if you’d like even more photos, and specifically information on how I personally load onto my FPGA board, read on. The next thing that you need to do is a bit more difficult if you aren’t connected to your board properly, and that’s to Synthesize your code, like the pretty image below.\n\n\n\n\n\nStart by installing Lattice Radiant. It’s straightforward, especially if you are following Professor Brake’s tutorial. I will talk specifically about installing the FTDI driver afterwards, as that was what was more difficult on my end.\nUnfortunately, unless you’ve done it before you’ll probably need to install the FTDI Drivers that Professor Brake mentions. I’ll give you a tip, though, that you shouldn’t just go blindly clicking and installing every zip file that you see – for example, clicking the linke for “setup executable” will give a file that is meant for Windows computers (x86), not for your arm64 chip. Here are the proper steps:\n\nRead through the Installation Guide for your situation. If you are like me, and are running a Windows Driver on your Mac, then use this Installation Guide. If you are even more like me, and you’re on a Mac with an M1 chip, you should carefully read and then ignore all of Sections 3.1 and 3.2 in this guide, and focuse solely on Section 3.3. As the document says, “Note: This is the only method to install the ARM64 or universal versions of the driver.”.\nThe rest of this process is quite straight forward, so long as you follow Section 3.3. The process will mainly be that you will first need to link your device into Parallels so that you can see it from inside the Parallels Device.\n\n\n\n\n\n\n\nYou will then be told that you should be able to open Device Manager within Windows (just use the search bar at the bottom to find it) and immediately see the relevant Ports. If you are like me, you don’t see this and panic. Don’t worry: it’s just hidden from you because it’s currently broken. To rectify this, you need to click View &gt; show hidden devices inside your Device Manager. Miraculously, you will suddenly see the same Ports file that they are talking about in the installation guide.\n\n\n\n\n\n\n\nContinue following their recommended steps. Note that when you install the FTDI driver, you should install it on the Parallels Window Machine and not on your home Mac, as this will cause errors when the program tries finding it (at least, it did for me)."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#kavis-code",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#kavis-code",
    "title": "How to Run FPGA Code",
    "section": "Kavi’s Code",
    "text": "Kavi’s Code\nThis has been posted with Kavi’s permission\nKavi was tired of needing to hunt down the .bin file every time. Kavi is also really good at writing shell code. Resultantly, Kavi wrote the following code which will find the binary file that you need, so long as you are in the proper folder for it.\nIn order to install this shortcut, first you need to open your .zshrc file. For those of you who are extremely unfamiliar with terminal code, follow the following steps.\n\nIn your terminal, type vim ~/.zshrc. This does two things; vim is a way of opening and editing a current configuration code (or any code file) from within terminal. ~/.zshrc is one of what are called “shell” code files. The ~/ indicates that the path to this file is from your current user’s home file. The “.zshrc” file itself is hidden; if you run ls in your home directory, you’ll note that it doesn’t appear; you can only see it if you list files including hidden ones (ls -a). It is what is run when your computer starts up, and helps point your computer on where to go. It is also where you can write shortcuts for running commands within terminal, which is what we are about to do. Below is an image of what my ~/.zshrc program looks like.\n\n\n\n\n\n\n\nYou’ll note that when you have this file open using vim, you can’t type anything. In order to actually insert things into this file, you need to type the letter i. This will put you into “Insert” mode, indicated by the -- INSERT -- on the bottom of your screen. You can now type in this folder! But be careful; deleting things or entering random things will likely throw errors in your terminal, which are often gross and icky to clean up.\n\n\n\n\n\n\n\nNow that you’re in Insert mode, navigate to the bottom of this file (just press/hold down on the down arrows until you get there). Paste the following code.\n\n#!/bin/bash\nalias program_fpga=\"find . -name '*.bin' -print | xargs openFPGALoader -b ice40_generic -c ft232  -f\"\nWhat this effectively does is locates the bin file (assuming that you’ve only made one – please don’t add more than one bin file or random, weird behavior will happen and the code likely won’t run), and then enters this into the openFPGALoader program. If you’re unfamiliar with terminal, you’ll notice that there’s a line (called a pipe) | in the middle of the code; this indicates that after you’ve found the *.bin file, you push the output into the next code; in this case, its being used as an argument (xargs) in openFPGA viewer.\n\nNow that you’ve inserted it, a problem that I first had when I was learning how to use vim was how to get out of it (vim is one of many ways to edit this programs, by the way: some people prefer using vi, or something else they’ve downloaded off of the interwebs. It’s really up to you how you edit files in terminal – I’m just most familiar with vim). To leave, and especially to save what you just did, use the Esc key. If you’ve decide that you don’t want to save your work, write :q! in the terminal and press Enter. This effectively quits the program without saving. If you DO want to save, instead you need to write :wq, which will save the edits that you’ve made to your ~/.zshrc file. You’ve now saved Kavi’s code, and if you want to run it, all you need to write in your terminal is program_fpga.\n\n\n\n\n\n\n\nDouble Check\n\n\n\nP.S. If you’d like to check that your changes were made inside of the program, you can experiment with that new pipe character you’ve just learned about to make sure that the file is in there. In your terminal, type cat ~/.zshrc | grep program_fpga. What this effectively does is:\n\nUses cat to return all the text inside your ~/.zshrc file\nPipelines this text and selectively sorts it, using grep, for the keyword “program_fpga”, which is the function we’ve just added.\n\nIf all went well, you should see the line alias program_fpga=\"find . -name '*.bin' -print | xargs openFPGALoader -b ice40_generic -c ft232  -f\" returned! If nothing is returned, that means it wasn’t saved properly, and you’ll need to go back and make sure that it’s there and that there are no typos."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#running-fpga-code",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#running-fpga-code",
    "title": "How to Run FPGA Code",
    "section": "Running FPGA Code",
    "text": "Running FPGA Code\nThe first step you need to take to running code off your FPGA board is locating where the folder containing this code is on your computer. Here is an example of how I find mine.\n\nI go to my Finder window, and go into Locations. This is where I can see Parallels’s virtual Windows environment.\n\n\n\n\n\n\n\nI then navigate to wherever I’ve saved my file. Note that it is also possible to save your file on your Mac, and upload it to your FPGA from there. For me, I had difficulties connecting to my FPGA whenever I was on my Mac besides when I was using the terminal, and so I chose to avoid some frustration by storing all my files solely on Parallels.\n\n\n\n\n\n\n\nBy dragging the folder for your lab into terminal, you can enter this path within your terminal in order to run your FGPA, Lattice Radiant code.\n\n\n\n\n\n\n\nNow that you are inside the program, you can run Kavi’s Code. Type program_fpga, and if you are connected to your board correctly (make sure that you have the microUSB plugged into the FPGA and that the lights are turned on), the code that you have Synthesized will automatically upload onto the FPGA, and you’ll see it running in real time. To double check and confirm, your terminal should resemble the image below (potentially without the colors)"
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#done",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#done",
    "title": "How to Run FPGA Code",
    "section": "Done!",
    "text": "Done!\nAnd that’s it! Congratulations, you’re now able to run code from your FPGA board!"
  },
  {
    "objectID": "projects/e-155_website/labs/lab2/lab2.html",
    "href": "projects/e-155_website/labs/lab2/lab2.html",
    "title": "Lab 2 Writeup",
    "section": "",
    "text": "Hours Spent: 13.5, Mapped with Toggl Track\n\n\nIn this lab, a design was developed to display the output of two 4-pin DIP Switches on a dual seven segmenet LED matrix, such that each four-pin switch was mapped to one display. The sum of these two values was then displayed on a set of five LEDs. The dual seven segment display is lit up using the same function as in Lab 1. Resultantly, it was necessary to multiplex the dual segment such that only one common anode was powered at a time. In addition, due to the current draw required on the display, the +3.3V regulator on the E155 Board was used to power the seven segment display (with the assumption that a computer would be able to supply the required amount of current). In addition, to prevent the current from flowing directly through the FPGA, the common anode was turned on and off using a PNP transistor setup. The LED display needed to be breadboarded, as well, because there are only a total of 4 FPGA-controllable LEDs onboard the development board. A 10-LED display was used to show the sum of each of the bits for this program.\n\n\n\n\n\nFrom the top layer down, it was understood that there would be the blocks displayed in the diagram depicted below.\n\n\n\n\n\n\nFigure 1: Block Diagram of Modules\n\n\n\nWhen encoded, the lab resultantly consisted of the above modules. They are explained in the table (Table 1) below.\n\n\n\nTable 1: Module Functions\n\n\n\n\n\n\n\n\n\nModule Name\nModule Function\n\n\n\n\ntop.sv\nPuts together lab2. Generates a clock that will run the program, and outputs variables to the necessary pins.\n\n\nlab02.sv\nRuns an always_ff block to determine the current state and the next state of the system. Runs combinational logic blocks of dual_seven_segment and led_summation for required seven segment and led logic\n\n\ndual_seven_seg.sv\nCalls on the seven segment block from Lab 1. According to the clock’s counter, half the time will return seven segment for one switch, and half the time will return the seven seg output for the other\n\n\nseven_segment.sv\nUses combinational logic to determine which seven segment cathodes to turn on, and which to turn off.\n\n\nled_summation.sv\nAdds together the collected 4-bits of the two switches and returns their binary equivalent as a 5-bit array\n\n\n\n\n\n\nSome important notes about this layout is that the clock is used to determine a state, S0 or S1, which will determine which display is turned on at any given time. In state S0, the system would rely on one switch (s1); in this case, seven_segment would be called on for that switch only. The system would then turn a corresponding anode on and off using the PNP resister; in this case, since its a PNP resistor, it needed to be turn “off” to turn the system on. In state S1, the output of seven_segment instead relies on the output of switch s2, and will return the opposite output for the anode display. The logic for this can be found in Table 2, the following can be said for each of the states.\n\n\n\nTable 2: State Logic\n\n\n\n\n\nstate\nSwitch Used for Seven Segment Logic\nAnode 1\nAnode 2\n\n\n\n\nS0\ns1\n0 (i.e. Display 1 is on)\n1 (Display 2 is off)\n\n\nS1\ns2\n1\n0\n\n\nX\nan error has occured, s = 0\n1\n1\n\n\n\n\n\n\nOnce these modules were all written, they were compiled, checked for errors, and finally put into Questa for testing.\n\n\n\nTwo test benches were written for this lab. The first one checks to make sure that lab02.sv as a whole can run, and correctly lights up the LEDs as seen fit. Because direct control of the counter can’t be gotten when calling on this upper-level module, the testbench instead only checked that at least one of the outputs of the potential seven segment outputs was correct. The second was used to determine that the proper segment was lit up when the correct switch/state was entered into the dual_seven_seg module. In the case of both, a testvector file was composed and assembled using Python to make sure that all possible options were checked for and confirmed. This Python program can be found in Github, at this_file.py\n\n\nIn order to make sure that all cases were covered, the test vectors were created by running a for-loop to generate a series of switches; each of these switch combinations was used to generate a potential segment output, and finally a summation-vector was made that could be called on to correctly add the sum of both segments to the end. The python file then printed a series of strings of the form\nswitch1_switch2_segment1_segment2_summed led values\nBy running two for loops to cycle through all potential switch values, it can be confirmed that all potential values within the system have been reached. Within the test bench itself, the system uses an or expression to confirm that at least one of the segment outputs is equal to the segment output of the system. It also confirms that the led_summation is working as anticipated.\nUsing this testbench, confirmation of the functionality of the whole of lab02 was completed, as all tests could be run without failure (Figure 2)\n\n\n\n\n\n\nFigure 2: Output of Running lab02_tb.sv in Questa\n\n\n\n\n\n\nIn order to make sure that all cases were covered, the test vectors for this testbench were created by running a for-loop to generate a series of switches, similar to lab02 testbench. However, these nested for-loops were nested in one final for-loop, which acertained which state the system was in; each of these switch combinations was used to generate a potential segment output, and finally a summation-vector was made that could be called on to correctly add the sum of both segments to the end. The python file then printed a series of strings of the form\nswitch1_switch2_state_segment_anode1_anode2\nBy running two for loops to cycle through all potential switch values, it can be confirmed that all potential values within the system have been reached. Within the test bench itself, the system uses an or expression to confirm that at least one of the segment outputs is equal to the segment output of the system. It also confirms that the led_summation is working as anticipated.\nUsing this testbench, confirmation of the functionality of the whole of lab02 was completed, as all tests could be run without failure (Figure 3)\n\n\n\n\n\n\nFigure 3: Output of Running lab02_tb.sv in Questa\n\n\n\nWith this confirmation that the logic of the modules were working, it was possible to then move on to physical implementation of the program on the actual FPGA and hardware.\n\n\n\n\n\nThe design was developed based on work from Lab 1. The same seven segmenet module was used within a double multiplexer, which used the clock to switch back and forth between powering the two common anodes of the dual display. Using multiplexing, the two values were displayed.\nBecause the final system was multiplexing between two segments, this means that the common anode of a given seven-segment LED must be able to be turned OFF. In the original design for the seven-segment display, the common anode had been plugged in directly to the +3.3V of the development board, and in this way circumvented being powered by the FPGA board (which can not supply more than 0.8 mA at a given time). Attempting to power the seven-segment display directly won’t work (as will be explained in Section 1.3.1) unless you want to short your board. Resultantly, two PNP 2N3906 transistors were used, wherein the FPGA was used only to turn the transistor on and off, allowing the +3.3V coming from the Development board to flow within the circuit (once again, circumventing using the FPGA as a current supply directly).\n\n\nBeforehand, to ensure proper requisites were met for powering the seven segment display that everything was properly set up for the PNP transistor and the resistors in the circuit, some simple mathematial calculations were performed to ensure proper voltage and current was kept throughout the circuit.\nThe transistors we were using were 2N3906 PNP transistors. PNP transistors have three terminals; the base, which controls if the PNP is on or off, the emitter, where electrons come from, and the collector, where the electrons go (Figure 4). For PNP transistors to work, there must be enough of a voltage gap between the base voltage and the emitter voltage that current can flow from one too the other; when this happens, current can also flow from the emitter to the collector, with the assumption that the voltages being used do not break or short out the transistor itself.\n\n\n\n\n\n\nFigure 4: PNP Transistor Diagram\n\n\n\nTo determine these limitations, it was necessary to know three things: the voltage drop across the collector to the emitter (V_CE), the voltage drop across the base to the emitter (V_BE), and finally the maximum current draw that would flow from the collector to the emitter (I_CE).\nAccording to the PNP’s datasheet, on average the V_CE drop is 3.3 V. The value of V_BE is, as with most transistors, assumed to be about 0.7 V. To start out with, the primary goal of this circuit should be to power the FPGA board without shorting it by sending too much current through it via the emitter to base connection on the board. Resultantly, a resistor should be placed between the FPGA’s output GPIO pin and the base of the transistor such that the current is less than the maximum possible current that can be sent into the board. This can be configured according to the datatable for the GPIO pins (Figure 5), where it can be seen that the maximum current that should be sent into or out of the FPGA board is 0.8 mA. The maximum current we will be sending into our board is based on the resistor values that we install for the diodes with the dual segment display. With the assumption that we use the same 220 Ohm resistors we were originally using, the current draw through each of these resistors will be slightly reduced from what was considered in Lab 1.\n\n\n\n\n\n\nFigure 5: GPIO Current Draw Pins for FPGA Board\n\n\n\nFirst and foremost, I intend to power the LED’s using 3.3V, but these volts will first travel across the transistor, which is dependent on the current I_C traveling through the circuit. Assuming that this is relatively negligable (see Figure 15 on the PNP Datasheet, to observe that most of the Voltage removed for current lying under 60 mA is close to 0.1 V), and knowing that per diode line there will be an anticipated voltage drop of 2.1 V, that means that any one resistor will need to remove 3.3 - 2.1 Volts, or 1.2 V, from the circuit. When traveling across a 220 Ohm resistor, this will result in a current of roughly 5.45 mA. Assuming that we’ll be powering seven segments at any one time (the maximum amount possible), this means that the total current draw that can be expected is 38.18 mA. We can then compute the necessary amount of current, I_B, that will need to travel through the base in order to turn this circuit on. Using the gain terms found in the datasheet (Figure 6), it can be seen that for a given current I_C = 40 mA, the gain will be roughly 50 around room temperature.\n\n\n\n\n\n\nFigure 6: Table of the Voltage Drop V_CE and Gain of PNP Transistor\n\n\n\nThis means that the corresponding current I_B for the circuit is 38.18 mA/50 = 0.69 mA. In the case of I_B, there is only one resistor between it and the +3.3V power supply; in addition, the transistor will remove V_BE from the circuit, which means that the resistence of this component must be roughly (3.3V - 0.7V)/(0.69 mA), or 3.745 kOhms. In my final circuit design, I used a 3.3 kOhm resistor as it was the closest one I could find in lab, meaning that the final current draw was likely 0.07 mA, which still falls far under the maximum current that the FPGA board can use.\nTable 3 below shows all the calculated voltages, currents, and resistances used for this circuit.\n\n\n\nTable 3: Calculated Component Values\n\n\n\n\n\n\n\n\n\nComponent/Measurement\nCalculated Value\n\n\n\n\nV_CE (voltage from Emitter to Collector)\n3.3 V\n\n\nV_BE (voltage drop from Base to Emitter)\n0.7 V\n\n\nI_C (anticipated current drawn from the emitter to the collector)\n38.18 mA\n\n\nh_FE (DC gain relative to current I_C)\n55\n\n\nI_B (current necessary to turn on the PNP transistor)\n0.69 mA\n\n\nR_transistor (current-limiting resistor between the FPGA and the emitter)\n3.745 kOhms\n\n\n\n\n\n\n\n\n\nSimilar to the previous Lab, in this lab each individual seven segment display was connected to a common anode (in this case, the output emitter of a PNP transistor). Each of the cathodes was attached via a resistor to the FPGA output pins onboard the E155 Breadboard Adapter. In similar fashion to what was described in Lab 1, setting the board up such that each cathode has a resistor allows for each of the diodes to be equally bright, as they all start at the same voltage drop and resultantly will draw the same current if powered (current being directly correlated with their lumosity).\nThe pin numbers, besides pin D, were kept the same as Lab 1 (it was later realized that the print of Pin 18 looks extremely similar to Pin 10, and that was why the system wasn’t working when Pin 10 was being powered; the system now works where Pin D is assigned to Pin 18). There are only three fundamental differences: two common anodes, two sets of A-G pins, and the presence of transistors within the circuit.\n\n\nThe dual display had two common anodes, which were how control over multiplexing was done. At any one time, there were two “states” assumed to exist within the system; in one state, the display on the right was turned on (S0), and in the other, the display on the left (S1)\n\n\n\nSince only a single module calculating the seven-segmenet display could be used at any one time, the corresponding pins of each cathode were connected to each other (i.e. A1 was connected to A2, B1 to B2, etc.). This meant that if both the common anodes had been lit up at the same time, both displays would show the same value, rather than only one lighting up.\n\n\n\nThe common anodes were controlled via the PNP transistors. In doing so, it was possible to only light up one display at a time, while only performing one calculation of the seven segment display.\nThe final schematic of this system can be seen in Figure 7\n\n\n\n\n\n\nFigure 7: Dual Seven Segment LED Matrix Schematic\n\n\n\n\n\n\n\n\nThere are two DIP switches used in this lab, one that is breadboarded and controls the output of the rightmost display, and one that is soldered onto the E155 board and is used the left-most display. The same logic as the previous labs applies to both DIP switches, where the rightmost pin is used as the lowest-order bit. The on-board DIP switches did not require any additional resistrs, as there is an integrated pull-up resistor as detailed on the “E155 FA Development Board Datasheet”. However, the readboarded switches did not have these pull-up resistors already; after reviewing the 78B04ST DIP switch datasheet, it was found that the switches work at 3.3V, so no voltage adjustment was necessary. However, four additional 220 Ohm resistors were added to the switch board between the switch and ground to create a pull-up resistor, and then four FPGA GPIO pins were connected into the anodes of each DIP switch. The final connections for these connections, as well as the variables to which they were assigned can be found in Figure 8\n\n\n\n\n\n\nFigure 8: 4-Pin DIP Switch Schematic\n\n\n\n\n\nThe final necessity for this lab is a set of five LEDs to display the binary summation of the two switches. For this project, a SSA-LXB10TW-GF-LP was used. Since the LED’s require a 2.1 voltage drop across them, very similar to the LEDs inside the seven segment array, 220 Ohm resistors were used for each LED while they drained to ground. This resulted in the corresponding schematic (Figure 9). Only 5 of the 10 LED-Diode Display were used.\n\n\n\n\n\n\nFigure 9: 10-LED Display Schematic\n\n\n\n\n\n\nThe final circuit is mainly controlled by the FPGA, except for the 3.3V that supplies the current for the seven segment voltage. The final circuit can be seen in Figure 10.\n\n\n\n\n\n\nFigure 10: Overall Schematic\n\n\n\n\n\n\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed.\nIf future development desired, additional phases or multiplexed digits could be added quite easily, especially if scaled by 2, as the multiplexing is controlled by each digit of counter; hypothetically, if an additional two numbers needed to be added, two more switches could be set up on the breadboard in similar fashion, the counter could be assigned based on the state of two bits within counter (for a total of four states, rather than two), and the multiplexing would occur via four PNP transistors that move to four common anodes. Scaling is extremely possible with this design.\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed both visually and with the aid of a test bench. The program is able to multiplex successfully without having the two LEDs bleed over, and all digits are equally lit for each segment, and proper calculations for the PNP transistor can be found above.\nI spent a total of 13.5 hours working on this lab, with roughly four of them spent on the lab writeup if including the planning of the modules and compiling all of the necessary diagrams."
  },
  {
    "objectID": "projects/e-155_website/labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "projects/e-155_website/labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "Lab 2 Writeup",
    "section": "",
    "text": "Hours Spent: 13.5, Mapped with Toggl Track\n\n\nIn this lab, a design was developed to display the output of two 4-pin DIP Switches on a dual seven segmenet LED matrix, such that each four-pin switch was mapped to one display. The sum of these two values was then displayed on a set of five LEDs. The dual seven segment display is lit up using the same function as in Lab 1. Resultantly, it was necessary to multiplex the dual segment such that only one common anode was powered at a time. In addition, due to the current draw required on the display, the +3.3V regulator on the E155 Board was used to power the seven segment display (with the assumption that a computer would be able to supply the required amount of current). In addition, to prevent the current from flowing directly through the FPGA, the common anode was turned on and off using a PNP transistor setup. The LED display needed to be breadboarded, as well, because there are only a total of 4 FPGA-controllable LEDs onboard the development board. A 10-LED display was used to show the sum of each of the bits for this program.\n\n\n\n\n\nFrom the top layer down, it was understood that there would be the blocks displayed in the diagram depicted below.\n\n\n\n\n\n\nFigure 1: Block Diagram of Modules\n\n\n\nWhen encoded, the lab resultantly consisted of the above modules. They are explained in the table (Table 1) below.\n\n\n\nTable 1: Module Functions\n\n\n\n\n\n\n\n\n\nModule Name\nModule Function\n\n\n\n\ntop.sv\nPuts together lab2. Generates a clock that will run the program, and outputs variables to the necessary pins.\n\n\nlab02.sv\nRuns an always_ff block to determine the current state and the next state of the system. Runs combinational logic blocks of dual_seven_segment and led_summation for required seven segment and led logic\n\n\ndual_seven_seg.sv\nCalls on the seven segment block from Lab 1. According to the clock’s counter, half the time will return seven segment for one switch, and half the time will return the seven seg output for the other\n\n\nseven_segment.sv\nUses combinational logic to determine which seven segment cathodes to turn on, and which to turn off.\n\n\nled_summation.sv\nAdds together the collected 4-bits of the two switches and returns their binary equivalent as a 5-bit array\n\n\n\n\n\n\nSome important notes about this layout is that the clock is used to determine a state, S0 or S1, which will determine which display is turned on at any given time. In state S0, the system would rely on one switch (s1); in this case, seven_segment would be called on for that switch only. The system would then turn a corresponding anode on and off using the PNP resister; in this case, since its a PNP resistor, it needed to be turn “off” to turn the system on. In state S1, the output of seven_segment instead relies on the output of switch s2, and will return the opposite output for the anode display. The logic for this can be found in Table 2, the following can be said for each of the states.\n\n\n\nTable 2: State Logic\n\n\n\n\n\nstate\nSwitch Used for Seven Segment Logic\nAnode 1\nAnode 2\n\n\n\n\nS0\ns1\n0 (i.e. Display 1 is on)\n1 (Display 2 is off)\n\n\nS1\ns2\n1\n0\n\n\nX\nan error has occured, s = 0\n1\n1\n\n\n\n\n\n\nOnce these modules were all written, they were compiled, checked for errors, and finally put into Questa for testing.\n\n\n\nTwo test benches were written for this lab. The first one checks to make sure that lab02.sv as a whole can run, and correctly lights up the LEDs as seen fit. Because direct control of the counter can’t be gotten when calling on this upper-level module, the testbench instead only checked that at least one of the outputs of the potential seven segment outputs was correct. The second was used to determine that the proper segment was lit up when the correct switch/state was entered into the dual_seven_seg module. In the case of both, a testvector file was composed and assembled using Python to make sure that all possible options were checked for and confirmed. This Python program can be found in Github, at this_file.py\n\n\nIn order to make sure that all cases were covered, the test vectors were created by running a for-loop to generate a series of switches; each of these switch combinations was used to generate a potential segment output, and finally a summation-vector was made that could be called on to correctly add the sum of both segments to the end. The python file then printed a series of strings of the form\nswitch1_switch2_segment1_segment2_summed led values\nBy running two for loops to cycle through all potential switch values, it can be confirmed that all potential values within the system have been reached. Within the test bench itself, the system uses an or expression to confirm that at least one of the segment outputs is equal to the segment output of the system. It also confirms that the led_summation is working as anticipated.\nUsing this testbench, confirmation of the functionality of the whole of lab02 was completed, as all tests could be run without failure (Figure 2)\n\n\n\n\n\n\nFigure 2: Output of Running lab02_tb.sv in Questa\n\n\n\n\n\n\nIn order to make sure that all cases were covered, the test vectors for this testbench were created by running a for-loop to generate a series of switches, similar to lab02 testbench. However, these nested for-loops were nested in one final for-loop, which acertained which state the system was in; each of these switch combinations was used to generate a potential segment output, and finally a summation-vector was made that could be called on to correctly add the sum of both segments to the end. The python file then printed a series of strings of the form\nswitch1_switch2_state_segment_anode1_anode2\nBy running two for loops to cycle through all potential switch values, it can be confirmed that all potential values within the system have been reached. Within the test bench itself, the system uses an or expression to confirm that at least one of the segment outputs is equal to the segment output of the system. It also confirms that the led_summation is working as anticipated.\nUsing this testbench, confirmation of the functionality of the whole of lab02 was completed, as all tests could be run without failure (Figure 3)\n\n\n\n\n\n\nFigure 3: Output of Running lab02_tb.sv in Questa\n\n\n\nWith this confirmation that the logic of the modules were working, it was possible to then move on to physical implementation of the program on the actual FPGA and hardware.\n\n\n\n\n\nThe design was developed based on work from Lab 1. The same seven segmenet module was used within a double multiplexer, which used the clock to switch back and forth between powering the two common anodes of the dual display. Using multiplexing, the two values were displayed.\nBecause the final system was multiplexing between two segments, this means that the common anode of a given seven-segment LED must be able to be turned OFF. In the original design for the seven-segment display, the common anode had been plugged in directly to the +3.3V of the development board, and in this way circumvented being powered by the FPGA board (which can not supply more than 0.8 mA at a given time). Attempting to power the seven-segment display directly won’t work (as will be explained in Section 1.3.1) unless you want to short your board. Resultantly, two PNP 2N3906 transistors were used, wherein the FPGA was used only to turn the transistor on and off, allowing the +3.3V coming from the Development board to flow within the circuit (once again, circumventing using the FPGA as a current supply directly).\n\n\nBeforehand, to ensure proper requisites were met for powering the seven segment display that everything was properly set up for the PNP transistor and the resistors in the circuit, some simple mathematial calculations were performed to ensure proper voltage and current was kept throughout the circuit.\nThe transistors we were using were 2N3906 PNP transistors. PNP transistors have three terminals; the base, which controls if the PNP is on or off, the emitter, where electrons come from, and the collector, where the electrons go (Figure 4). For PNP transistors to work, there must be enough of a voltage gap between the base voltage and the emitter voltage that current can flow from one too the other; when this happens, current can also flow from the emitter to the collector, with the assumption that the voltages being used do not break or short out the transistor itself.\n\n\n\n\n\n\nFigure 4: PNP Transistor Diagram\n\n\n\nTo determine these limitations, it was necessary to know three things: the voltage drop across the collector to the emitter (V_CE), the voltage drop across the base to the emitter (V_BE), and finally the maximum current draw that would flow from the collector to the emitter (I_CE).\nAccording to the PNP’s datasheet, on average the V_CE drop is 3.3 V. The value of V_BE is, as with most transistors, assumed to be about 0.7 V. To start out with, the primary goal of this circuit should be to power the FPGA board without shorting it by sending too much current through it via the emitter to base connection on the board. Resultantly, a resistor should be placed between the FPGA’s output GPIO pin and the base of the transistor such that the current is less than the maximum possible current that can be sent into the board. This can be configured according to the datatable for the GPIO pins (Figure 5), where it can be seen that the maximum current that should be sent into or out of the FPGA board is 0.8 mA. The maximum current we will be sending into our board is based on the resistor values that we install for the diodes with the dual segment display. With the assumption that we use the same 220 Ohm resistors we were originally using, the current draw through each of these resistors will be slightly reduced from what was considered in Lab 1.\n\n\n\n\n\n\nFigure 5: GPIO Current Draw Pins for FPGA Board\n\n\n\nFirst and foremost, I intend to power the LED’s using 3.3V, but these volts will first travel across the transistor, which is dependent on the current I_C traveling through the circuit. Assuming that this is relatively negligable (see Figure 15 on the PNP Datasheet, to observe that most of the Voltage removed for current lying under 60 mA is close to 0.1 V), and knowing that per diode line there will be an anticipated voltage drop of 2.1 V, that means that any one resistor will need to remove 3.3 - 2.1 Volts, or 1.2 V, from the circuit. When traveling across a 220 Ohm resistor, this will result in a current of roughly 5.45 mA. Assuming that we’ll be powering seven segments at any one time (the maximum amount possible), this means that the total current draw that can be expected is 38.18 mA. We can then compute the necessary amount of current, I_B, that will need to travel through the base in order to turn this circuit on. Using the gain terms found in the datasheet (Figure 6), it can be seen that for a given current I_C = 40 mA, the gain will be roughly 50 around room temperature.\n\n\n\n\n\n\nFigure 6: Table of the Voltage Drop V_CE and Gain of PNP Transistor\n\n\n\nThis means that the corresponding current I_B for the circuit is 38.18 mA/50 = 0.69 mA. In the case of I_B, there is only one resistor between it and the +3.3V power supply; in addition, the transistor will remove V_BE from the circuit, which means that the resistence of this component must be roughly (3.3V - 0.7V)/(0.69 mA), or 3.745 kOhms. In my final circuit design, I used a 3.3 kOhm resistor as it was the closest one I could find in lab, meaning that the final current draw was likely 0.07 mA, which still falls far under the maximum current that the FPGA board can use.\nTable 3 below shows all the calculated voltages, currents, and resistances used for this circuit.\n\n\n\nTable 3: Calculated Component Values\n\n\n\n\n\n\n\n\n\nComponent/Measurement\nCalculated Value\n\n\n\n\nV_CE (voltage from Emitter to Collector)\n3.3 V\n\n\nV_BE (voltage drop from Base to Emitter)\n0.7 V\n\n\nI_C (anticipated current drawn from the emitter to the collector)\n38.18 mA\n\n\nh_FE (DC gain relative to current I_C)\n55\n\n\nI_B (current necessary to turn on the PNP transistor)\n0.69 mA\n\n\nR_transistor (current-limiting resistor between the FPGA and the emitter)\n3.745 kOhms\n\n\n\n\n\n\n\n\n\nSimilar to the previous Lab, in this lab each individual seven segment display was connected to a common anode (in this case, the output emitter of a PNP transistor). Each of the cathodes was attached via a resistor to the FPGA output pins onboard the E155 Breadboard Adapter. In similar fashion to what was described in Lab 1, setting the board up such that each cathode has a resistor allows for each of the diodes to be equally bright, as they all start at the same voltage drop and resultantly will draw the same current if powered (current being directly correlated with their lumosity).\nThe pin numbers, besides pin D, were kept the same as Lab 1 (it was later realized that the print of Pin 18 looks extremely similar to Pin 10, and that was why the system wasn’t working when Pin 10 was being powered; the system now works where Pin D is assigned to Pin 18). There are only three fundamental differences: two common anodes, two sets of A-G pins, and the presence of transistors within the circuit.\n\n\nThe dual display had two common anodes, which were how control over multiplexing was done. At any one time, there were two “states” assumed to exist within the system; in one state, the display on the right was turned on (S0), and in the other, the display on the left (S1)\n\n\n\nSince only a single module calculating the seven-segmenet display could be used at any one time, the corresponding pins of each cathode were connected to each other (i.e. A1 was connected to A2, B1 to B2, etc.). This meant that if both the common anodes had been lit up at the same time, both displays would show the same value, rather than only one lighting up.\n\n\n\nThe common anodes were controlled via the PNP transistors. In doing so, it was possible to only light up one display at a time, while only performing one calculation of the seven segment display.\nThe final schematic of this system can be seen in Figure 7\n\n\n\n\n\n\nFigure 7: Dual Seven Segment LED Matrix Schematic\n\n\n\n\n\n\n\n\nThere are two DIP switches used in this lab, one that is breadboarded and controls the output of the rightmost display, and one that is soldered onto the E155 board and is used the left-most display. The same logic as the previous labs applies to both DIP switches, where the rightmost pin is used as the lowest-order bit. The on-board DIP switches did not require any additional resistrs, as there is an integrated pull-up resistor as detailed on the “E155 FA Development Board Datasheet”. However, the readboarded switches did not have these pull-up resistors already; after reviewing the 78B04ST DIP switch datasheet, it was found that the switches work at 3.3V, so no voltage adjustment was necessary. However, four additional 220 Ohm resistors were added to the switch board between the switch and ground to create a pull-up resistor, and then four FPGA GPIO pins were connected into the anodes of each DIP switch. The final connections for these connections, as well as the variables to which they were assigned can be found in Figure 8\n\n\n\n\n\n\nFigure 8: 4-Pin DIP Switch Schematic\n\n\n\n\n\nThe final necessity for this lab is a set of five LEDs to display the binary summation of the two switches. For this project, a SSA-LXB10TW-GF-LP was used. Since the LED’s require a 2.1 voltage drop across them, very similar to the LEDs inside the seven segment array, 220 Ohm resistors were used for each LED while they drained to ground. This resulted in the corresponding schematic (Figure 9). Only 5 of the 10 LED-Diode Display were used.\n\n\n\n\n\n\nFigure 9: 10-LED Display Schematic\n\n\n\n\n\n\nThe final circuit is mainly controlled by the FPGA, except for the 3.3V that supplies the current for the seven segment voltage. The final circuit can be seen in Figure 10.\n\n\n\n\n\n\nFigure 10: Overall Schematic\n\n\n\n\n\n\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed.\nIf future development desired, additional phases or multiplexed digits could be added quite easily, especially if scaled by 2, as the multiplexing is controlled by each digit of counter; hypothetically, if an additional two numbers needed to be added, two more switches could be set up on the breadboard in similar fashion, the counter could be assigned based on the state of two bits within counter (for a total of four states, rather than two), and the multiplexing would occur via four PNP transistors that move to four common anodes. Scaling is extremely possible with this design.\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed both visually and with the aid of a test bench. The program is able to multiplex successfully without having the two LEDs bleed over, and all digits are equally lit for each segment, and proper calculations for the PNP transistor can be found above.\nI spent a total of 13.5 hours working on this lab, with roughly four of them spent on the lab writeup if including the planning of the modules and compiling all of the necessary diagrams."
  },
  {
    "objectID": "projects/e-155_website/labs/lab4/lab4.html",
    "href": "projects/e-155_website/labs/lab4/lab4.html",
    "title": "Lab 4 Writeup",
    "section": "",
    "text": "Hours Spent: 32, Mapped with Toggl Track\n\n\nIn this lab, a STM32L432KCU Microcontroller Unit (the MCU) was used to control a SM231508-1 Speaker to play a series of different musical songs. In order to do so, the MCU was programmed to control the E155 Breadboard Adapter v4 board to output voltages on GPIO pins using an internall phase-lock looped clock, as well as two timers. Through the design of several structs, the enabling of cross communication between pins, and careful reading of the datasheet, the microcontroller was configured to play songs like “Fur Elise” as well as “Megalovania” and several other recognizable game tunes.\n\n\n\n\n\nSegger Embedded Studio 8.16a was used to program all modules. In order to do so, it was necessary to first find all relevant and necessary components for this lab, as well as compile a series of libraries that would be used in its construction. Of note, we were explicitly told to not use the inbuilt stm32l432xx.h header file from the Segger’s library; we wrote all headers and c code for this class from scratch to ensure that we understood all necessary components.\n\n\n\n\n\n\n\n\n\nThe system that was designed for this lab required this simple framework (Figure 1) to function: the main point was that a clock (CLOCK) would be generated and sent into two timers (FREQUENCY_TIMER and DELAY_TIMER); the first would control the frequency of the speaker (GPIO_OUT), the second would control for how long the frequency was played. As a result, we would need to make four c files:\n\nmain.c: a C file that sits above all the headers and other c files in order to properly assign the enable pins and run the actual music itself.\nclk.c/clk.h: A paired C and C header file that assign the proper variables and memory allocations for running clocks onboard the MCU. This looks specifically at pages 175-246 of the STM Reference Manual to assign all relevant materials. Further details of what needed to be assigned of this can be found in Clock Memory and Layout (Section 1.2.1.1).\ntimer.c/timer.h: A paired C and C header file that assign the proper variables and memory allocation for running timers onboard the MCU. It uses logic gathered from pages 817-980 in the STM Reference Manual and pages 51-58 in the STM32L432xx Datasheet. Further details of what needed to be assigned of this can be found in Timer Layout.\ngpio.c/gpio.h: A paired C and C header file that assign the proper variables and memory allocation for connecting to GPIO pins onboard the mcu. It uses logic gathered from pages 258-275 in the STM Reference Manual. Further details of what needed to be assigned of this can be found in Timer Layout (Section 1.2.1.3).\n\n\n\nBefore programming anything, all necessary parameters to control a clock were written out using Figure 13 in the Reference Manual. For this specific scenario, I wanted to control the phase-locked loop clock to gain experience with varying an onboard clock within the program. This required the layout of the memory bank (based on pages 243-246 in the Reference Manual), as well as the variables assigned as indicated in Table 1 and Table 2. In order to easily access each memory bit, I set up a structure within the header file (called RCC_STM32L432xx_TypeDef), which I then built off the RCC base located at 0x40021000UL to control each individual register on the MCU. There are two functions for this program: configurePLL and configureClock; configurePLL sets up the PLL to be connected to the onboard MSI clock, and configureClock sets up a clock to be delivered to the rest of the board.\n\n\n\nTable 1: configurePLL Memory Assignments\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nPLLON (beginning of configurePLL)\n0 at bit 24\nRCC, Configuration Register (CR)\nSo that the clock can be properly reconfigured, it must be turned off\n\n\nPLLRDY\nnot assigned, but wait until its 0\nRCC, Configuration Register (CR)\nWait to make sure you can reprogram this bit\n\n\nPLL_SRC\n1 at bit 0\nRCC, PLL Configuration Register (PLL_CFGR)\nTurning on PLL and connecting it to the MSI (40 MHz) internal clock\n\n\nPLLR\n0b00 from bits 25:26\nRCC, PLL Configuration Register (PLL_CFGR)\nDividing the incoming clock (MSI) by a factor of 2\n\n\nPLLM\n0b000 from bits 4:6\nRCC, PLL Configuration Register (PLL_CFGR)\nDividing the output clock (Voltage Controlled Oscillator Output) by 1\n\n\nPLLN\n10 from bits 14:18\nRCC, PLL Configuration Register (PLL_CFGR)\nMultiplying the output clock by 16\n\n\nPLLON (end of configurePLL)\n1 at bit 24\nRCC, Configuration Register (CR)\nSo that the PLL is now running again, reconfigured\n\n\nPLLCLK\n1 at bit 24\nRCC, PLL Configuration Register (PLL_CFGR)\nSo that the PLL is sent out of the register as the internal clock\n\n\n\n\n\n\n\n\n\nTable 2: configureClock Memory Assignments\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nSW\n0b11 at bits 0:1\nRCC, Configuration Register\nTo set up the output clock to be PLL\n\n\nSWS\n0b11 at bits 2:3\nRCC, Configuration Register\nTo make sure that the PLL has been configured on, we wait for this to be 1\n\n\n\n\n\n\n\n\n\nFor this specific scenario, I wanted to control two timers (as specified in Figure 1), one that would be used to control the frequency of the speaker, and the other that would be used to control how long the frequency was played. This required the layout of the memory bank (based on pages 814-816 in the Reference Manual), as well as the variables assigned as indicated in ?@tbl-timer. In order to easily access each memory bit, I set up three structures within the header file for Timers 2 and 3, Timers 15 and 16, and Timers 6 and 7 (since each has some variables unassigned, and I didn’t want to accidentaly assign the wrong bits if I happened to be writing to the wrong clock on accident). These structures are called TIM_67_STM32L432xx_TypeDef (Timers 6 and 7), TIM_ALL_STM32L432xx_TypeDef (Could apply to any timer, but is constrained in potential variables for more complex operations (i.e. runs all timers similar to timers 6 and 7)), TIM15_STM32L432xx_TypeDef (Timer 15), and TIM_23_STM32L432xx_TypeDef (Timers 2 and 3). Of these, I built all Timers as defined by their memory as found in Table 2, page 68 and 69 of the reference manual (placed below).\n\n\n\n\n\n\n\n\nThe variables were assigned for the following values in order to run: in total, I have four functions: delay(TIM_67_STM32L432xx_TypeDef * DELAY_TIMx, uint32_t time), configure_TIM23_PWM(TIM_23_STM32L432xx_TypeDef *  TIMx, int freq, double duty), configure_TIM2_CH1_PWM(int freq, double duty), and configure_TIMx(TIM_67_STM32L432xx_TypeDef *  TIMx). Each of these functions is meant to set up a timer or perform a function using said timer. configure_TIM23_PWM is meant to set up either Timers 2 or 3 acting in PWM mode. configure_TIM2_CH1_PWM was created to control specifically timer TIM2, and noticeably does not take in an input TypeDef clock. There is an additional function within the C file with a similar name, which overloads this function, and performs a similar function but with a predecided frequency and duty cycle for the timer, which was used to organize when designing the other functions; it cannot be called from the main C function. configure_TIMx is meant to set up a given timer to begin running in counter only (since it is for Timers 6 and 7, which cannot generate their own outputs). Finally, delay assumes that the user is using configure_TIMx to design a timer, and with the predetermined parameters for this function (i.e. generates a signal at 77 kHz), waits for time number of miliseconds. I will specify only the variables as defined in the configure_TIM23_PWM function, as this is what is used within the program to setup the desired frequencies for the speaker’s singing, and all the logic used for the configuration of CNTR, ARR, and CCR is used for setting up TIM6.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nCC1S\n0b00 at bits 0:1\nCapture/Compare Register 1 (CCR1)\nConfigure Channel 1 of the clock as Output\n\n\nOC1M\n0 at bit 16, 0b111 at bits 4:6\nCapture/Compare Register 1 (CCR1)\nConfigure the timer in PWM mode 2 (i.e. high when the counter is greater than the assigned CCR value)\n\n\nCC1E\n1 at bit 0\nCapture/Compare Enable Register (CCER)\nSet OC1 as the active channel\n\n\nCC1P\n0 at bit 1\nCapture/Compare Enable Register (CCER)\nMake OC1’s “active” be 1 (i.e. when its “on”, its output voltage)\n\n\nECE\n0 at bit 14\nSlave Mode Control Register (SMCR)\nSets the external clock to 0 to make sure that we are using the internal clock for this timer\n\n\nSMS\n0 at bit 16, 0b000 at bits 0:2\nSlave Mode Control Register (SMCR)\nSets the internal clock to be used when CEN is enabled\n\n\nETF\n0b011 at bit 8\nSlave Mode Control Register (SMCR)\nSets the external trigger factor such that it divides the input clock by 8\n\n\nPSC\n256\nPrescaler Register\nSets the input clock to be divided by 256 (slowing the timer down)\n\n\nARR\n9 kHz / desired frequency\nAuto-reload Register (ARR)\nSets the value the counter will get to (sets frequency of timer)\n\n\nCCR1\nduty cycle * ARR’s value\nCapture/Compare Register 1 (CCR1)\nSets the value the counter is compared against (generates output and duty cycle)\n\n\nOC1PE\n1 at bit 3\nCapture/Compare Mode Register 1 (CCMR1)\nEnables the preload for this channel. Necessary for PWM mode unless configure in One-Pulse mode\n\n\nARPE\n1 at bit 7\nControl Register 1 (CR1)\nEnable the auto-reload preload feature\n\n\nCC1G\n1 at bit 1\nEvent Generation Register (EGR)\nEnable the Capture/Compare 1 Generator\n\n\nUG\n1 at bit 0\nEvent Generation Register (EGR)\nEnable the update generation; this will allow us to continue counting over and over via taking advantage of the shadow preload registers\n\n\nCMS\n0b00 at bits 5:6\nControl Register 1 (CR1)\nSet the timer to work in edge-aligned mode\n\n\nDIR\n0 at bit 4\nControl Register 1 (CR1)\nSet the counter to be an upcounter\n\n\nCEN\n1 at bit 0\nControl Register 1 (CR1)\nEnable the counter\n\n\n\n:Timer Commands Table{tbl-colwidths=“[10,30, 30,50]”}\n\n\n\n\n\n\nThere are two primary things that need to be done to set up the GPIO pins on board the MCU: the first is that they are set up in a mode that can communicate with the timer (in this case, I chose to use Alternate Function 1, which allows PA5 to communicate with Timer 2’s Channel 1), and the second that the pin is enabled. There are four functions within my gpio.c class, but in this instance only one of these functions is necessary, the setModeOfPinA function. This function sets the GPIO’s mode into the “alternate function” mode, which will allow certain pins to interact with other on-board pins.\nTo do this, the MODER register of the GPIO structure that I constructed in header needs to have the two bits that refer to the GPIO pin on the board set to 0b10: after this, AF logic assigned within the main function will be able to correctly interact with and assign values to the pin.\n\n\n\nThe final C file of this lab is the main.c, which compiles all of the code together. Inside, it calls the configureClock function (which calls configurePLL), sets the mode of the pin, configures the timers, and connects the clocks to the timers and the pins. Finally, it also assigns the alternate function desired to the pin via the low alternate function register (GPIOA - AFRL); I referred again to Table 15 in the MCU Datasheet.\n\n\n\n\nThe frequencies generated by the speaker were confirmed to be accurate through the use of an iPhone tuner app “Tuner T1”, and via calculations for each of the relevant frequencies and time delays.\nTimer 2 was used to generate frequencies. Because it has both a prescaler and the internal variable ETF (external trigger factor), it was able to divide the incoming frequency (in this case, the 20MHz generated by the PLL timer) twice. The PSC was set to be 32, and the ETF to be 8, which effectively scales the timer to run at a 75757.58 Hz. The frequencies that it is able to send the speaker, then, vary depending on the size of the array, and potentially additional configurations you can make to the duty cycle. The highest frequency that could be produced using this PSC and ETF setup \\[\n\\frac{75757.58}{2} Hz = 37878.79 Hz\n\\]\nThis is because the speaker must be turned off and on to generate one full wave; in order for a full period to pass, the output must be turned off and on again, meaning that CCR1 would be set to 1, and ARR would be set to 2 in this scenario.\nThe lowest frequency possible with this clock would be one where the counter counts to the maximum value of ARR. I am currently assuming that the user may chose to use Timer 2 or Timer 3, so although Timer 2 could have an array of up to 2^32 - 1 counts, I will first consider both Timers together (where Timer 3 is constrained to 16 bits). In this scenario, the maximum that the counter could ever reach would be 2^16-1, or 65535. In this case, the lowest possible frequency would be given by\n\\[\n\\frac{75757.58}{65535} Hz = 1.16 Hz\n\\]\nHowever, I would also like to consider possible future reiterations of this design that could allow for even more flexibility with frequency and duration: in the case where we only use Timer 2, and we include the 32 bits that Timer 2 can use for ARR, the lowest possible frequency is 17.64 µHz. If we additionally consider that we could arrange an additional function that sets the output to its inverse whenever the counter is set (effectively creating a 50% duty cycle for half the frequency), we would be able to get either 0.578 Hz for the 15 bit timer, or as low as 8.82 µHz for the 32 bit timer.\nAs it appies to the accuracy of the timer, the timer should be within 1% of of a given frequency relative to 1000 Hz; because it is an integer value, sometimes values may be clipped for the frequency. However, this is a minimal amount of frequency clipping. 1% of the frequency range, in this case is given by\n\\[\n\\frac{1000-220}{100} = 7.8 Hz\n\\]\nIn order for the frequency to be within 1% of 220 Hz, for example, it would need to be between about 213 and 227 Hz. With our current frequency, the integer division of our clock frequency over time would mean that each square wave would happen over a period of \\(\\frac{75757.58}{220} = 344.4\\) counts. If this is rounded to the nearest integer using the ceil function in C (i.e. 344), the actual Hz that would be generated by the speaker would be 220.2 Hz, well within our required frequency limit. If we go to the maximum Hz range, we can see that the final length of the cycle would be \\(\\frac{75757.58}{1000}\\) or 75.75 counts, which would become 76. In this case, the final generated frequency would be 996.81, which is 0.4% from it’s intended value relative to the range (using \\(\\frac{1000-996.81}{1000-220} = 0.4%\\)), which inside our desired 1% range.\nAs for the delay timer, I currently have it configured so that it prescales by 512. Because there is no external filter trigger in this instance, we do not divide by any additional values, and so the frequency of the counter within TIM6 is given by \\[\n\\frac{20}{512} MHz = 39 kHz\n\\]\nThe shortest possible delay for this timer would resultantly be the length of one counter, i.e. 1/39 kHz, which in this case is 25.6 µs. In the case that we would like it to last as long as possible, the longest period would be when 2^16 - 1 clock cycles occur (i.e. ARR = 65535), which would mean a longest period of 1.678 seconds. In our case, since we are playing music that has, at maximum, a whole note that lasts a second, all the music is well within the range of possible note lengths.\n\n\n\n\nThe hardware setup for this lab was relatively simple. Because the speaker requires a greater current that the MCU GPIO pins can provide, I used an LM386 amplifier to set-up my system. This chip was set up for a gain of 50 (relative to Figure 9-5 on the data sheet), and has a 10k potentiometer place at the output of pin 3 in order to control the volume of the speaker Figure 2.\n\n\n\n\n\n\nFigure 2: Schematic Diagram\n\n\n\n\n\n\nBecause this lab required the implementation of multiple parts, I used two strategies to confirm that my code was working as expected. The first was the “Build and Debug” mode that is found inside of Segger Embedded Studio, which allows you to see the internal memory of the MCU as its running. With this, I was able to confirm when my counter was working, and additionally catch bugs. Some relevant bugs that I caught using this strategy were:\n\nI did not initially realize that Timer 2 had 32 bits, and resultantly the CCR1 was consistently being set to a negative value. This meant that counter was always greater than CCR1, and because it was set to output high when this was the case (PWM mode 2), the LED never turned off. After setting the values within counter (CNTR), ARR, and CCR1 to display their decimal values, I realized that CCR1 was displaying a negative number, and so I altered the upper bits of both ARR and CCR1 so that they were not negative.\nFor a long time I was not able to get the output traveling to GPIO A. I noticed while debugging that GPIO was not updating at all, even though I had confirmed before adding the timer that it was able to update. When I cross-checked my code with a demo I made to blink the LED, I quickly realized that I had accidentally set the GPIO B pins, not the GPIO A ones.\n\nFor an additional form of testing, specifically to confirm that I was seeing the anticipated frequencies, I hooked up an LED to my output in order to observe it blinking at low Hz. This helped me confirm that the calculations that I had made for the frequencies were correct (i.e. the delay of 1 second worked, and that the frequency of blinking was similarly accurate). Although there are no test benches for this program, I believe that in the end this worked effectively to debug my system as a whole.\n\n\n\nIn conclusion, this lab was a success in configuring an MCU board using C headers and functions. It additionally provided insight into the internal structures and memories found on an MCU, as well as provided a comprehensive understanding of all the relevant background required for working with MCU (Figure 3).\n\n\n\n\n\n\n\n\nFigure 3: Video of the MCU playing three different songs back to back.\n\n\n\n\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed both visually and with the aid of a test bench. The program is able to multiplex successfully without having the two LEDs bleed over, and all digits are equally lit for each segment, and proper calculations for the PNP transistor can be found above.\nI spent a total of 13.5 hours working on this lab, with roughly four of them spent on the lab writeup if including the planning of the modules and compiling all of the necessary diagrams."
  },
  {
    "objectID": "projects/e-155_website/labs/lab4/lab4.html#lab-4-digital-audio",
    "href": "projects/e-155_website/labs/lab4/lab4.html#lab-4-digital-audio",
    "title": "Lab 4 Writeup",
    "section": "",
    "text": "Hours Spent: 32, Mapped with Toggl Track\n\n\nIn this lab, a STM32L432KCU Microcontroller Unit (the MCU) was used to control a SM231508-1 Speaker to play a series of different musical songs. In order to do so, the MCU was programmed to control the E155 Breadboard Adapter v4 board to output voltages on GPIO pins using an internall phase-lock looped clock, as well as two timers. Through the design of several structs, the enabling of cross communication between pins, and careful reading of the datasheet, the microcontroller was configured to play songs like “Fur Elise” as well as “Megalovania” and several other recognizable game tunes.\n\n\n\n\n\nSegger Embedded Studio 8.16a was used to program all modules. In order to do so, it was necessary to first find all relevant and necessary components for this lab, as well as compile a series of libraries that would be used in its construction. Of note, we were explicitly told to not use the inbuilt stm32l432xx.h header file from the Segger’s library; we wrote all headers and c code for this class from scratch to ensure that we understood all necessary components.\n\n\n\n\n\n\n\n\n\nThe system that was designed for this lab required this simple framework (Figure 1) to function: the main point was that a clock (CLOCK) would be generated and sent into two timers (FREQUENCY_TIMER and DELAY_TIMER); the first would control the frequency of the speaker (GPIO_OUT), the second would control for how long the frequency was played. As a result, we would need to make four c files:\n\nmain.c: a C file that sits above all the headers and other c files in order to properly assign the enable pins and run the actual music itself.\nclk.c/clk.h: A paired C and C header file that assign the proper variables and memory allocations for running clocks onboard the MCU. This looks specifically at pages 175-246 of the STM Reference Manual to assign all relevant materials. Further details of what needed to be assigned of this can be found in Clock Memory and Layout (Section 1.2.1.1).\ntimer.c/timer.h: A paired C and C header file that assign the proper variables and memory allocation for running timers onboard the MCU. It uses logic gathered from pages 817-980 in the STM Reference Manual and pages 51-58 in the STM32L432xx Datasheet. Further details of what needed to be assigned of this can be found in Timer Layout.\ngpio.c/gpio.h: A paired C and C header file that assign the proper variables and memory allocation for connecting to GPIO pins onboard the mcu. It uses logic gathered from pages 258-275 in the STM Reference Manual. Further details of what needed to be assigned of this can be found in Timer Layout (Section 1.2.1.3).\n\n\n\nBefore programming anything, all necessary parameters to control a clock were written out using Figure 13 in the Reference Manual. For this specific scenario, I wanted to control the phase-locked loop clock to gain experience with varying an onboard clock within the program. This required the layout of the memory bank (based on pages 243-246 in the Reference Manual), as well as the variables assigned as indicated in Table 1 and Table 2. In order to easily access each memory bit, I set up a structure within the header file (called RCC_STM32L432xx_TypeDef), which I then built off the RCC base located at 0x40021000UL to control each individual register on the MCU. There are two functions for this program: configurePLL and configureClock; configurePLL sets up the PLL to be connected to the onboard MSI clock, and configureClock sets up a clock to be delivered to the rest of the board.\n\n\n\nTable 1: configurePLL Memory Assignments\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nPLLON (beginning of configurePLL)\n0 at bit 24\nRCC, Configuration Register (CR)\nSo that the clock can be properly reconfigured, it must be turned off\n\n\nPLLRDY\nnot assigned, but wait until its 0\nRCC, Configuration Register (CR)\nWait to make sure you can reprogram this bit\n\n\nPLL_SRC\n1 at bit 0\nRCC, PLL Configuration Register (PLL_CFGR)\nTurning on PLL and connecting it to the MSI (40 MHz) internal clock\n\n\nPLLR\n0b00 from bits 25:26\nRCC, PLL Configuration Register (PLL_CFGR)\nDividing the incoming clock (MSI) by a factor of 2\n\n\nPLLM\n0b000 from bits 4:6\nRCC, PLL Configuration Register (PLL_CFGR)\nDividing the output clock (Voltage Controlled Oscillator Output) by 1\n\n\nPLLN\n10 from bits 14:18\nRCC, PLL Configuration Register (PLL_CFGR)\nMultiplying the output clock by 16\n\n\nPLLON (end of configurePLL)\n1 at bit 24\nRCC, Configuration Register (CR)\nSo that the PLL is now running again, reconfigured\n\n\nPLLCLK\n1 at bit 24\nRCC, PLL Configuration Register (PLL_CFGR)\nSo that the PLL is sent out of the register as the internal clock\n\n\n\n\n\n\n\n\n\nTable 2: configureClock Memory Assignments\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nSW\n0b11 at bits 0:1\nRCC, Configuration Register\nTo set up the output clock to be PLL\n\n\nSWS\n0b11 at bits 2:3\nRCC, Configuration Register\nTo make sure that the PLL has been configured on, we wait for this to be 1\n\n\n\n\n\n\n\n\n\nFor this specific scenario, I wanted to control two timers (as specified in Figure 1), one that would be used to control the frequency of the speaker, and the other that would be used to control how long the frequency was played. This required the layout of the memory bank (based on pages 814-816 in the Reference Manual), as well as the variables assigned as indicated in ?@tbl-timer. In order to easily access each memory bit, I set up three structures within the header file for Timers 2 and 3, Timers 15 and 16, and Timers 6 and 7 (since each has some variables unassigned, and I didn’t want to accidentaly assign the wrong bits if I happened to be writing to the wrong clock on accident). These structures are called TIM_67_STM32L432xx_TypeDef (Timers 6 and 7), TIM_ALL_STM32L432xx_TypeDef (Could apply to any timer, but is constrained in potential variables for more complex operations (i.e. runs all timers similar to timers 6 and 7)), TIM15_STM32L432xx_TypeDef (Timer 15), and TIM_23_STM32L432xx_TypeDef (Timers 2 and 3). Of these, I built all Timers as defined by their memory as found in Table 2, page 68 and 69 of the reference manual (placed below).\n\n\n\n\n\n\n\n\nThe variables were assigned for the following values in order to run: in total, I have four functions: delay(TIM_67_STM32L432xx_TypeDef * DELAY_TIMx, uint32_t time), configure_TIM23_PWM(TIM_23_STM32L432xx_TypeDef *  TIMx, int freq, double duty), configure_TIM2_CH1_PWM(int freq, double duty), and configure_TIMx(TIM_67_STM32L432xx_TypeDef *  TIMx). Each of these functions is meant to set up a timer or perform a function using said timer. configure_TIM23_PWM is meant to set up either Timers 2 or 3 acting in PWM mode. configure_TIM2_CH1_PWM was created to control specifically timer TIM2, and noticeably does not take in an input TypeDef clock. There is an additional function within the C file with a similar name, which overloads this function, and performs a similar function but with a predecided frequency and duty cycle for the timer, which was used to organize when designing the other functions; it cannot be called from the main C function. configure_TIMx is meant to set up a given timer to begin running in counter only (since it is for Timers 6 and 7, which cannot generate their own outputs). Finally, delay assumes that the user is using configure_TIMx to design a timer, and with the predetermined parameters for this function (i.e. generates a signal at 77 kHz), waits for time number of miliseconds. I will specify only the variables as defined in the configure_TIM23_PWM function, as this is what is used within the program to setup the desired frequencies for the speaker’s singing, and all the logic used for the configuration of CNTR, ARR, and CCR is used for setting up TIM6.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nCC1S\n0b00 at bits 0:1\nCapture/Compare Register 1 (CCR1)\nConfigure Channel 1 of the clock as Output\n\n\nOC1M\n0 at bit 16, 0b111 at bits 4:6\nCapture/Compare Register 1 (CCR1)\nConfigure the timer in PWM mode 2 (i.e. high when the counter is greater than the assigned CCR value)\n\n\nCC1E\n1 at bit 0\nCapture/Compare Enable Register (CCER)\nSet OC1 as the active channel\n\n\nCC1P\n0 at bit 1\nCapture/Compare Enable Register (CCER)\nMake OC1’s “active” be 1 (i.e. when its “on”, its output voltage)\n\n\nECE\n0 at bit 14\nSlave Mode Control Register (SMCR)\nSets the external clock to 0 to make sure that we are using the internal clock for this timer\n\n\nSMS\n0 at bit 16, 0b000 at bits 0:2\nSlave Mode Control Register (SMCR)\nSets the internal clock to be used when CEN is enabled\n\n\nETF\n0b011 at bit 8\nSlave Mode Control Register (SMCR)\nSets the external trigger factor such that it divides the input clock by 8\n\n\nPSC\n256\nPrescaler Register\nSets the input clock to be divided by 256 (slowing the timer down)\n\n\nARR\n9 kHz / desired frequency\nAuto-reload Register (ARR)\nSets the value the counter will get to (sets frequency of timer)\n\n\nCCR1\nduty cycle * ARR’s value\nCapture/Compare Register 1 (CCR1)\nSets the value the counter is compared against (generates output and duty cycle)\n\n\nOC1PE\n1 at bit 3\nCapture/Compare Mode Register 1 (CCMR1)\nEnables the preload for this channel. Necessary for PWM mode unless configure in One-Pulse mode\n\n\nARPE\n1 at bit 7\nControl Register 1 (CR1)\nEnable the auto-reload preload feature\n\n\nCC1G\n1 at bit 1\nEvent Generation Register (EGR)\nEnable the Capture/Compare 1 Generator\n\n\nUG\n1 at bit 0\nEvent Generation Register (EGR)\nEnable the update generation; this will allow us to continue counting over and over via taking advantage of the shadow preload registers\n\n\nCMS\n0b00 at bits 5:6\nControl Register 1 (CR1)\nSet the timer to work in edge-aligned mode\n\n\nDIR\n0 at bit 4\nControl Register 1 (CR1)\nSet the counter to be an upcounter\n\n\nCEN\n1 at bit 0\nControl Register 1 (CR1)\nEnable the counter\n\n\n\n:Timer Commands Table{tbl-colwidths=“[10,30, 30,50]”}\n\n\n\n\n\n\nThere are two primary things that need to be done to set up the GPIO pins on board the MCU: the first is that they are set up in a mode that can communicate with the timer (in this case, I chose to use Alternate Function 1, which allows PA5 to communicate with Timer 2’s Channel 1), and the second that the pin is enabled. There are four functions within my gpio.c class, but in this instance only one of these functions is necessary, the setModeOfPinA function. This function sets the GPIO’s mode into the “alternate function” mode, which will allow certain pins to interact with other on-board pins.\nTo do this, the MODER register of the GPIO structure that I constructed in header needs to have the two bits that refer to the GPIO pin on the board set to 0b10: after this, AF logic assigned within the main function will be able to correctly interact with and assign values to the pin.\n\n\n\nThe final C file of this lab is the main.c, which compiles all of the code together. Inside, it calls the configureClock function (which calls configurePLL), sets the mode of the pin, configures the timers, and connects the clocks to the timers and the pins. Finally, it also assigns the alternate function desired to the pin via the low alternate function register (GPIOA - AFRL); I referred again to Table 15 in the MCU Datasheet.\n\n\n\n\nThe frequencies generated by the speaker were confirmed to be accurate through the use of an iPhone tuner app “Tuner T1”, and via calculations for each of the relevant frequencies and time delays.\nTimer 2 was used to generate frequencies. Because it has both a prescaler and the internal variable ETF (external trigger factor), it was able to divide the incoming frequency (in this case, the 20MHz generated by the PLL timer) twice. The PSC was set to be 32, and the ETF to be 8, which effectively scales the timer to run at a 75757.58 Hz. The frequencies that it is able to send the speaker, then, vary depending on the size of the array, and potentially additional configurations you can make to the duty cycle. The highest frequency that could be produced using this PSC and ETF setup \\[\n\\frac{75757.58}{2} Hz = 37878.79 Hz\n\\]\nThis is because the speaker must be turned off and on to generate one full wave; in order for a full period to pass, the output must be turned off and on again, meaning that CCR1 would be set to 1, and ARR would be set to 2 in this scenario.\nThe lowest frequency possible with this clock would be one where the counter counts to the maximum value of ARR. I am currently assuming that the user may chose to use Timer 2 or Timer 3, so although Timer 2 could have an array of up to 2^32 - 1 counts, I will first consider both Timers together (where Timer 3 is constrained to 16 bits). In this scenario, the maximum that the counter could ever reach would be 2^16-1, or 65535. In this case, the lowest possible frequency would be given by\n\\[\n\\frac{75757.58}{65535} Hz = 1.16 Hz\n\\]\nHowever, I would also like to consider possible future reiterations of this design that could allow for even more flexibility with frequency and duration: in the case where we only use Timer 2, and we include the 32 bits that Timer 2 can use for ARR, the lowest possible frequency is 17.64 µHz. If we additionally consider that we could arrange an additional function that sets the output to its inverse whenever the counter is set (effectively creating a 50% duty cycle for half the frequency), we would be able to get either 0.578 Hz for the 15 bit timer, or as low as 8.82 µHz for the 32 bit timer.\nAs it appies to the accuracy of the timer, the timer should be within 1% of of a given frequency relative to 1000 Hz; because it is an integer value, sometimes values may be clipped for the frequency. However, this is a minimal amount of frequency clipping. 1% of the frequency range, in this case is given by\n\\[\n\\frac{1000-220}{100} = 7.8 Hz\n\\]\nIn order for the frequency to be within 1% of 220 Hz, for example, it would need to be between about 213 and 227 Hz. With our current frequency, the integer division of our clock frequency over time would mean that each square wave would happen over a period of \\(\\frac{75757.58}{220} = 344.4\\) counts. If this is rounded to the nearest integer using the ceil function in C (i.e. 344), the actual Hz that would be generated by the speaker would be 220.2 Hz, well within our required frequency limit. If we go to the maximum Hz range, we can see that the final length of the cycle would be \\(\\frac{75757.58}{1000}\\) or 75.75 counts, which would become 76. In this case, the final generated frequency would be 996.81, which is 0.4% from it’s intended value relative to the range (using \\(\\frac{1000-996.81}{1000-220} = 0.4%\\)), which inside our desired 1% range.\nAs for the delay timer, I currently have it configured so that it prescales by 512. Because there is no external filter trigger in this instance, we do not divide by any additional values, and so the frequency of the counter within TIM6 is given by \\[\n\\frac{20}{512} MHz = 39 kHz\n\\]\nThe shortest possible delay for this timer would resultantly be the length of one counter, i.e. 1/39 kHz, which in this case is 25.6 µs. In the case that we would like it to last as long as possible, the longest period would be when 2^16 - 1 clock cycles occur (i.e. ARR = 65535), which would mean a longest period of 1.678 seconds. In our case, since we are playing music that has, at maximum, a whole note that lasts a second, all the music is well within the range of possible note lengths.\n\n\n\n\nThe hardware setup for this lab was relatively simple. Because the speaker requires a greater current that the MCU GPIO pins can provide, I used an LM386 amplifier to set-up my system. This chip was set up for a gain of 50 (relative to Figure 9-5 on the data sheet), and has a 10k potentiometer place at the output of pin 3 in order to control the volume of the speaker Figure 2.\n\n\n\n\n\n\nFigure 2: Schematic Diagram\n\n\n\n\n\n\nBecause this lab required the implementation of multiple parts, I used two strategies to confirm that my code was working as expected. The first was the “Build and Debug” mode that is found inside of Segger Embedded Studio, which allows you to see the internal memory of the MCU as its running. With this, I was able to confirm when my counter was working, and additionally catch bugs. Some relevant bugs that I caught using this strategy were:\n\nI did not initially realize that Timer 2 had 32 bits, and resultantly the CCR1 was consistently being set to a negative value. This meant that counter was always greater than CCR1, and because it was set to output high when this was the case (PWM mode 2), the LED never turned off. After setting the values within counter (CNTR), ARR, and CCR1 to display their decimal values, I realized that CCR1 was displaying a negative number, and so I altered the upper bits of both ARR and CCR1 so that they were not negative.\nFor a long time I was not able to get the output traveling to GPIO A. I noticed while debugging that GPIO was not updating at all, even though I had confirmed before adding the timer that it was able to update. When I cross-checked my code with a demo I made to blink the LED, I quickly realized that I had accidentally set the GPIO B pins, not the GPIO A ones.\n\nFor an additional form of testing, specifically to confirm that I was seeing the anticipated frequencies, I hooked up an LED to my output in order to observe it blinking at low Hz. This helped me confirm that the calculations that I had made for the frequencies were correct (i.e. the delay of 1 second worked, and that the frequency of blinking was similarly accurate). Although there are no test benches for this program, I believe that in the end this worked effectively to debug my system as a whole.\n\n\n\nIn conclusion, this lab was a success in configuring an MCU board using C headers and functions. It additionally provided insight into the internal structures and memories found on an MCU, as well as provided a comprehensive understanding of all the relevant background required for working with MCU (Figure 3).\n\n\n\n\n\n\n\n\nFigure 3: Video of the MCU playing three different songs back to back.\n\n\n\n\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed both visually and with the aid of a test bench. The program is able to multiplex successfully without having the two LEDs bleed over, and all digits are equally lit for each segment, and proper calculations for the PNP transistor can be found above.\nI spent a total of 13.5 hours working on this lab, with roughly four of them spent on the lab writeup if including the planning of the modules and compiling all of the necessary diagrams."
  },
  {
    "objectID": "projects/e-155_website/posts/004_post_2024-09-16.html",
    "href": "projects/e-155_website/posts/004_post_2024-09-16.html",
    "title": "Where is the Time?",
    "section": "",
    "text": "So about Time\nI’ve been running low on sleep recently, and its not for lack of trying. I have a reason for it – mainly being that there just aren’t enough hours in the day to do all the schoolwork I need to do. Forget socialization, or not feeling like doing things – I’m doing so much all the time and it still doesn’t cut down the massive tidal wave hurtling towards me.\nI think that school is, generally, like a tsunami – at least that’s how I’ve explained it to people. You see the signs of it coming long before it does, and dealing with it is a terrible time. Specifically, it’s like facing off against a tsunami with a small little bucket, and you’re told by the captain “you got it buddy, I believe in you” – in my case, the captain is my past self who put me in this situation.\nSo how do we deal with the stress of it all? How do we work towards still succeeding while trying to do everything? Some may say that you should take a break – I think that’s perfectly valid. I actually love throwing myself into work, but I find that I tend to procrastinate on some work by doing others. I recommend, then, that everyone gets a way to track their time and how much time they’re spending for any one thing, whether its to distribute classwork better or whether its to actually see your friends every Saturday.\nHere are some solutions I’ve found; feel free to try them in your own time:\n\nSet up a set time that you’ll meet with your friend, and make sure you tell them its time limited\nWhen you do a silent study session with a friend, bring something to read; if you’re doing something that requires complex math problems, for example, you may need help or start making exclamations that will take away from work.\nUse Toggl Tap! I found this recently through MicroP’s, and its quite useful for budgeting my time and making sure I’m not procrastinating too much on any one thing."
  },
  {
    "objectID": "projects/e-155_website/posts/003_post_2024-09-08.html",
    "href": "projects/e-155_website/posts/003_post_2024-09-08.html",
    "title": "Worldbuilding while on the Move",
    "section": "",
    "text": "Worldbuilding on the Move\nThere are always endless excuses to not doing the things you want to do. At least, that’s what we tell ourselves – but sometimes it is the case that you are actually, fundamentally too busy to do what you want to do. This was a thought I had a while ago when I first started trying to worldbuild. What do you do when you literally don’t have the hours you want to work on something you’re passionate about? Or what do you do if you want to work on that thing during a period when you really, really can’t afford to do it?\nThe answer is, and its quite obvious, you do it when you’re on the move. That was the case for my world building adventures so far.\nI realized at a certain pointa few years ago that my art had stagnated - mainly due to me not being able to practice it as much in college. Engineering meant that unless I had whatever I was making due as an assignment for class, I would never actually be able to do the hour long projects that I had been able to devote to it during my senior year of high school (where I was stuck in quarantine with a large pad of paper, a box of colored pencils, and a senior portfolio to draw). I took inspiration from time to time in little doodles in my notebooks, but it was hard to be consistent, or to even have a theme to draw. THe main issue was that there simply wasn’t enough time to make the firm start I needed for making another art project; I needed to be able to come up with something coherent during the short fifteen minute windows I was running between classes or when I was taking notes, but that type of thing, at least in my head, takes time.\nThe change came when I began listening to Youtube art videos while walking too and from class, specifically about DeviantArt Drama. The drama itself wasn’t what inspired me, but rather who the drama featured. Swatches of artists on the internet have specific characters they draw, repeatedly, over and over again, in different scenarios, storylines, with different aesthetics or interactions. It is an endless supply of inspiration, in many cases, and often a way for them to express themselves or their own personalities or struggles through their artwork. Some might call it self-insert.\nNow why was this interesting to me? Why did this become some big epiphany? Because it gave my brain a direction to move towards. Previously, the main difficulty was a lack of a goal; I would worldbuild small amounts at a time, for a bunch of different stories, and the discombobulation of it all was what I think caused some of the stalls in my own artpieces. But many of these Deviantartists had been creating their characters and the world around them for years, decades even; it was Tolkein levels of thought, for some of them. It was the inspiration I needed.\nWhy?\nBecause it made me want to make something that would last from weeks to months to years; rather than just making a small idea and doodling it briefly in my notebook, I made a conscious, though small, effort to incorporate some world building into the doodles I drew on the go or in the margins. I focused more on fleshing out a world while listening to Debussy, or to creating plots for characters inside the world while listening to pop. That’s not to say everything I drew was consumed by worldbuilding, but the concerted effort I made to making something that was more than just something to pass the time, but something with a long term goal, was an important switch.\nSo where am I now?\nAbout four years into making a fantasy world, with fantasy creatures of my own design, fantasy races, characters, and ideas, and all of it cossting a few minutes of a day from the past few years. Worldbuilding is difficult; worldbuilding when you don’t have the hours you need to do it requires a decision on your part to focus on planning it in the few minutes you can steal. So to those artists or writers, to my fellow engineers who want to find the time but can’t make it work, come up with a goal, and make the small tweaks to edge you in the right direction. It doesn’t need to happen all at once; ideas can come slow, and sometimes you may even forget about the goal before you find it again. What’s important is that small bit you add every so often, so that you build yourself from a blank page to a masterpiece.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/e-155_website/blog.html",
    "href": "projects/e-155_website/blog.html",
    "title": "Blog",
    "section": "",
    "text": "Where is the Time?\n\n\n\n\n\n\ntrue\n\n\n\n\n\n\n\n\n\nSep 16, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nWorldbuilding while on the Move\n\n\n\n\n\n\nblogpost\n\n\n\nMaking time where there isn’t any to build your fantasy world\n\n\n\n\n\nSep 10, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nThe Swamp That Stands Between\n\n\n\n\n\n\nblogpost\n\n\n\nHow do art and engineering entangle with each other? And where do we draw the line?\n\n\n\n\n\nSep 5, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nE155: Learning Goals\n\n\n\n\n\n\nblogpost\n\n\n\nExplaining my initial learning goals for MicroPs\n\n\n\n\n\nAug 29, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nIs ‘Smart’ Really a Thing?\n\n\n\n\n\n\nblogpost\n\n\n\nExamining what it means to be smart, and strategies to respect alternative forms of it within the classroom\n\n\n\n\n\nAug 23, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Zoe Worrall’s Website",
    "section": "",
    "text": "Mae g’ovannen! My name is Zoe Worrall, and I am currently a senior Engineering Major at Harvey Mudd College.\nAlthough I have experience with a broad range of engineering topics including materials engineering, continuum mechanics, and manufacturing, my primary interests lie in signal processing, radio frequency, and optical systems.\n\n\nMudd’s general Engineering gives its students a strong background in a variety of subjects, but what has clicked with me the most in my schooling has been electrical engineering, especially through research.\nWhether it was working under PI Dr. Jason Gallicchio on software defined radio, or with research of in-vivo imaging systems in the Harvey Mudd Biophotonics Lab with Dr. Joshua Brake, I’ve learned to work with electromagnetic waves, their generation, and their processing.\n\n\n\n\n\n\nMy favorite courses at HMC have included E&M, Data Structures for C++, Digital Design and Computer Architecture, analog circuit design, and Systems Engineering."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Zoe Worrall’s Website",
    "section": "",
    "text": "Mae g’ovannen! My name is Zoe Worrall, and I am currently a senior Engineering Major at Harvey Mudd College.\nAlthough I have experience with a broad range of engineering topics including materials engineering, continuum mechanics, and manufacturing, my primary interests lie in signal processing, radio frequency, and optical systems.\n\n\nMudd’s general Engineering gives its students a strong background in a variety of subjects, but what has clicked with me the most in my schooling has been electrical engineering, especially through research.\nWhether it was working under PI Dr. Jason Gallicchio on software defined radio, or with research of in-vivo imaging systems in the Harvey Mudd Biophotonics Lab with Dr. Joshua Brake, I’ve learned to work with electromagnetic waves, their generation, and their processing.\n\n\n\n\n\n\nMy favorite courses at HMC have included E&M, Data Structures for C++, Digital Design and Computer Architecture, analog circuit design, and Systems Engineering."
  },
  {
    "objectID": "index.html#engineering",
    "href": "index.html#engineering",
    "title": "Zoe Worrall’s Website",
    "section": "",
    "text": "Mudd’s general Engineering gives its students a strong background in a variety of subjects, but what has clicked with me the most in my schooling has been electrical engineering, especially through research.\nWhether it was working under PI Dr. Jason Gallicchio on software defined radio, or with research of in-vivo imaging systems in the Harvey Mudd Biophotonics Lab with Dr. Joshua Brake, I’ve learned to work with electromagnetic waves, their generation, and their processing."
  },
  {
    "objectID": "index.html#art",
    "href": "index.html#art",
    "title": "Zoe Worrall’s Website",
    "section": "Art",
    "text": "Art\nIn addition to majoring in Engineering, I am also pursuing a concentration in Studio Art."
  }
]