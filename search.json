[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Link to the E155 Lab Website\nLink to the HMC Biophotonics Lab"
  },
  {
    "objectID": "contacts/index.html",
    "href": "contacts/index.html",
    "title": "Contact Me",
    "section": "",
    "text": "Social Media\nMy Github can be found here!\nFollow me on LinkedIn here\nIf you’d like to reach out to me via email, please direct it to zworrall@g.hmc.edu"
  },
  {
    "objectID": "projects/open_ivis.html",
    "href": "projects/open_ivis.html",
    "title": "openIVIS",
    "section": "",
    "text": "OpenIVIS is one of the research projects run by Mudd Professor Josh Brake at Harvey Mudd College, in conjunction with Colorado School of Mines and with the additional support of the National Science Foundation and the Zuckerburg Chan Trust. Having aided in its progression towards increased imaging modularity, I helped to publish a paper on the topic.\nThis research is still in progress, although I am no longer working in this lab."
  },
  {
    "objectID": "projects/open_ivis.html#what-is-the-goal",
    "href": "projects/open_ivis.html#what-is-the-goal",
    "title": "openIVIS",
    "section": "What is the Goal?",
    "text": "What is the Goal?\nMuch of the in-vivo imaging research available to small universities and labs is too expensive to use, or may be too risky to pursue, most machines costing hundreds of thousands of dollars and only being available or more accessible to larger organizations. The purpose of openIVIS is to construct a cheap in-vivo imaging system with easily accessible materials. Although openIVIS will not replace the current, expensive opportunities that exist, the goal of this project is to design an alternative stepping stone that will allow labratories to perform fundamental, proof of concept tests that they would otherwise find difficult to attain. All of this will be done in an open-source context, with an accessible GUI, CAD designs, computer systems, and types of imaging."
  },
  {
    "objectID": "projects/open_ivis.html#what-i-worked-on",
    "href": "projects/open_ivis.html#what-i-worked-on",
    "title": "openIVIS",
    "section": "What I Worked On",
    "text": "What I Worked On\nI worked with the openIVIS project from Fall 2023 to Fall 2024. Within that time, I created a new CAD design for the system’s shell, and worked on its imaging capabilities using laser speckle contrast imaging (LSCI).\n\nCAD Designs – Originally, the designs supplied by Colorado School of Mines had straight edges for the box, which did not provide for easy assembly. I worked within SolidWorks to build a new box model of the same dimensions that would use puzzle-piece layout to fit the pieces more snuggly, and to prevent light from entering the box.\nMachining – Using the HMC Machine Shop and Makerspace, I used a lathe, drill, laser cutter, and 3D printers to create the parts necessary for the assembly of the system.\nLaser Speckle Contrast Imaging – Based on the idea of low exposure time leading to increased blurriness of moving objects, my main focus was to create LSCI capabilities for the openIVIS system. This was done by programming of 20+ Python models of different fourier transforms and cross correlations of both simulated and actual data. By the end of summer, 2023, the system was performing rudimentary imaging of moving liquid encased in diffusing material that was otherwise invisible to the naked eye and the camara.\nFluorescent Imaging – I created a basic CAD design for implementing LED lights on top of the box that would be kept out of the box to prevent overheating. This design was 3D printed, and is currently one of the prototypes that have aided in the progression of the project."
  },
  {
    "objectID": "projects/open_ivis.html#want-to-learn-more",
    "href": "projects/open_ivis.html#want-to-learn-more",
    "title": "openIVIS",
    "section": "Want to Learn More?",
    "text": "Want to Learn More?\nSee the HMC Biophotonics Lab page, as well as the Colorado School of Mines research paper on which I am listed."
  },
  {
    "objectID": "projects/e-155_website/index.html",
    "href": "projects/e-155_website/index.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 2, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2 Initial Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3 Initial Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4 Initial Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5 Initial Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6 Initial Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7 Initial Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/e-155_website/posts/001_post_2024-08-28.html",
    "href": "projects/e-155_website/posts/001_post_2024-08-28.html",
    "title": "Is ‘Smart’ Really a Thing?",
    "section": "",
    "text": "Is “Smart” really a thing?\nI have a distinct memory from my time in elementary school of realizing that being smart is a very relative thing. The fact is, even elementary school students can understand that there’s a grey area when it comes to “intellectual prowess”: it is weird, in that way, that we try to decide and define who is smart and who isn’t. Sometimes, there are outliers of course - no one would ever really try to fight me if I said that Einstein was a genius. And yet, to me “smart” remains a very loaded word.\nThe main aspect of “smartness” I was thinking about in lower school was smartness in a multitude of categories: even if I may be book smart, for example, I have a very difficult time understanding people, and when it comes to social interactions I’m relatively hopeless. Smartness, from my perspective, ought to be considered more like (and forgive my references here) a Dungeons and Dragons character sheet rather than as some individual thing that measures solely how much someone has memorized flash card.\nAs a society, we’ve definitely been moving in the correct direction – standardized testing becoming optional for many schools is one of the first steps to recognizing the multitude of “smart” categories of students, and it will likely bring about a great degree of change for the better in multiple institutions. There obviously remains a long path to this recognition, however, and to that extent I’ve come up with a few paths I think might be able to be followed. The primary goal of these paths, or initiatives, would be to actively support the “smartness” of students not only in their intelligence, but in their five other categories as well (although I will mainly want to focus on Constitution, Wisdom, and Charisma).\nFor those unitiated in Dungeons and Dragons, I’ve provided a short, handy example of each of the six stats explained using tomatoes.\n\n\n\nImage of Tomato DnD Chart\n\n\nBased off of the DnD chart:\n\n(Constitution): How often has there been a friend that is just inherently in tune with their own body? This applies particularly to athletes and to dancers; the reason why I’d say that this falls under my terminology for “smart” is that this is a skill, based in understanding, that must be incessently worked at. Over time, you need enough experience with moving, working out, or playing games to understand yourself. The best way that we might begin incorporating a greater degree of respect for this “smartness” would likely be similar to the gym classes we have now; however, it relies on the coaches or teachers leading these activities encouraging learning about physical improvement, and applauding personal growth (not just natural skill)\n(Wisdom): This is street smarts, and although it can’t really be taught, it is always good to introduce new material to kids in class. I think running small sessions of activities that have unexpected or unrecognizable projects would aid in improving “wisdom smartness”.\n(Charisma): This one is quite important, and quite often overlooked. Charisma is a trait that is often built up from a very young age, and I know that I for one struggle with it. This smartness was my primary inspiration for thinking this in elementary school; knowing social interactions, when to speak, what is funny to say, when to say it, is difficult. As adults we’ve honed in on proper timing in converstaions, or proper topics to discuss, but as children most of the time this is only learned through peer-to-peer interaction. I’d say that in this case, the problem is less about teaching Charisma “smartness” and more about acknowledging it; potentially in school, especially lower levels of schooling, taking time to acknowledge feats of charisma, or running small programs where students share what they admire about how other people interact with them. The main point here is cognizance of the importance of social awareness.\n\nThere’s something to be said for teachers and mentors being involved outside of the classroom. I think at the end of the day, what I really wanted to get across with this post is the fact that students should acknowledge a variety of talents that they have, not just the ones that they demonstrate via memorization or in class."
  },
  {
    "objectID": "projects/e-155_website/posts/002_post_2024-09-05.html",
    "href": "projects/e-155_website/posts/002_post_2024-09-05.html",
    "title": "The Swamp That Stands Between",
    "section": "",
    "text": "The Swamp That Stands Between: Engineering and (Studio) Art\n\nTo Be Honest…\nI’m extremely surprised that more artists don’t turn up inside engineering. Looking at it pragmatically, engineering and art share quite a bit of cross-dialogue. Engineering, for example, has ill-defined points where a prototype becomes a “finished” article; in many of the same ways that a painter will look at a piece and not be able to say with absolute certainty “this is done”, an engineer will normally look at their circuit design and say “this is up to caliper”. Now, obviously, that isn’t to say there are some distinct divides; no one will be killed if a painting is missing a few lines or drawing in an odd way, but a bridge built with miscalculations or a power plant that’s not assembled up to a great degree of specific calibrations is bound to at least endanger many lives.\nSide note, I’d like to make it clear that much of the art I’ll be talking about in this blog post is the artform I’m most familiar with, being studio and digital art; normally very traditional, and falls well before many of the early 20th century movements that began questioning what exactly defines what art is; I refer to art here in a pretty classical, unnuanced sense, and plan on discussing Dadaism, Surrealism, Pop Art, etc. for a later day\nBut the fact remains that fundamentally, many of the same ideas we see in art appear in engineering. Diagrams, for example. Multiple drafts. Working at resembling real world structures and rendering them, sometimes twisting them or simplifying them, to either get a better understanding or a new interpretation. Both are inherently human, and require large degrees of creativity.\nI believe the fundamental differences between these two, and the reason that so few artists turn up as engineers, or so few engineers turn up as artists, is two fold: 1. Engineering and (studio) art’s high bar for entry 2. Engineering’s restrictions\nI don’t think many people would argue with me when I say that engineering has a high bar for entry; you need a lot of STEM background, an appreciation for systems often, and you need to not only enjoy being a problem solver but have been encouraged to do so; much of engineering, at least as a student, is as much about will power, perserverance, and a drive to succeed, as it is a series of mathematical expressions and designs.\nBut why would I say that art has a high bar for entry? This one, I think, is more a mental high bar than a physical one. To any artists reading this, I want you to fill in the following blank in my imaginary scenario:\nPerson A: [showing an artwork] This is a cat that I drew! I based it off of a photo of my cat, but I used oil pastel and changed the colors around to make it appear neon and change color under UV lighting. Person B: Oh my gosh, I could never draw something like that! I can’t even draw a ____.\nIf your answer to that is stick figure, you are one of the many artists who are seeing live the high-bar for entry that is artistry, and very similar to engineering, its a mental one. Where engineering is exhausting while being learned, and requires a large amount of devotion (sometimes at expense of social life, for example), artistry requries a will to improve; it is self driven, at the end of the day, similar to engineering, but unlike engineering it requires constant, subjective comparison. It requires the artist to ask themselves “where did I go wrong”, “how could I improve this”, or “why doesn’t my artwork look like theirs”. The internal battle within artwork creates a high bar for entry that many people are scared to face and overcome, particularly later in life.\nAll that is to say, that there are high bars to enter both engineering and art, both of them mental, and both of them requiring either early interest in the subject or the drive to pursue them later in life despite societal opposition (less-so is this true for engineering). Resultantly, the chance of meeting someone who has been able to do both art and engineering is lower than you would think.\nMoving onto the second bullet, being Engineering’s restrictions, I think that this is one of the things that holds artists back from joining engineering - the fact that engineering is an artform with a great degree of restrictions applied. From my perspective, engineering’s prototyping is a reflection of how it exists as a form of art. The difference from prototyping in art, however, and prototyping in engineering, is that as I said before if you make a prototype the final design, someone could get hurt in engineering. Engineering has built of a long history of rules and regulations (and logically so), but I think that to the average artist, who is so familiar with the ability to build what they want and do what they want with their artform, without rules, engineering likely feels quite restrictive. In many ways its like putting blinders on a horse; it focuses your energy, it keeps you focused on the road ahead; it keeps you and the people around you safe. But I think that at the same time, it’s just as good to let the horse roam a little bit, see the world, get spooked etc (I’m not a horse girl, if you couldn’t tell, and I’m sure many horse people got very mad at me for saying that just now). My main point is that engineering’s restrictions are unfortunately somewhat contradictory to what some artists want to do with their artforms, and resultantly engineering only applies to a few select artists who enjoy challenging themselves by placing restrictions on their own art forms. Engineering, then, is almost a practice in artistic expression that faces many requisites in order to ensure a sense of safety and coherence for its majors.\n\n\n\n\n\n\nInspiration\n\n\n\nCall it a happy accident. While I was breadboarding for Lab 2 of HMC E155, I noticed that the wires and the way everything was coming together looks very similar to abstract art. In general, a lot of engineering (especially in its early stages) looks more like an art project than anything else. It made me think a bit about how to define the divide between the two."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/lab1.html",
    "href": "projects/e-155_website/labs/lab1/lab1.html",
    "title": "Lab 1 Writeup",
    "section": "",
    "text": "Hours Spent: 21.3, Mapped with Toggl Track\n\n\nThe goal of this lab was initial setup and confirmation of FPGA control of on-board LEDs and attached GPIO pin. This was done through the control of three leds: D6, D7, and D8, as well as seven GPIO pins: 45, 3, 44, 9, 13, 12, and 20 through the readout of on-board 4-pin DIP switch. By the end of the laboratory, the three switches were controlled as defined as seen in Tables 1(a) and 1(b), and the seven segment LED matrix as defined in Table 2.\n\n\n\n\n\nTable 1: LED Logic for Table\n\n\n\n\n\n\n\n(a) LED 1 (D7)\n\n\n\n\n\ns[3]\ns[2]\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) LED 0 (D6)\n\n\n\n\n\ns[1]\ns[0]\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\n\n\n\n\n\nThe logic tables that were used for the led to switch mapping. Table 1 (a) refers to s[3] and s[2]; on the board, these are switches 1 and 2 (pins P32 and P31 respectively) to match where the highest order digits would be in a four digit number. By extensino, Table 1 (b) uses the two right-most switches (P35 and P32)\n\n\n\n\n\nTable 2: Seven Segment LED Matrix Logic\n\n\n\n\n\nSwitch Base 10 Value\nSeven Segment Display\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n2\n\n\n3\n3\n\n\n4\n4\n\n\n5\n5\n\n\n6\n6\n\n\n7\n7\n\n\n8\n8\n\n\n9\n9\n\n\n10\nA\n\n\n11\nB\n\n\n12\nC\n\n\n13\nD\n\n\n14\nE\n\n\n15\nF\n\n\n\n\n\n\nThe mapping from the decimal readout of the switches in hexadecimal.\n\n\n\n\n\nThe first stage of this lab involved the soldering of the MCU and the FPGA, as well as all additional SMD and THT pins. To do this, the E155 FA23 Development Board schematic was used. To begin, the SMD components were soldered. Careful consideration was given to make sure that the diodes were soldered in the right order and facing the correct direction. After these were soldered, THT components were then soldered, including the 4-pin DIP switch, the 8-pin DIP switch, and the female headers (Figure 1).\n\n\n\n\n\n\nFigure 1: SMD and THT pins soldered\n\n\n\nA board was connected via ribbon cable to the main Development board to allow for control of a breadboard via on-board GPIO pins (Figure 2). Once all pieces had been put together, the board was tested via a voltmeter via the screw terminal to ensure that the board could be properly powered (Figure 3)(Figure 4). The board through the screw terminal required +6 - +20 V; testing was done using 6V, and the board was confirmed to be running. The breadboard was tested using a multimeter to ensure that the 3.3V, 5.0V, and GND pins were properly generating the right voltage.\n\n\n\n\n\n\n\n\n\nFigure 2: Board assembled with ribbon cable\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Powering the board with the screw terminal at +6V\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: The Voltmeter while powering the screw terminal\n\n\n\n\n\nAll soldered pins and the required impedance values and relevant pin numbers can be found in the E155 FA23 Development Board pdf, linked in “Other Links” on this page. Once confirmation was had that the board was properly powering all pins using the screw terminal, the transition was then made to powering the board using both the MCU and the FPGA individually via a micro-USB cable.\nThe final schematic for this design can be seen below.\n\n\n\n\n\n\n\n\nI own a Mac computer, so I needed to go through a broad array of necessary preparation in order to begin generating the code for my computer. First, I installed SEGGER Embedded Studio 8.16a on my computer. Following the SEGGER Embedded Studio Tutorial, I confirmed that I was able to load designs onto my MCU board.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nUnfortunately, because I don’t have a Windows, it was necessary to run to the laboratory and use an actual Windows computer in order to install J-Link. The only thing you need to download is the third link on the download links, specifically the one called “SEGGER STLinkReflash utility”. You shouldn’t need to install anything additional, since the supplied boards already had J-Link installed.\n\n\nThe FPGA proved to be a little more difficult. This was a multiple step process, and required a bit of troubleshooting.\nFirst, I installed Parallels on my computer: I know that not everyone has $80 lined up to pay for a virtual Windows Machine. I recommend, if possible, use a student discount; when I got it, I managed to find a 50% student discount, which meant in the end I only spent $40. Parallels is one of the best ways to interact with your FPGA besides being in-lab, and I highly recommend it after using it for the past few days.\nOnce I had that downloaded, I installed Lattice Radiant for Windows 64 inside of the Parallels machine. In all, this process took me about two hours, so make sure to budget some time beforehand if you’re planning on doing this on a Mac. As noted by Professor Brake on his page explaining how to use Lattice Radiant, if you build a design within this program you won’t be able to run it like you would on a Windows, even if you are able to Synthesize the board. Instead, you need to go back to your home screen and find the correct pathing to the file on your Windows computer.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nNot many people seem to know this, but if you have a folder or file open in your File Manager, you can drag the file into an open terminal window in order to get the complete file path; I’m sure there are other ways to do this, but this is the fastest way for me to open most programs.\n\n\nAlthough you could run the same terminal code that Professor Brake advises, I personally have been using code given to my by Kavi Dey, which works better most of the time because I don’t need to figure out pathing to the .bin file on my computer. If you’re interested, follow this tutorial.\n\n\n\nThe lab is composed of three modules, one test bench, and one basic text file of test vectors. The modules are assumbled such that there is one for the combinational logic used for the LEDs called led_control.sv, and another that is used for the combinational logic of the seven segment array, called seven_segments.sv. The connection of these modules can be visualized in the block diagram below.\n\nIn this design approach, I noted that the led’s followed very basic boolean logic; LED 0 followed XOR logic with the lowest order two bits supplied by the DIP switch, and LED 1 followed AND logic with the two highest bits. LED 2 was very simple to program, as it followed similar logic to that used in the iCE_40.sv tutorial..\nThe design approach for the seven segment array required some more thoughtful setup. First, I constructed a table for each of the 16 possible arrangements of the DIP switch. Following the general logic that 0 should be mapped to 0x0, 1 to 0x1, etc. etc. until 15 was mapped to 0xF, I then created a table Table 3 that mapped out which parts of the segment would need to turn on to display the correct number. This gave me a list of seven bits arrange in 16 ways, which I then used inside a case statement when assigning according to the decimal value held by the DIP switch. Note that in the following table, segA was seg[0], or the least significant bit of the seven_segment array inside of the module; I initially had an issue debugging where I reversed the values on accident, and it created some odd shapes on the seven-segment matrix.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\nTable 3: Table of Switches Mapped to Segments\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ns[3]\ns[2]\ns[2]\ns[0]\n0x___\nsegA\nsegB\nsegC\nsegD\nsegE\nsegF\nsegG\n\n\n\n\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n0\n0\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n\n\n0\n0\n1\n0\n2\n0\n0\n1\n0\n0\n1\n0\n\n\n0\n0\n1\n1\n3\n0\n0\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n0\n4\n1\n0\n0\n1\n1\n0\n0\n\n\n0\n1\n0\n1\n5\n0\n1\n0\n0\n1\n0\n0\n\n\n0\n1\n1\n0\n6\n0\n1\n0\n0\n0\n0\n0\n\n\n0\n1\n1\n1\n7\n0\n0\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n8\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n0\n0\n1\n9\n0\n0\n0\n0\n1\n0\n0\n\n\n1\n0\n1\n0\n“A”\n0\n0\n0\n1\n0\n0\n0\n\n\n1\n0\n1\n1\n“b”\n1\n1\n0\n0\n0\n0\n0\n\n\n1\n1\n0\n0\n“C”\n0\n1\n1\n0\n0\n0\n1\n\n\n1\n1\n0\n1\n“d”\n1\n0\n0\n0\n0\n1\n0\n\n\n1\n1\n1\n0\n“E”\n0\n1\n1\n0\n0\n0\n0\n\n\n1\n1\n1\n1\n“F”\n0\n1\n1\n1\n0\n0\n0\n\n\n\n\n\n\n\n\n\nIn all, the combinational logic for this program was very straight forward. The next challenge came when mapping pins to the GPIO pins, and subsequent mapping to each individual segment on the matrix.\nWhen attaching the seven segment display, I took care to note the design specifications. My board was a common-anode, single-seven segment display, which means that it was a MAN6460 on the data sheet. All segments had a test operating current of 20mA, and a dynamic resistance of 26 ohms when running. Additionally, I found that the average test voltage drop across was 2.1 V; I did not want to design for the maximum voltage scenario (which was 2.8 V), as I’d rather avoid getting too close to any risk of burning the matrix out. Considering that the current draw ought to be 20 mA, and that the voltage drop across a given segment is 2.1 V, I know that the resistors have to remove 1.2V at 20mA of current; when calculating according to the equation V/I = R, this means that the final resistance ought to be about 60 ohms. For the sake of safety and with confirmation from Kavi, I used 220 ohm resistors to connect each of the cathodes of the board to their relative pins, and supplied both of the common anode pins with 3.3 V from the GPIO board. This means that each segment, when powered, has a current of 1.2/220 ohms or about 5 mA of current, which would map to 0.5 relative luminosity on their supplied data sheet (Figure 5)\n\n\n\n\n\n\n\n\n\nThis leads to the question of why I didn’t put a single resistor at the common anode, and chose instead to use seven different ones. The answer to this lies within the design constraints; we want each of the segments to light up equal amounts every time. If the resistor came before the diode’s power drop, the current through each diode would vary as the number of diodes lighting up varied. A very simple example can be seen with the setup seen in Figure 6.\n\n\n\n\n\n\n\n\n\nIf we compare A and B, we can see how the current through the diodes will differ between each situation. In case A, the one that I used, if one diode isn’t lit up, it has no impact on the current traveling through the other diode: in every case, the voltage drop will assuredly be either 0V or 2.1 V across a given diode, irrelevant to any other segment within this case. However in case B, the same can not be said. If two diodes are lit up, they will be using double the amount of current, and resultantly the voltage drop caused by the single resistor will double. This means that there will be a smaller voltage drop across the diodes, which means that the more segments that are lit up, the less bright the matrix will glow - if it glows at all. This is why all of the resistors were attached to each cathode in the final design, rather than one resistor being connected to the common anode.\nThe FPGA board maps to all pins starting with P; the MCU maps to all pins starting with PA. In order to accomplish the correct mapping, I drew a diagram (Figure 7) that mapped the pin number, the segment controlled, and then the GPIO pin I intended for each part of the device. I knew that seg[0] was assigned to segA, seg[6] to segG, etc., and resultantly I was able to make a basic table that I then implemented on my breadboard (Table 4)\n\n\n\n\n\n\n\n\n\n\n\n\nTable 4: Mapping of Pins to Segments\n\n\n\n\n\nsegment number\nGPIO Pin\n\n\n\n\n0\nP20\n\n\n1\nP12\n\n\n2\nP13\n\n\n3\nP45\n\n\n4\nP9\n\n\n5\nP44\n\n\n6\nP3\n\n\n\n\n\n\nWhen writing a testbench, I ran into several problems with using test vectors, to the point where I initially just wanted to program a for-loop to check my results. However, I realized after multiple hours of debugging and talking with Kavi that I had saved the file as the wrong type of text file, and resultantly my code couldn’t find the file (not for lack of me putting the textfile in every place)\n\n\n\n\n\n\nCan’t Find *.tv File\n\n\n\nBecause Windows doesn’t show the full extension, it wasn’t until I was looking through Windows via Terminal that I saw that the .tv file was, in fact, not a .tv file but a .tv.rtf file; this meant that when the program looked for the file that it wanted to run to test the vectors, it was unable to load it, even if the pathing to the text file was correct. Be very careful in Windows that the extension you see in the Finder window may not be the complete extension.\n\n\nThe final test bench that I made controlled the four bit input of the switches, and the cross checked the output of top with the values I knew ought to be in the led and seven segment array. The simulation takes a long time to run: I believe in order for it to complete all test vectors, I need to use the command run 1000000 (with six 0’s) in order to see the full thing and confirm that it is working. I removed $finish from the initial testbench file I was using as a baseline, as I wanted to be able to see the finished Waveform generator in Questa.\n\nThis final design meets all the requirements for this lab. The bits are arranged in increasing order, left to right, on the DIP switches, and correspond to the LED’s when everything is oriented the same way (i.e. the seven segment array is facing the correct direction, and the ribbon cable keeps everything close to the development board) without any twisting. Listing the requirements, and going over each one, we see that: 1. The development board is fully assembled and all its components are soldered. This was confirmed for the screw panel as well as the GPIO pins using a multimeter in lab. 2. There are three verilog modules written, one that serves at the top wrapper module, and two the serve to individually control the LEDs and control the 7-segment display 3. The FPGA has been programmed to run with this Verilog code. 4. The 7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF 5. All digits for the board are unique, with no repeats 6. The DIP switches are sequentially ordered, with P37 being the highest order and P32 the lowest. This is true for both the LED logic and the seven segment logic. 7. The LEDs display the specified logic operations properly. 8. I have provided calculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions, as 1.2V/220ohms = about 20 mA, which is within the device’s marked operating current. 9. I have generated a ModelSim (or specifically Questa) simulation with an automatic test bench that walks through each potential switch combination and ensures that the design is working properly. 10. Finally, I have performed the necessary calcualtions to ensure that all digits, specifically of the seven-segment array, are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "projects/e-155_website/labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "Lab 1 Writeup",
    "section": "",
    "text": "Hours Spent: 21.3, Mapped with Toggl Track\n\n\nThe goal of this lab was initial setup and confirmation of FPGA control of on-board LEDs and attached GPIO pin. This was done through the control of three leds: D6, D7, and D8, as well as seven GPIO pins: 45, 3, 44, 9, 13, 12, and 20 through the readout of on-board 4-pin DIP switch. By the end of the laboratory, the three switches were controlled as defined as seen in Tables 1(a) and 1(b), and the seven segment LED matrix as defined in Table 2.\n\n\n\n\n\nTable 1: LED Logic for Table\n\n\n\n\n\n\n\n(a) LED 1 (D7)\n\n\n\n\n\ns[3]\ns[2]\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) LED 0 (D6)\n\n\n\n\n\ns[1]\ns[0]\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\n\n\n\n\n\nThe logic tables that were used for the led to switch mapping. Table 1 (a) refers to s[3] and s[2]; on the board, these are switches 1 and 2 (pins P32 and P31 respectively) to match where the highest order digits would be in a four digit number. By extensino, Table 1 (b) uses the two right-most switches (P35 and P32)\n\n\n\n\n\nTable 2: Seven Segment LED Matrix Logic\n\n\n\n\n\nSwitch Base 10 Value\nSeven Segment Display\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n2\n\n\n3\n3\n\n\n4\n4\n\n\n5\n5\n\n\n6\n6\n\n\n7\n7\n\n\n8\n8\n\n\n9\n9\n\n\n10\nA\n\n\n11\nB\n\n\n12\nC\n\n\n13\nD\n\n\n14\nE\n\n\n15\nF\n\n\n\n\n\n\nThe mapping from the decimal readout of the switches in hexadecimal.\n\n\n\n\n\nThe first stage of this lab involved the soldering of the MCU and the FPGA, as well as all additional SMD and THT pins. To do this, the E155 FA23 Development Board schematic was used. To begin, the SMD components were soldered. Careful consideration was given to make sure that the diodes were soldered in the right order and facing the correct direction. After these were soldered, THT components were then soldered, including the 4-pin DIP switch, the 8-pin DIP switch, and the female headers (Figure 1).\n\n\n\n\n\n\nFigure 1: SMD and THT pins soldered\n\n\n\nA board was connected via ribbon cable to the main Development board to allow for control of a breadboard via on-board GPIO pins (Figure 2). Once all pieces had been put together, the board was tested via a voltmeter via the screw terminal to ensure that the board could be properly powered (Figure 3)(Figure 4). The board through the screw terminal required +6 - +20 V; testing was done using 6V, and the board was confirmed to be running. The breadboard was tested using a multimeter to ensure that the 3.3V, 5.0V, and GND pins were properly generating the right voltage.\n\n\n\n\n\n\n\n\n\nFigure 2: Board assembled with ribbon cable\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Powering the board with the screw terminal at +6V\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: The Voltmeter while powering the screw terminal\n\n\n\n\n\nAll soldered pins and the required impedance values and relevant pin numbers can be found in the E155 FA23 Development Board pdf, linked in “Other Links” on this page. Once confirmation was had that the board was properly powering all pins using the screw terminal, the transition was then made to powering the board using both the MCU and the FPGA individually via a micro-USB cable.\nThe final schematic for this design can be seen below.\n\n\n\n\n\n\n\n\nI own a Mac computer, so I needed to go through a broad array of necessary preparation in order to begin generating the code for my computer. First, I installed SEGGER Embedded Studio 8.16a on my computer. Following the SEGGER Embedded Studio Tutorial, I confirmed that I was able to load designs onto my MCU board.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nUnfortunately, because I don’t have a Windows, it was necessary to run to the laboratory and use an actual Windows computer in order to install J-Link. The only thing you need to download is the third link on the download links, specifically the one called “SEGGER STLinkReflash utility”. You shouldn’t need to install anything additional, since the supplied boards already had J-Link installed.\n\n\nThe FPGA proved to be a little more difficult. This was a multiple step process, and required a bit of troubleshooting.\nFirst, I installed Parallels on my computer: I know that not everyone has $80 lined up to pay for a virtual Windows Machine. I recommend, if possible, use a student discount; when I got it, I managed to find a 50% student discount, which meant in the end I only spent $40. Parallels is one of the best ways to interact with your FPGA besides being in-lab, and I highly recommend it after using it for the past few days.\nOnce I had that downloaded, I installed Lattice Radiant for Windows 64 inside of the Parallels machine. In all, this process took me about two hours, so make sure to budget some time beforehand if you’re planning on doing this on a Mac. As noted by Professor Brake on his page explaining how to use Lattice Radiant, if you build a design within this program you won’t be able to run it like you would on a Windows, even if you are able to Synthesize the board. Instead, you need to go back to your home screen and find the correct pathing to the file on your Windows computer.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nNot many people seem to know this, but if you have a folder or file open in your File Manager, you can drag the file into an open terminal window in order to get the complete file path; I’m sure there are other ways to do this, but this is the fastest way for me to open most programs.\n\n\nAlthough you could run the same terminal code that Professor Brake advises, I personally have been using code given to my by Kavi Dey, which works better most of the time because I don’t need to figure out pathing to the .bin file on my computer. If you’re interested, follow this tutorial.\n\n\n\nThe lab is composed of three modules, one test bench, and one basic text file of test vectors. The modules are assumbled such that there is one for the combinational logic used for the LEDs called led_control.sv, and another that is used for the combinational logic of the seven segment array, called seven_segments.sv. The connection of these modules can be visualized in the block diagram below.\n\nIn this design approach, I noted that the led’s followed very basic boolean logic; LED 0 followed XOR logic with the lowest order two bits supplied by the DIP switch, and LED 1 followed AND logic with the two highest bits. LED 2 was very simple to program, as it followed similar logic to that used in the iCE_40.sv tutorial..\nThe design approach for the seven segment array required some more thoughtful setup. First, I constructed a table for each of the 16 possible arrangements of the DIP switch. Following the general logic that 0 should be mapped to 0x0, 1 to 0x1, etc. etc. until 15 was mapped to 0xF, I then created a table Table 3 that mapped out which parts of the segment would need to turn on to display the correct number. This gave me a list of seven bits arrange in 16 ways, which I then used inside a case statement when assigning according to the decimal value held by the DIP switch. Note that in the following table, segA was seg[0], or the least significant bit of the seven_segment array inside of the module; I initially had an issue debugging where I reversed the values on accident, and it created some odd shapes on the seven-segment matrix.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\nTable 3: Table of Switches Mapped to Segments\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ns[3]\ns[2]\ns[2]\ns[0]\n0x___\nsegA\nsegB\nsegC\nsegD\nsegE\nsegF\nsegG\n\n\n\n\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n0\n0\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n\n\n0\n0\n1\n0\n2\n0\n0\n1\n0\n0\n1\n0\n\n\n0\n0\n1\n1\n3\n0\n0\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n0\n4\n1\n0\n0\n1\n1\n0\n0\n\n\n0\n1\n0\n1\n5\n0\n1\n0\n0\n1\n0\n0\n\n\n0\n1\n1\n0\n6\n0\n1\n0\n0\n0\n0\n0\n\n\n0\n1\n1\n1\n7\n0\n0\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n8\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n0\n0\n1\n9\n0\n0\n0\n0\n1\n0\n0\n\n\n1\n0\n1\n0\n“A”\n0\n0\n0\n1\n0\n0\n0\n\n\n1\n0\n1\n1\n“b”\n1\n1\n0\n0\n0\n0\n0\n\n\n1\n1\n0\n0\n“C”\n0\n1\n1\n0\n0\n0\n1\n\n\n1\n1\n0\n1\n“d”\n1\n0\n0\n0\n0\n1\n0\n\n\n1\n1\n1\n0\n“E”\n0\n1\n1\n0\n0\n0\n0\n\n\n1\n1\n1\n1\n“F”\n0\n1\n1\n1\n0\n0\n0\n\n\n\n\n\n\n\n\n\nIn all, the combinational logic for this program was very straight forward. The next challenge came when mapping pins to the GPIO pins, and subsequent mapping to each individual segment on the matrix.\nWhen attaching the seven segment display, I took care to note the design specifications. My board was a common-anode, single-seven segment display, which means that it was a MAN6460 on the data sheet. All segments had a test operating current of 20mA, and a dynamic resistance of 26 ohms when running. Additionally, I found that the average test voltage drop across was 2.1 V; I did not want to design for the maximum voltage scenario (which was 2.8 V), as I’d rather avoid getting too close to any risk of burning the matrix out. Considering that the current draw ought to be 20 mA, and that the voltage drop across a given segment is 2.1 V, I know that the resistors have to remove 1.2V at 20mA of current; when calculating according to the equation V/I = R, this means that the final resistance ought to be about 60 ohms. For the sake of safety and with confirmation from Kavi, I used 220 ohm resistors to connect each of the cathodes of the board to their relative pins, and supplied both of the common anode pins with 3.3 V from the GPIO board. This means that each segment, when powered, has a current of 1.2/220 ohms or about 5 mA of current, which would map to 0.5 relative luminosity on their supplied data sheet (Figure 5)\n\n\n\n\n\n\n\n\n\nThis leads to the question of why I didn’t put a single resistor at the common anode, and chose instead to use seven different ones. The answer to this lies within the design constraints; we want each of the segments to light up equal amounts every time. If the resistor came before the diode’s power drop, the current through each diode would vary as the number of diodes lighting up varied. A very simple example can be seen with the setup seen in Figure 6.\n\n\n\n\n\n\n\n\n\nIf we compare A and B, we can see how the current through the diodes will differ between each situation. In case A, the one that I used, if one diode isn’t lit up, it has no impact on the current traveling through the other diode: in every case, the voltage drop will assuredly be either 0V or 2.1 V across a given diode, irrelevant to any other segment within this case. However in case B, the same can not be said. If two diodes are lit up, they will be using double the amount of current, and resultantly the voltage drop caused by the single resistor will double. This means that there will be a smaller voltage drop across the diodes, which means that the more segments that are lit up, the less bright the matrix will glow - if it glows at all. This is why all of the resistors were attached to each cathode in the final design, rather than one resistor being connected to the common anode.\nThe FPGA board maps to all pins starting with P; the MCU maps to all pins starting with PA. In order to accomplish the correct mapping, I drew a diagram (Figure 7) that mapped the pin number, the segment controlled, and then the GPIO pin I intended for each part of the device. I knew that seg[0] was assigned to segA, seg[6] to segG, etc., and resultantly I was able to make a basic table that I then implemented on my breadboard (Table 4)\n\n\n\n\n\n\n\n\n\n\n\n\nTable 4: Mapping of Pins to Segments\n\n\n\n\n\nsegment number\nGPIO Pin\n\n\n\n\n0\nP20\n\n\n1\nP12\n\n\n2\nP13\n\n\n3\nP45\n\n\n4\nP9\n\n\n5\nP44\n\n\n6\nP3\n\n\n\n\n\n\nWhen writing a testbench, I ran into several problems with using test vectors, to the point where I initially just wanted to program a for-loop to check my results. However, I realized after multiple hours of debugging and talking with Kavi that I had saved the file as the wrong type of text file, and resultantly my code couldn’t find the file (not for lack of me putting the textfile in every place)\n\n\n\n\n\n\nCan’t Find *.tv File\n\n\n\nBecause Windows doesn’t show the full extension, it wasn’t until I was looking through Windows via Terminal that I saw that the .tv file was, in fact, not a .tv file but a .tv.rtf file; this meant that when the program looked for the file that it wanted to run to test the vectors, it was unable to load it, even if the pathing to the text file was correct. Be very careful in Windows that the extension you see in the Finder window may not be the complete extension.\n\n\nThe final test bench that I made controlled the four bit input of the switches, and the cross checked the output of top with the values I knew ought to be in the led and seven segment array. The simulation takes a long time to run: I believe in order for it to complete all test vectors, I need to use the command run 1000000 (with six 0’s) in order to see the full thing and confirm that it is working. I removed $finish from the initial testbench file I was using as a baseline, as I wanted to be able to see the finished Waveform generator in Questa.\n\nThis final design meets all the requirements for this lab. The bits are arranged in increasing order, left to right, on the DIP switches, and correspond to the LED’s when everything is oriented the same way (i.e. the seven segment array is facing the correct direction, and the ribbon cable keeps everything close to the development board) without any twisting. Listing the requirements, and going over each one, we see that: 1. The development board is fully assembled and all its components are soldered. This was confirmed for the screw panel as well as the GPIO pins using a multimeter in lab. 2. There are three verilog modules written, one that serves at the top wrapper module, and two the serve to individually control the LEDs and control the 7-segment display 3. The FPGA has been programmed to run with this Verilog code. 4. The 7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF 5. All digits for the board are unique, with no repeats 6. The DIP switches are sequentially ordered, with P37 being the highest order and P32 the lowest. This is true for both the LED logic and the seven segment logic. 7. The LEDs display the specified logic operations properly. 8. I have provided calculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions, as 1.2V/220ohms = about 20 mA, which is within the device’s marked operating current. 9. I have generated a ModelSim (or specifically Questa) simulation with an automatic test bench that walks through each potential switch combination and ensures that the design is working properly. 10. Finally, I have performed the necessary calcualtions to ensure that all digits, specifically of the seven-segment array, are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/lab1.html#suggestions-for-future-improvements",
    "href": "projects/e-155_website/labs/lab1/lab1.html#suggestions-for-future-improvements",
    "title": "Lab 1 Writeup",
    "section": "Suggestions for Future Improvements",
    "text": "Suggestions for Future Improvements\nOverall, this lab was a very good introduction for MicroP’s, and really gets the ball rolling so that the student can get back into the frame of mind they were accustomed to in E85. Overall, I think very few edits should be made to this laboratory. However, if I had to suggest a change, I believe the main one would be that the lab writeup should include, at some point, a reference to the MCU board, in case the lab user either skipped the section or forgot about it. In particular, since the MCU will be used in the future, it seems important that the user demonstrate that they know how to use it before it is used to a much greater degree further into the semester.\nAdditionally, a reference to an example of a block diagram within the References page would have aided in clearing up exactly what was expected to be seen in the first lab writeup, as I had many questions that needed to be answered in person, and couldn’t be found online."
  },
  {
    "objectID": "projects/mcf_lci.html",
    "href": "projects/mcf_lci.html",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "",
    "text": "Brain imaging capabilities such as fMRI scans, although broad in capability, normally face issues when it comes to creating images with spatial and temporal resolution. Light increases the capabilities of both of these, but is limited by conventional lenses, which though non-intrusive causes a great degree of scatter, and GRIN lenses, which are wide, stiff intrusions in the context of optical imaging and risk damaging the subject while preventing in-situ imaging. Multicore fibers lie in the middle of these two. Capable of in-situ imaging and minimally invasive, this system would allow for the high temporal and spatial resolution of light and the benefits of non optical system."
  },
  {
    "objectID": "projects/mcf_lci.html#what-is-the-goal",
    "href": "projects/mcf_lci.html#what-is-the-goal",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "",
    "text": "Brain imaging capabilities such as fMRI scans, although broad in capability, normally face issues when it comes to creating images with spatial and temporal resolution. Light increases the capabilities of both of these, but is limited by conventional lenses, which though non-intrusive causes a great degree of scatter, and GRIN lenses, which are wide, stiff intrusions in the context of optical imaging and risk damaging the subject while preventing in-situ imaging. Multicore fibers lie in the middle of these two. Capable of in-situ imaging and minimally invasive, this system would allow for the high temporal and spatial resolution of light and the benefits of non optical system."
  },
  {
    "objectID": "projects/mcf_lci.html#what-i-worked-on",
    "href": "projects/mcf_lci.html#what-i-worked-on",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "What I Worked On",
    "text": "What I Worked On\n\nSimulations – …\nSLM Calibrations – …\nInterferometry – …\nSoftware Connections – U1800 Camera, pco.panda Camera, NiDAQmx…"
  },
  {
    "objectID": "projects/mcf_lci.html#want-to-learn-more",
    "href": "projects/mcf_lci.html#want-to-learn-more",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "Want to Learn More?",
    "text": "Want to Learn More?\nSee the HMC Biophotonics Lab page.\nMulticore Fiber Bundle LCI is one of the research projects run by Mudd Professor Josh Brake at Harvey Mudd College."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html",
    "href": "projects/e-155_website/labs/lab1/running_labs.html",
    "title": "How to Run FPGA Code",
    "section": "",
    "text": "The first thing that you need to do is write your code. Easy enough; let’s pretend that you’ve done that already.\nI follow Professor Brake’s tutorial for most of this, and it was quite comprehensive. However, if you’d like even more photos, and specifically information on how I personally load onto my FPGA board, read on. The next thing that you need to do is a bit more difficult if you aren’t connected to your board properly, and that’s to Synthesize your code, like the pretty image below.\n\n\n\n\n\nStart by installing Lattice Radiant. It’s straightforward, especially if you are following Professor Brake’s tutorial. I will talk specifically about installing the FTDI driver afterwards, as that was what was more difficult on my end.\nUnfortunately, unless you’ve done it before you’ll probably need to install the FTDI Drivers that Professor Brake mentions. I’ll give you a tip, though, that you shouldn’t just go blindly clicking and installing every zip file that you see – for example, clicking the linke for “setup executable” will give a file that is meant for Windows computers (x86), not for your arm64 chip. Here are the proper steps:\n\nRead through the Installation Guide for your situation. If you are like me, and are running a Windows Driver on your Mac, then use this Installation Guide. If you are even more like me, and you’re on a Mac with an M1 chip, you should carefully read and then ignore all of Sections 3.1 and 3.2 in this guide, and focuse solely on Section 3.3. As the document says, “Note: This is the only method to install the ARM64 or universal versions of the driver.”.\nThe rest of this process is quite straight forward, so long as you follow Section 3.3. The process will mainly be that you will first need to link your device into Parallels so that you can see it from inside the Parallels Device.\n\n\n\n\n\n\n\nYou will then be told that you should be able to open Device Manager within Windows (just use the search bar at the bottom to find it) and immediately see the relevant Ports. If you are like me, you don’t see this and panic. Don’t worry: it’s just hidden from you because it’s currently broken. To rectify this, you need to click View &gt; show hidden devices inside your Device Manager. Miraculously, you will suddenly see the same Ports file that they are talking about in the installation guide.\n\n\n\n\n\n\n\nContinue following their recommended steps. Note that when you install the FTDI driver, you should install it on the Parallels Window Machine and not on your home Mac, as this will cause errors when the program tries finding it (at least, it did for me)."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#first-steps",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#first-steps",
    "title": "How to Run FPGA Code",
    "section": "",
    "text": "The first thing that you need to do is write your code. Easy enough; let’s pretend that you’ve done that already.\nI follow Professor Brake’s tutorial for most of this, and it was quite comprehensive. However, if you’d like even more photos, and specifically information on how I personally load onto my FPGA board, read on. The next thing that you need to do is a bit more difficult if you aren’t connected to your board properly, and that’s to Synthesize your code, like the pretty image below.\n\n\n\n\n\nStart by installing Lattice Radiant. It’s straightforward, especially if you are following Professor Brake’s tutorial. I will talk specifically about installing the FTDI driver afterwards, as that was what was more difficult on my end.\nUnfortunately, unless you’ve done it before you’ll probably need to install the FTDI Drivers that Professor Brake mentions. I’ll give you a tip, though, that you shouldn’t just go blindly clicking and installing every zip file that you see – for example, clicking the linke for “setup executable” will give a file that is meant for Windows computers (x86), not for your arm64 chip. Here are the proper steps:\n\nRead through the Installation Guide for your situation. If you are like me, and are running a Windows Driver on your Mac, then use this Installation Guide. If you are even more like me, and you’re on a Mac with an M1 chip, you should carefully read and then ignore all of Sections 3.1 and 3.2 in this guide, and focuse solely on Section 3.3. As the document says, “Note: This is the only method to install the ARM64 or universal versions of the driver.”.\nThe rest of this process is quite straight forward, so long as you follow Section 3.3. The process will mainly be that you will first need to link your device into Parallels so that you can see it from inside the Parallels Device.\n\n\n\n\n\n\n\nYou will then be told that you should be able to open Device Manager within Windows (just use the search bar at the bottom to find it) and immediately see the relevant Ports. If you are like me, you don’t see this and panic. Don’t worry: it’s just hidden from you because it’s currently broken. To rectify this, you need to click View &gt; show hidden devices inside your Device Manager. Miraculously, you will suddenly see the same Ports file that they are talking about in the installation guide.\n\n\n\n\n\n\n\nContinue following their recommended steps. Note that when you install the FTDI driver, you should install it on the Parallels Window Machine and not on your home Mac, as this will cause errors when the program tries finding it (at least, it did for me)."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#kavis-code",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#kavis-code",
    "title": "How to Run FPGA Code",
    "section": "Kavi’s Code",
    "text": "Kavi’s Code\nThis has been posted with Kavi’s permission\nKavi was tired of needing to hunt down the .bin file every time. Kavi is also really good at writing shell code. Resultantly, Kavi wrote the following code which will find the binary file that you need, so long as you are in the proper folder for it.\nIn order to install this shortcut, first you need to open your .zshrc file. For those of you who are extremely unfamiliar with terminal code, follow the following steps.\n\nIn your terminal, type vim ~/.zshrc. This does two things; vim is a way of opening and editing a current configuration code (or any code file) from within terminal. ~/.zshrc is one of what are called “shell” code files. The ~/ indicates that the path to this file is from your current user’s home file. The “.zshrc” file itself is hidden; if you run ls in your home directory, you’ll note that it doesn’t appear; you can only see it if you list files including hidden ones (ls -a). It is what is run when your computer starts up, and helps point your computer on where to go. It is also where you can write shortcuts for running commands within terminal, which is what we are about to do. Below is an image of what my ~/.zshrc program looks like.\n\n\n\n\n\n\n\nYou’ll note that when you have this file open using vim, you can’t type anything. In order to actually insert things into this file, you need to type the letter i. This will put you into “Insert” mode, indicated by the -- INSERT -- on the bottom of your screen. You can now type in this folder! But be careful; deleting things or entering random things will likely throw errors in your terminal, which are often gross and icky to clean up.\n\n\n\n\n\n\n\nNow that you’re in Insert mode, navigate to the bottom of this file (just press/hold down on the down arrows until you get there). Paste the following code.\n\n#!/bin/bash\nalias program_fpga=\"find . -name '*.bin' -print | xargs openFPGALoader -b ice40_generic -c ft232  -f\"\nWhat this effectively does is locates the bin file (assuming that you’ve only made one – please don’t add more than one bin file or random, weird behavior will happen and the code likely won’t run), and then enters this into the openFPGALoader program. If you’re unfamiliar with terminal, you’ll notice that there’s a line (called a pipe) | in the middle of the code; this indicates that after you’ve found the *.bin file, you push the output into the next code; in this case, its being used as an argument (xargs) in openFPGA viewer.\n\nNow that you’ve inserted it, a problem that I first had when I was learning how to use vim was how to get out of it (vim is one of many ways to edit this programs, by the way: some people prefer using vi, or something else they’ve downloaded off of the interwebs. It’s really up to you how you edit files in terminal – I’m just most familiar with vim). To leave, and especially to save what you just did, use the Esc key. If you’ve decide that you don’t want to save your work, write :q! in the terminal and press Enter. This effectively quits the program without saving. If you DO want to save, instead you need to write :wq, which will save the edits that you’ve made to your ~/.zshrc file. You’ve now saved Kavi’s code, and if you want to run it, all you need to write in your terminal is program_fpga.\n\n\n\n\n\n\n\nDouble Check\n\n\n\nP.S. If you’d like to check that your changes were made inside of the program, you can experiment with that new pipe character you’ve just learned about to make sure that the file is in there. In your terminal, type cat ~/.zshrc | grep program_fpga. What this effectively does is:\n\nUses cat to return all the text inside your ~/.zshrc file\nPipelines this text and selectively sorts it, using grep, for the keyword “program_fpga”, which is the function we’ve just added.\n\nIf all went well, you should see the line alias program_fpga=\"find . -name '*.bin' -print | xargs openFPGALoader -b ice40_generic -c ft232  -f\" returned! If nothing is returned, that means it wasn’t saved properly, and you’ll need to go back and make sure that it’s there and that there are no typos."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#running-fpga-code",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#running-fpga-code",
    "title": "How to Run FPGA Code",
    "section": "Running FPGA Code",
    "text": "Running FPGA Code\nThe first step you need to take to running code off your FPGA board is locating where the folder containing this code is on your computer. Here is an example of how I find mine.\n\nI go to my Finder window, and go into Locations. This is where I can see Parallels’s virtual Windows environment.\n\n\n\n\n\n\n\nI then navigate to wherever I’ve saved my file. Note that it is also possible to save your file on your Mac, and upload it to your FPGA from there. For me, I had difficulties connecting to my FPGA whenever I was on my Mac besides when I was using the terminal, and so I chose to avoid some frustration by storing all my files solely on Parallels.\n\n\n\n\n\n\n\nBy dragging the folder for your lab into terminal, you can enter this path within your terminal in order to run your FGPA, Lattice Radiant code.\n\n\n\n\n\n\n\nNow that you are inside the program, you can run Kavi’s Code. Type program_fpga, and if you are connected to your board correctly (make sure that you have the microUSB plugged into the FPGA and that the lights are turned on), the code that you have Synthesized will automatically upload onto the FPGA, and you’ll see it running in real time. To double check and confirm, your terminal should resemble the image below (potentially without the colors)"
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#done",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#done",
    "title": "How to Run FPGA Code",
    "section": "Done!",
    "text": "Done!\nAnd that’s it! Congratulations, you’re now able to run code from your FPGA board!"
  },
  {
    "objectID": "projects/e-155_website/posts/initial_learning_goals.html",
    "href": "projects/e-155_website/posts/initial_learning_goals.html",
    "title": "E155: Learning Goals",
    "section": "",
    "text": "My final goals for MicroP’s mainly revolve around getting more familiar with FPGA boards, as well as practicing my time management skills. This semester is set up to be packed with a lot of material, but it is all material that focuses mainly on projects rather than problem sets: resultantly, it’s an excellent way to hone in on my organization and my calendar skills.\nAdditionally, it has been about a year since I took E85, which means that many of my Verilog skills that I built up are rusty; this ought to be an excellent way to get back into programming in SystemVerilog. Additionally, FPGA’s are heavily used within the radio transmitting and signal processing world, and so I think it’s very important that I learn how to interact with them, even at their most basic level.\nFinally, I’m excited that this course incorporates Quarto and Github! It was not something that I was anticipating, but I believe that one of my final goals with this course is to build some additional professional skills that will allow me to present my work better, whether in academia or in industry."
  },
  {
    "objectID": "projects/e-155_website/posts/initial_learning_goals.html#my-thoughts",
    "href": "projects/e-155_website/posts/initial_learning_goals.html#my-thoughts",
    "title": "E155: Learning Goals",
    "section": "",
    "text": "My final goals for MicroP’s mainly revolve around getting more familiar with FPGA boards, as well as practicing my time management skills. This semester is set up to be packed with a lot of material, but it is all material that focuses mainly on projects rather than problem sets: resultantly, it’s an excellent way to hone in on my organization and my calendar skills.\nAdditionally, it has been about a year since I took E85, which means that many of my Verilog skills that I built up are rusty; this ought to be an excellent way to get back into programming in SystemVerilog. Additionally, FPGA’s are heavily used within the radio transmitting and signal processing world, and so I think it’s very important that I learn how to interact with them, even at their most basic level.\nFinally, I’m excited that this course incorporates Quarto and Github! It was not something that I was anticipating, but I believe that one of my final goals with this course is to build some additional professional skills that will allow me to present my work better, whether in academia or in industry."
  },
  {
    "objectID": "projects/e-155_website/blog.html",
    "href": "projects/e-155_website/blog.html",
    "title": "Blog",
    "section": "",
    "text": "The Swamp That Stands Between\n\n\n\n\n\n\nblogpost\n\n\n\nHow do art and engineering entangle with each other? And where do we draw the line?\n\n\n\n\n\nSep 5, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nE155: Learning Goals\n\n\n\n\n\n\nblogpost\n\n\n\nExplaining my initial learning goals for MicroPs\n\n\n\n\n\nAug 29, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nIs ‘Smart’ Really a Thing?\n\n\n\n\n\n\nblogpost\n\n\n\nExamining what it means to be smart, and strategies to respect alternative forms of it within the classroom\n\n\n\n\n\nAug 23, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Zoe Worrall’s Website",
    "section": "",
    "text": "** note for Prof. Brake for E155 (this will be removed later): the links to Github and LinkedIn are in the footbar at the bottom of this page\n\n\nMae g’ovannen! My name is Zoe Worrall, and I am currently a senior Engineering Major at Harvey Mudd College.\nAlthough I have experience with a broad range of engineering topics including materials engineering, continuum mechanics, and manufacturing, my primary interests lie in signal processing, radio frequency, and optical systems.\n\n\nMudd’s general Engineering gives its students a strong background in a variety of subjects, but what has clicked with me the most in my schooling has been electrical engineering, especially through research.\nWhether it was working under PI Dr. Jason Gallicchio on software defined radio, or with research of in-vivo imaging systems in the Harvey Mudd Biophotonics Lab with Dr. Joshua Brake, I’ve learned to work with electromagnetic waves, their generation, and their processing.\n\n\n\n\n\n\nMy favorite courses at HMC have included E&M, Data Structures for C++, Digital Design and Computer Architecture, analog circuit design, and Systems Engineering."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Zoe Worrall’s Website",
    "section": "",
    "text": "** note for Prof. Brake for E155 (this will be removed later): the links to Github and LinkedIn are in the footbar at the bottom of this page\n\n\nMae g’ovannen! My name is Zoe Worrall, and I am currently a senior Engineering Major at Harvey Mudd College.\nAlthough I have experience with a broad range of engineering topics including materials engineering, continuum mechanics, and manufacturing, my primary interests lie in signal processing, radio frequency, and optical systems.\n\n\nMudd’s general Engineering gives its students a strong background in a variety of subjects, but what has clicked with me the most in my schooling has been electrical engineering, especially through research.\nWhether it was working under PI Dr. Jason Gallicchio on software defined radio, or with research of in-vivo imaging systems in the Harvey Mudd Biophotonics Lab with Dr. Joshua Brake, I’ve learned to work with electromagnetic waves, their generation, and their processing.\n\n\n\n\n\n\nMy favorite courses at HMC have included E&M, Data Structures for C++, Digital Design and Computer Architecture, analog circuit design, and Systems Engineering."
  },
  {
    "objectID": "index.html#engineering",
    "href": "index.html#engineering",
    "title": "Zoe Worrall’s Website",
    "section": "",
    "text": "Mudd’s general Engineering gives its students a strong background in a variety of subjects, but what has clicked with me the most in my schooling has been electrical engineering, especially through research.\nWhether it was working under PI Dr. Jason Gallicchio on software defined radio, or with research of in-vivo imaging systems in the Harvey Mudd Biophotonics Lab with Dr. Joshua Brake, I’ve learned to work with electromagnetic waves, their generation, and their processing."
  },
  {
    "objectID": "index.html#art",
    "href": "index.html#art",
    "title": "Zoe Worrall’s Website",
    "section": "Art",
    "text": "Art\nIn addition to majoring in Engineering, I am also pursuing a concentration in Studio Art."
  }
]