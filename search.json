[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Link to the E155 Lab Website\nLink to the HMC Biophotonics Lab"
  },
  {
    "objectID": "contacts/index.html",
    "href": "contacts/index.html",
    "title": "Contact Me",
    "section": "",
    "text": "Social Media\nMy Github can be found here!\nFollow me on LinkedIn here\nIf you’d like to reach out to me via email, please direct it to zworrall@g.hmc.edu"
  },
  {
    "objectID": "projects/open_ivis.html",
    "href": "projects/open_ivis.html",
    "title": "openIVIS",
    "section": "",
    "text": "OpenIVIS is one of the research projects run by Mudd Professor Josh Brake at Harvey Mudd College, in conjunction with Colorado School of Mines and with the additional support of the National Science Foundation and the Zuckerburg Chan Trust. Having aided in its progression towards increased imaging modularity, I helped to publish a paper on the topic.\nThis research is still in progress, although I am no longer working in this lab."
  },
  {
    "objectID": "projects/open_ivis.html#what-is-the-goal",
    "href": "projects/open_ivis.html#what-is-the-goal",
    "title": "openIVIS",
    "section": "What is the Goal?",
    "text": "What is the Goal?\nMuch of the in-vivo imaging research available to small universities and labs is too expensive to use, or may be too risky to pursue, most machines costing hundreds of thousands of dollars and only being available or more accessible to larger organizations. The purpose of openIVIS is to construct a cheap in-vivo imaging system with easily accessible materials. Although openIVIS will not replace the current, expensive opportunities that exist, the goal of this project is to design an alternative stepping stone that will allow labratories to perform fundamental, proof of concept tests that they would otherwise find difficult to attain. All of this will be done in an open-source context, with an accessible GUI, CAD designs, computer systems, and types of imaging."
  },
  {
    "objectID": "projects/open_ivis.html#what-i-worked-on",
    "href": "projects/open_ivis.html#what-i-worked-on",
    "title": "openIVIS",
    "section": "What I Worked On",
    "text": "What I Worked On\nI worked with the openIVIS project from Fall 2023 to Fall 2024. Within that time, I created a new CAD design for the system’s shell, and worked on its imaging capabilities using laser speckle contrast imaging (LSCI).\n\nCAD Designs – Originally, the designs supplied by Colorado School of Mines had straight edges for the box, which did not provide for easy assembly. I worked within SolidWorks to build a new box model of the same dimensions that would use puzzle-piece layout to fit the pieces more snuggly, and to prevent light from entering the box.\nMachining – Using the HMC Machine Shop and Makerspace, I used a lathe, drill, laser cutter, and 3D printers to create the parts necessary for the assembly of the system.\nLaser Speckle Contrast Imaging – Based on the idea of low exposure time leading to increased blurriness of moving objects, my main focus was to create LSCI capabilities for the openIVIS system. This was done by programming of 20+ Python models of different fourier transforms and cross correlations of both simulated and actual data. By the end of summer, 2023, the system was performing rudimentary imaging of moving liquid encased in diffusing material that was otherwise invisible to the naked eye and the camara.\nFluorescent Imaging – I created a basic CAD design for implementing LED lights on top of the box that would be kept out of the box to prevent overheating. This design was 3D printed, and is currently one of the prototypes that have aided in the progression of the project."
  },
  {
    "objectID": "projects/open_ivis.html#want-to-learn-more",
    "href": "projects/open_ivis.html#want-to-learn-more",
    "title": "openIVIS",
    "section": "Want to Learn More?",
    "text": "Want to Learn More?\nSee the HMC Biophotonics Lab page, as well as the Colorado School of Mines research paper on which I am listed."
  },
  {
    "objectID": "projects/e-155_website/index.html",
    "href": "projects/e-155_website/index.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 2, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nSep 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nOct 21, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7 Writeup\n\n\n\n\n\n\nZoe Worrall - zworrall@g.hmc.edu\n\n\nNov 1, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/e-155_website/posts/009_post_2024-10-29.html",
    "href": "projects/e-155_website/posts/009_post_2024-10-29.html",
    "title": "A Discussion on ‘Nerd Culture’",
    "section": "",
    "text": "Being Weird is quirky now\nDon’t believe me? Many of the things that were originally considered geeky and bully worthy have become something cool - Dungeons and Dragons, Star Wars, Star Trek, almost anything that has a cult following has become the mainstream. In fact, its no longer cool to bully the kids that have deep interests in topics; society has advanced, in that regard, to the point where if you have a deep interest in something, people won’t make fun of you for it and instead think that you yourself are interesting and fun to talk to. This, obviously, comes with an acception; if you have some difficulty talking.\nI think everyone has that awkward phase growing up where you’re never quite sure what to say or how to say anything. I remember a good part of my elementary school years were spent continually wondering “why am I always entering the conversation at the wrong time?” and “I never say anything that goes with what the topic of this conversation was supposed to be - everyone always looks at me like I said the wrong thing”. That’s just a part of growing up; we’ve all socialized ourselves, in a certain way, to discuss things and impart our own personal knowledge in certain ways. This obviously varies from person to person - some people are more listeners, some people are more observers. But at the end of the day, I think that what’s interesting is how we all reach the “societal norm” at a certain stage. Similar to my first post about tomatoes and the different forms of intelligence, I think that the ability to be in tune with what is “right” to say at the right time is as much practice as it is innate intellect - certain people just find it easier than others.\nThis brings me to what exactly it means to be a nerd, or to be socially awkward, in modern day. I think the main differentiating factor is that many of the people who are “nerdy” now are people who struggled to overcome that initial charisma gap - that isn’t to say that they aren’t charismatic, or that they aren’t extraverted, but rather that they understand implicitly what it means to be the ‘weirdo’, to have said the wrong things in conversations. I think that many people online now, especially in communities like “Epic the Musical”, “Five Nights at Freddy’s”, and other ‘cult followings’ tend to be united under the idea that at one point or another, they had something about them that wasn’t quite right, and so now they chose to find other people who are similar.\nSometimes this results in a “we’re better than them” mindset - in fact, so many books made being the “weirdo” cool, and being “popular” bad, that often times groups of “social outcasts” will be extremely pretentious (I’m looking back at my highschool friendgroup - myself included - for this specific point). Often times, there is little “oppression” when it comes to being a bit socially awkward, since so much of society now is aime at making being awkward acceptable. So I think that the definitions and guidepoles for nerd have been changed completely, and the question is less so “are you at the bottom of the social hierarchy” and moreso “where are you in all of the many pools that society has made” - which is a good thing."
  },
  {
    "objectID": "projects/e-155_website/posts/005_post_2024-10-01.html",
    "href": "projects/e-155_website/posts/005_post_2024-10-01.html",
    "title": "The Swamp that Stands Between",
    "section": "",
    "text": "About the wild ride of the physics world\nQuotes from Actual Physics Students\n“Much like hoola hooping or acrobatics, stat mech is something I can’t do!” - A Physics Student\n“I can share my highschool quote - kinetic energy and potential energy are conserved, which explains why my life is spinning out of control and I have no potential left” - Another Physics Student\nA common trend I’ve noticed recently is how each type of student for each of the mathematically-rich majors at Mudd (think Engineering, Physics, Math, CS-Math) sort themselves out almost by personality. The physics majors are those who are able to deal with extremely long, complicated math problems, normally requiring a large amount of time in groups. Engineers, rather than complicated problem sets, tend to have a large amount of problems, that take up time but are possible to complete with proper time management skills. Math is purely theoretical, and requires a great degree of thought - I find that this is where people who like working alone but like the complexity of some of the physics problems go.\nSo why the title of this blog post? Why do I say physics is a circus? What does that make the other majors?\nI think that, in part, we can model each of the majors as if they were some extension of the arts; for engineering, I would say they tend to be the classic artistic styles like Renaissance or Baroque period, where very strict rules for art were adhered to and pursued. There is very little chance for abandoning ship and trying to make new pieces, and much of engineering research is about using new concepts from other fields in the very well defined, rule-conscious nature of engineering in order to make the world better or safer.\nMath, on the other hand, is much like contemporary dance if I had to say; there is purpose to each of the movements they make, and many of the complexities of the dance can’t be truly understood or appreciated until you yourself are a dancer. At that point in time, where you become an appreciator of contemporary dance, you begin attending concerts, watching dances, and choreographing yourself; I think much of the math major’s drive for math comes from passion for the subject and the abstract (to which I am woefully unable to process).\nSo why is physics a circus, in this case? Why did I chose this specific art form? I’d say that its because physics is so general as a whole (and yes, engineering is too, but wait). Whereas other majors have either many restrictions (engineering) or stay constrained to the abstract (math), physics is a way of interacting with, modeling, and reconstruing the world, often in new, exciting ways. Obviously, this comes with a great degree of intensity; you can’t stick your head into a lion’s mouth without being prepared to lose your head, you don’t swallow fire without having burned your tongue a few times. I think that the circus, to me, means that there are many different ways of pursuing physics, both theoretical and experimental, and for each of these there is a requisite for a large range of experiences and a vast array of different personalities; but what defines the circus, as what defines physics, is the way in which physicists will spend hours working through one extremely difficult problem, much like how a circus will confront the unknown; physics is unique in that it is almost always set to face a vast array of the unknown and unexplored, because its primary goal is to explore.\nThis leads back to my quotations at the top from my physics friends. I think physics comes with a heavy dose of cynicism - just like the circus, its not all sunshine and rainbows – behind every trapeze trick and quantum computation are hours of work and team work and collaboration, perfected to the point that it looks easy. And it is all a part of some great, wide variety of things, that culminates in the spectacle that we have come to love."
  },
  {
    "objectID": "projects/e-155_website/posts/003_post_2024-09-08.html",
    "href": "projects/e-155_website/posts/003_post_2024-09-08.html",
    "title": "Worldbuilding while on the Move",
    "section": "",
    "text": "Worldbuilding on the Move\nThere are always endless excuses to not doing the things you want to do. At least, that’s what we tell ourselves – but sometimes it is the case that you are actually, fundamentally too busy to do what you want to do. This was a thought I had a while ago when I first started trying to worldbuild. What do you do when you literally don’t have the hours you want to work on something you’re passionate about? Or what do you do if you want to work on that thing during a period when you really, really can’t afford to do it?\nThe answer is, and its quite obvious, you do it when you’re on the move. That was the case for my world building adventures so far.\nI realized at a certain pointa few years ago that my art had stagnated - mainly due to me not being able to practice it as much in college. Engineering meant that unless I had whatever I was making due as an assignment for class, I would never actually be able to do the hour long projects that I had been able to devote to it during my senior year of high school (where I was stuck in quarantine with a large pad of paper, a box of colored pencils, and a senior portfolio to draw). I took inspiration from time to time in little doodles in my notebooks, but it was hard to be consistent, or to even have a theme to draw. THe main issue was that there simply wasn’t enough time to make the firm start I needed for making another art project; I needed to be able to come up with something coherent during the short fifteen minute windows I was running between classes or when I was taking notes, but that type of thing, at least in my head, takes time.\nThe change came when I began listening to Youtube art videos while walking too and from class, specifically about DeviantArt Drama. The drama itself wasn’t what inspired me, but rather who the drama featured. Swatches of artists on the internet have specific characters they draw, repeatedly, over and over again, in different scenarios, storylines, with different aesthetics or interactions. It is an endless supply of inspiration, in many cases, and often a way for them to express themselves or their own personalities or struggles through their artwork. Some might call it self-insert.\nNow why was this interesting to me? Why did this become some big epiphany? Because it gave my brain a direction to move towards. Previously, the main difficulty was a lack of a goal; I would worldbuild small amounts at a time, for a bunch of different stories, and the discombobulation of it all was what I think caused some of the stalls in my own artpieces. But many of these Deviantartists had been creating their characters and the world around them for years, decades even; it was Tolkein levels of thought, for some of them. It was the inspiration I needed.\nWhy?\nBecause it made me want to make something that would last from weeks to months to years; rather than just making a small idea and doodling it briefly in my notebook, I made a conscious, though small, effort to incorporate some world building into the doodles I drew on the go or in the margins. I focused more on fleshing out a world while listening to Debussy, or to creating plots for characters inside the world while listening to pop. That’s not to say everything I drew was consumed by worldbuilding, but the concerted effort I made to making something that was more than just something to pass the time, but something with a long term goal, was an important switch.\nSo where am I now?\nAbout four years into making a fantasy world, with fantasy creatures of my own design, fantasy races, characters, and ideas, and all of it cossting a few minutes of a day from the past few years. Worldbuilding is difficult; worldbuilding when you don’t have the hours you need to do it requires a decision on your part to focus on planning it in the few minutes you can steal. So to those artists or writers, to my fellow engineers who want to find the time but can’t make it work, come up with a goal, and make the small tweaks to edge you in the right direction. It doesn’t need to happen all at once; ideas can come slow, and sometimes you may even forget about the goal before you find it again. What’s important is that small bit you add every so often, so that you build yourself from a blank page to a masterpiece.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/e-155_website/posts/initial_learning_goals.html",
    "href": "projects/e-155_website/posts/initial_learning_goals.html",
    "title": "E155: Learning Goals",
    "section": "",
    "text": "My final goals for MicroP’s mainly revolve around getting more familiar with FPGA boards, as well as practicing my time management skills. This semester is set up to be packed with a lot of material, but it is all material that focuses mainly on projects rather than problem sets: resultantly, it’s an excellent way to hone in on my organization and my calendar skills.\nAdditionally, it has been about a year since I took E85, which means that many of my Verilog skills that I built up are rusty; this ought to be an excellent way to get back into programming in SystemVerilog. Additionally, FPGA’s are heavily used within the radio transmitting and signal processing world, and so I think it’s very important that I learn how to interact with them, even at their most basic level.\nFinally, I’m excited that this course incorporates Quarto and Github! It was not something that I was anticipating, but I believe that one of my final goals with this course is to build some additional professional skills that will allow me to present my work better, whether in academia or in industry."
  },
  {
    "objectID": "projects/e-155_website/posts/initial_learning_goals.html#my-thoughts",
    "href": "projects/e-155_website/posts/initial_learning_goals.html#my-thoughts",
    "title": "E155: Learning Goals",
    "section": "",
    "text": "My final goals for MicroP’s mainly revolve around getting more familiar with FPGA boards, as well as practicing my time management skills. This semester is set up to be packed with a lot of material, but it is all material that focuses mainly on projects rather than problem sets: resultantly, it’s an excellent way to hone in on my organization and my calendar skills.\nAdditionally, it has been about a year since I took E85, which means that many of my Verilog skills that I built up are rusty; this ought to be an excellent way to get back into programming in SystemVerilog. Additionally, FPGA’s are heavily used within the radio transmitting and signal processing world, and so I think it’s very important that I learn how to interact with them, even at their most basic level.\nFinally, I’m excited that this course incorporates Quarto and Github! It was not something that I was anticipating, but I believe that one of my final goals with this course is to build some additional professional skills that will allow me to present my work better, whether in academia or in industry."
  },
  {
    "objectID": "projects/e-155_website/posts/002_post_2024-09-05.html",
    "href": "projects/e-155_website/posts/002_post_2024-09-05.html",
    "title": "The Swamp That Stands Between",
    "section": "",
    "text": "The Swamp That Stands Between: Engineering and (Studio) Art\n\nTo Be Honest…\nI’m extremely surprised that more artists don’t turn up inside engineering. Looking at it pragmatically, engineering and art share quite a bit of cross-dialogue. Engineering, for example, has ill-defined points where a prototype becomes a “finished” article; in many of the same ways that a painter will look at a piece and not be able to say with absolute certainty “this is done”, an engineer will normally look at their circuit design and say “this is up to caliper”. Now, obviously, that isn’t to say there are some distinct divides; no one will be killed if a painting is missing a few lines or drawing in an odd way, but a bridge built with miscalculations or a power plant that’s not assembled up to a great degree of specific calibrations is bound to at least endanger many lives.\nSide note, I’d like to make it clear that much of the art I’ll be talking about in this blog post is the artform I’m most familiar with, being studio and digital art; normally very traditional, and falls well before many of the early 20th century movements that began questioning what exactly defines what art is; I refer to art here in a pretty classical, unnuanced sense, and plan on discussing Dadaism, Surrealism, Pop Art, etc. for a later day\nBut the fact remains that fundamentally, many of the same ideas we see in art appear in engineering. Diagrams, for example. Multiple drafts. Working at resembling real world structures and rendering them, sometimes twisting them or simplifying them, to either get a better understanding or a new interpretation. Both are inherently human, and require large degrees of creativity.\nI believe the fundamental differences between these two, and the reason that so few artists turn up as engineers, or so few engineers turn up as artists, is two fold: 1. Engineering and (studio) art’s high bar for entry 2. Engineering’s restrictions\nI don’t think many people would argue with me when I say that engineering has a high bar for entry; you need a lot of STEM background, an appreciation for systems often, and you need to not only enjoy being a problem solver but have been encouraged to do so; much of engineering, at least as a student, is as much about will power, perserverance, and a drive to succeed, as it is a series of mathematical expressions and designs.\nBut why would I say that art has a high bar for entry? This one, I think, is more a mental high bar than a physical one. To any artists reading this, I want you to fill in the following blank in my imaginary scenario:\nPerson A: [showing an artwork] This is a cat that I drew! I based it off of a photo of my cat, but I used oil pastel and changed the colors around to make it appear neon and change color under UV lighting.\nPerson B: Oh my gosh, I could never draw something like that! I can’t even draw a ____.\nIf your answer to that is stick figure, you are one of the many artists who are seeing live the high-bar for entry that is artistry, and very similar to engineering, its a mental one. Where engineering is exhausting while being learned, and requires a large amount of devotion (sometimes at expense of social life, for example), artistry requries a will to improve; it is self driven, at the end of the day, similar to engineering, but unlike engineering it requires constant, subjective comparison. It requires the artist to ask themselves “where did I go wrong”, “how could I improve this”, or “why doesn’t my artwork look like theirs”. The internal battle within artwork creates a high bar for entry that many people are scared to face and overcome, particularly later in life.\nAll that is to say, that there are high bars to enter both engineering and art, both of them mental, and both of them requiring either early interest in the subject or the drive to pursue them later in life despite societal opposition (less-so is this true for engineering). Resultantly, the chance of meeting someone who has been able to do both art and engineering is lower than you would think.\nMoving onto the second bullet, being Engineering’s restrictions, I think that this is one of the things that holds artists back from joining engineering - the fact that engineering is an artform with a great degree of restrictions applied. From my perspective, engineering’s prototyping is a reflection of how it exists as a form of art. The difference from prototyping in art, however, and prototyping in engineering, is that as I said before if you make a prototype the final design, someone could get hurt in engineering. Engineering has built of a long history of rules and regulations (and logically so), but I think that to the average artist, who is so familiar with the ability to build what they want and do what they want with their artform, without rules, engineering likely feels quite restrictive. In many ways its like putting blinders on a horse; it focuses your energy, it keeps you focused on the road ahead; it keeps you and the people around you safe. But I think that at the same time, it’s just as good to let the horse roam a little bit, see the world, get spooked etc (I’m not a horse girl, if you couldn’t tell, and I’m sure many horse people got very mad at me for saying that just now). My main point is that engineering’s restrictions are unfortunately somewhat contradictory to what some artists want to do with their artforms, and resultantly engineering only applies to a few select artists who enjoy challenging themselves by placing restrictions on their own art forms. Engineering, then, is almost a practice in artistic expression that faces many requisites in order to ensure a sense of safety and coherence for its majors.\n\n\n\n\n\n\nInspiration\n\n\n\nCall it a happy accident. While I was breadboarding for Lab 2 of HMC E155, I noticed that the wires and the way everything was coming together looks very similar to abstract art. In general, a lot of engineering (especially in its early stages) looks more like an art project than anything else. It made me think a bit about how to define the divide between the two."
  },
  {
    "objectID": "projects/e-155_website/labs/lab4/lab4.html",
    "href": "projects/e-155_website/labs/lab4/lab4.html",
    "title": "Lab 4 Writeup",
    "section": "",
    "text": "Hours Spent: 48.6, Mapped with Toggl Track\n\n\nIn this lab, a STM32L432KCU Microcontroller Unit (the MCU) was used to control a SM231508-1 Speaker to play a series of different musical songs. In order to do so, the MCU was programmed to control the E155 Breadboard Adapter v4 board to output voltages on GPIO pins using an internall phase-lock looped clock, as well as two timers. Through the design of several structs, the enabling of cross communication between pins, and careful reading of the datasheet, the microcontroller was configured to play songs like “Fur Elise” as well as “Megalovania” and several other recognizable game tunes.\n\n\n\n\n\nSegger Embedded Studio 8.16a was used to program all modules. In order to do so, it was necessary to first find all relevant and necessary components for this lab, as well as compile a series of libraries that would be used in its construction. Of note, we were explicitly told to not use the inbuilt stm32l432xx.h header file from the Segger’s library; we wrote all headers and c code for this class from scratch to ensure that we understood all necessary components.\n\n\n\n\n\n\n\n\n\nThe system that was designed for this lab required this simple framework (Figure 1) to function: the main point was that a clock (CLOCK) would be generated and sent into two timers (FREQUENCY_TIMER and DELAY_TIMER); the first would control the frequency of the speaker (GPIO_OUT), the second would control for how long the frequency was played. As a result, we would need to make four c files:\n\nmain.c: a C file that sits above all the headers and other c files in order to properly assign the enable pins and run the actual music itself.\nclk.c/clk.h: A paired C and C header file that assign the proper variables and memory allocations for running clocks onboard the MCU. This looks specifically at pages 175-246 of the STM Reference Manual to assign all relevant materials. Further details of what needed to be assigned of this can be found in Clock Memory and Layout (Section 1.2.1.1).\ntimer.c/timer.h: A paired C and C header file that assign the proper variables and memory allocation for running timers onboard the MCU. It uses logic gathered from pages 817-980 in the STM Reference Manual and pages 51-58 in the STM32L432xx Datasheet. Further details of what needed to be assigned of this can be found in Timer Layout.\ngpio.c/gpio.h: A paired C and C header file that assign the proper variables and memory allocation for connecting to GPIO pins onboard the mcu. It uses logic gathered from pages 258-275 in the STM Reference Manual. Further details of what needed to be assigned of this can be found in Timer Layout (Section 1.2.1.3).\n\nThis expanded out into the final, overarching layout seen in Figure 2.\n\n\n\n\n\n\n\n\n\n\n\nBefore programming anything, all necessary parameters to control a clock were written out using Figure 13 in the Reference Manual. For this specific scenario, I wanted to control the phase-locked loop clock to gain experience with varying an onboard clock within the program. This required the layout of the memory bank (based on pages 243-246 in the Reference Manual), as well as the variables assigned as indicated in Table 1 and Table 2. In order to easily access each memory bit, I set up a structure within the header file (called RCC_STM32L432xx_TypeDef), which I then built off the RCC base located at 0x40021000UL to control each individual register on the MCU. There are two functions for this program: configurePLL and configureClock; configurePLL sets up the PLL to be connected to the onboard MSI clock, and configureClock sets up a clock to be delivered to the rest of the board.\n\n\n\nTable 1: configurePLL Memory Assignments\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nPLLON (beginning of configurePLL)\n0 at bit 24\nRCC, Configuration Register (CR)\nSo that the clock can be properly reconfigured, it must be turned off\n\n\nPLLRDY\nnot assigned, but wait until its 0\nRCC, Configuration Register (CR)\nWait to make sure you can reprogram this bit\n\n\nPLL_SRC\n1 at bit 0\nRCC, PLL Configuration Register (PLL_CFGR)\nTurning on PLL and connecting it to the MSI (40 MHz) internal clock\n\n\nPLLR\n0b00 from bits 25:26\nRCC, PLL Configuration Register (PLL_CFGR)\nDividing the incoming clock (MSI) by a factor of 2\n\n\nPLLM\n0b000 from bits 4:6\nRCC, PLL Configuration Register (PLL_CFGR)\nDividing the output clock (Voltage Controlled Oscillator Output) by 1\n\n\nPLLN\n10 from bits 14:18\nRCC, PLL Configuration Register (PLL_CFGR)\nMultiplying the output clock by 16\n\n\nPLLON (end of configurePLL)\n1 at bit 24\nRCC, Configuration Register (CR)\nSo that the PLL is now running again, reconfigured\n\n\nPLLCLK\n1 at bit 24\nRCC, PLL Configuration Register (PLL_CFGR)\nSo that the PLL is sent out of the register as the internal clock\n\n\n\n\n\n\n\n\n\nTable 2: configureClock Memory Assignments\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nSW\n0b11 at bits 0:1\nRCC, Configuration Register\nTo set up the output clock to be PLL\n\n\nSWS\n0b11 at bits 2:3\nRCC, Configuration Register\nTo make sure that the PLL has been configured on, we wait for this to be 1\n\n\n\n\n\n\n\n\n\nFor this specific scenario, I wanted to control two timers (as specified in Figure 1), one that would be used to control the frequency of the speaker, and the other that would be used to control how long the frequency was played. This required the layout of the memory bank (based on pages 814-816 in the Reference Manual), as well as the variables assigned as indicated in the Expandable Table. In order to easily access each memory bit, I set up three structures within the header file for Timers 2 and 3, Timers 15 and 16, and Timers 6 and 7 (since each has some variables unassigned, and I didn’t want to accidentaly assign the wrong bits if I happened to be writing to the wrong clock on accident). These structures are called TIM_67_STM32L432xx_TypeDef (Timers 6 and 7), TIM_ALL_STM32L432xx_TypeDef (Could apply to any timer, but is constrained in potential variables for more complex operations (i.e. runs all timers similar to timers 6 and 7)), TIM15_STM32L432xx_TypeDef (Timer 15), and TIM_23_STM32L432xx_TypeDef (Timers 2 and 3). Of these, I built all Timers as defined by their memory as found in Table 2, page 68 and 69 of the reference manual (placed below).\n\n\n\n\n\n\n\n\nThe variables were assigned for the following values in order to run: in total, I have four functions: delay(TIM_67_STM32L432xx_TypeDef * DELAY_TIMx, uint32_t time), configure_TIM23_PWM(TIM_23_STM32L432xx_TypeDef *  TIMx, int freq, double duty), configure_TIM2_CH1_PWM(int freq, double duty), and configure_TIMx(TIM_67_STM32L432xx_TypeDef *  TIMx). Each of these functions is meant to set up a timer or perform a function using said timer. configure_TIM23_PWM is meant to set up either Timers 2 or 3 acting in PWM mode. configure_TIM2_CH1_PWM was created to control specifically timer TIM2, and noticeably does not take in an input TypeDef clock. There is an additional function within the C file with a similar name, which overloads this function, and performs a similar function but with a predecided frequency and duty cycle for the timer, which was used to organize when designing the other functions; it cannot be called from the main C function. configure_TIMx is meant to set up a given timer to begin running in counter only (since it is for Timers 6 and 7, which cannot generate their own outputs). Finally, delay assumes that the user is using configure_TIMx to design a timer, and with the predetermined parameters for this function (i.e. generates a signal at 77 kHz), waits for time number of miliseconds. I will specify only the variables as defined in the configure_TIM23_PWM function, as this is what is used within the program to setup the desired frequencies for the speaker’s singing, and all the logic used for the configuration of CNTR, ARR, and CCR is used for setting up TIM6.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nCC1S\n0b00 at bits 0:1\nCapture/Compare Register 1 (CCR1)\nConfigure Channel 1 of the clock as Output\n\n\nOC1M\n0 at bit 16, 0b111 at bits 4:6\nCapture/Compare Register 1 (CCR1)\nConfigure the timer in PWM mode 2 (i.e. high when the counter is greater than the assigned CCR value)\n\n\nCC1E\n1 at bit 0\nCapture/Compare Enable Register (CCER)\nSet OC1 as the active channel\n\n\nCC1P\n0 at bit 1\nCapture/Compare Enable Register (CCER)\nMake OC1’s “active” be 1 (i.e. when its “on”, its output voltage)\n\n\nECE\n0 at bit 14\nSlave Mode Control Register (SMCR)\nSets the external clock to 0 to make sure that we are using the internal clock for this timer\n\n\nSMS\n0 at bit 16, 0b000 at bits 0:2\nSlave Mode Control Register (SMCR)\nSets the internal clock to be used when CEN is enabled\n\n\nETF\n0b011 at bit 8\nSlave Mode Control Register (SMCR)\nSets the external trigger factor such that it divides the input clock by 8\n\n\nPSC\n256\nPrescaler Register\nSets the input clock to be divided by 256 (slowing the timer down)\n\n\nARR\n9 kHz / desired frequency\nAuto-reload Register (ARR)\nSets the value the counter will get to (sets frequency of timer)\n\n\nCCR1\nduty cycle * ARR’s value\nCapture/Compare Register 1 (CCR1)\nSets the value the counter is compared against (generates output and duty cycle)\n\n\nOC1PE\n1 at bit 3\nCapture/Compare Mode Register 1 (CCMR1)\nEnables the preload for this channel. Necessary for PWM mode unless configure in One-Pulse mode\n\n\nARPE\n1 at bit 7\nControl Register 1 (CR1)\nEnable the auto-reload preload feature\n\n\nCC1G\n1 at bit 1\nEvent Generation Register (EGR)\nEnable the Capture/Compare 1 Generator\n\n\nUG\n1 at bit 0\nEvent Generation Register (EGR)\nEnable the update generation; this will allow us to continue counting over and over via taking advantage of the shadow preload registers\n\n\nCMS\n0b00 at bits 5:6\nControl Register 1 (CR1)\nSet the timer to work in edge-aligned mode\n\n\nDIR\n0 at bit 4\nControl Register 1 (CR1)\nSet the counter to be an upcounter\n\n\nCEN\n1 at bit 0\nControl Register 1 (CR1)\nEnable the counter\n\n\n\n:Timer Commands Table{tbl-colwidths=“[10,30, 30,50]”}\n\n\n\n\n\n\nThere are two primary things that need to be done to set up the GPIO pins on board the MCU: the first is that they are set up in a mode that can communicate with the timer (in this case, I chose to use Alternate Function 1, which allows PA5 to communicate with Timer 2’s Channel 1), and the second that the pin is enabled. There are four functions within my gpio.c class, but in this instance only one of these functions is necessary, the setModeOfPinA function. This function sets the GPIO’s mode into the “alternate function” mode, which will allow certain pins to interact with other on-board pins.\nTo do this, the MODER register of the GPIO structure that I constructed in header needs to have the two bits that refer to the GPIO pin on the board set to 0b10: after this, AF logic assigned within the main function will be able to correctly interact with and assign values to the pin.\n\n\n\nThe final C file of this lab is the main.c, which compiles all of the code together. Inside, it calls the configureClock function (which calls configurePLL), sets the mode of the pin, configures the timers, and connects the clocks to the timers and the pins. Finally, it also assigns the alternate function desired to the pin via the low alternate function register (GPIOA - AFRL); I referred again to Table 15 in the MCU Datasheet.\n\n\n\n\nThe frequencies generated by the speaker were confirmed to be accurate through the use of an iPhone tuner app “Tuner T1”, and via calculations for each of the relevant frequencies and time delays.\nTimer 2 was used to generate frequencies. Because it has both a prescaler and the internal variable ETF (external trigger factor), it was able to divide the incoming frequency (in this case, the 20MHz generated by the PLL timer) twice. The PSC was set to be 32, and the ETF to be 8, which effectively scales the timer to run at a 75757.58 Hz. The frequencies that it is able to send the speaker, then, vary depending on the size of the array, and potentially additional configurations you can make to the duty cycle. The highest frequency that could be produced using this PSC and ETF setup \\[\n\\frac{75757.58}{2} Hz = 37878.79 Hz\n\\]\nThis is because the speaker must be turned off and on to generate one full wave; in order for a full period to pass, the output must be turned off and on again, meaning that CCR1 would be set to 1, and ARR would be set to 2 in this scenario.\nThe lowest frequency possible with this clock would be one where the counter counts to the maximum value of ARR. I am currently assuming that the user may chose to use Timer 2 or Timer 3, so although Timer 2 could have an array of up to \\(2^{32} - 1\\) counts, I will first consider both Timers together (where Timer 3 is constrained to 16 bits). In this scenario, the maximum that the counter could ever reach would be \\(2^{16}-1\\), or 65535. In this case, the lowest possible frequency would be given by\n\\[\n\\frac{75757.58}{65535} Hz = 1.16 Hz\n\\]\nHowever, I would also like to consider possible future reiterations of this design that could allow for even more flexibility with frequency and duration: in the case where we only use Timer 2, and we include the 32 bits that Timer 2 can use for ARR, the lowest possible frequency is 17.64 µHz. If we additionally consider that we could arrange an additional function that sets the output to its inverse whenever the counter is set (effectively creating a 50% duty cycle for half the frequency), we would be able to get either 0.578 Hz for the 15 bit timer, or as low as 8.82 µHz for the 32 bit timer.\nAs it appies to the accuracy of the timer, the timer should be within 1% of of a given frequency relative to 1000 Hz; because it is an integer value, sometimes values may be clipped for the frequency. However, this is a minimal amount of frequency clipping. 1% of the frequency range, in this case is given by\n\\[\n\\frac{1000-220}{100} = 7.8 Hz\n\\]\nIn order for the frequency to be within 1% of 220 Hz, for example, it would need to be between about 213 and 227 Hz. With our current frequency, the integer division of our clock frequency over time would mean that each square wave would happen over a period of \\(\\frac{75757.58}{220} = 344.4\\) counts. If this is rounded to the nearest integer using the ceil function in C (i.e. 344), the actual Hz that would be generated by the speaker would be 220.2 Hz, well within our required frequency limit. If we go to the maximum Hz range, we can see that the final length of the cycle would be \\(\\frac{75757.58}{1000}\\) or 75.75 counts, which would become 76. In this case, the final generated frequency would be 996.81, which is 0.4% from it’s intended value relative to the range (using \\(\\frac{1000-996.81}{1000-220} = 0.4%\\)), which inside our desired 1% range.\nAs for the delay timer, I currently have it configured so that it prescales by 512. Because there is no external filter trigger in this instance, we do not divide by any additional values, and so the frequency of the counter within TIM6 is given by \\[\n\\frac{20}{512} MHz = 39 kHz\n\\]\nThe shortest possible delay for this timer would resultantly be the length of one counter, i.e. 1/39 kHz, which in this case is 25.6 µs. In the case that we would like it to last as long as possible, the longest period would be when \\(2^{16} - 1\\) clock cycles occur (i.e. ARR = 65535), which would mean a longest period of 1.678 seconds. In our case, since we are playing music that has, at maximum, a whole note that lasts a second, all the music is well within the range of possible note lengths.\n\n\n\n\nThe hardware setup for this lab was relatively simple. Because the speaker requires a greater current that the MCU GPIO pins can provide, I used an LM386 amplifier to set-up my system. This chip was set up for a gain of 50 (relative to Figure 9-5 on the data sheet), and has a 10k potentiometer place at the output of pin 3 in order to control the volume of the speaker Figure 3.\n\n\n\n\n\n\nFigure 3: Schematic Diagram\n\n\n\n\n\n\nBecause this lab required the implementation of multiple parts, I used two strategies to confirm that my code was working as expected. The first was the “Build and Debug” mode that is found inside of Segger Embedded Studio, which allows you to see the internal memory of the MCU as its running. With this, I was able to confirm when my counter was working, and additionally catch bugs. Some relevant bugs that I caught using this strategy were:\n\nI did not initially realize that Timer 2 had 32 bits, and resultantly the CCR1 was consistently being set to a negative value. This meant that counter was always greater than CCR1, and because it was set to output high when this was the case (PWM mode 2), the LED never turned off. After setting the values within counter (CNTR), ARR, and CCR1 to display their decimal values, I realized that CCR1 was displaying a negative number, and so I altered the upper bits of both ARR and CCR1 so that they were not negative.\nFor a long time I was not able to get the output traveling to GPIO A. I noticed while debugging that GPIO was not updating at all, even though I had confirmed before adding the timer that it was able to update. When I cross-checked my code with a demo I made to blink the LED, I quickly realized that I had accidentally set the GPIO B pins, not the GPIO A ones.\n\nFor an additional form of testing, specifically to confirm that I was seeing the anticipated frequencies, I hooked up an LED to my output in order to observe it blinking at low Hz. This helped me confirm that the calculations that I had made for the frequencies were correct (i.e. the delay of 1 second worked, and that the frequency of blinking was similarly accurate). Although there are no test benches for this program, I believe that in the end this worked effectively to debug my system as a whole.\n\n\n\nIn conclusion, this lab was a success in configuring an MCU board using C headers and functions. It additionally provided insight into the internal structures and memories found on an MCU, as well as provided a comprehensive understanding of all the relevant background required for working with MCU (Figure 4).\n\n\n\n\n\n\n\n\nFigure 4: Video of the MCU playing three different songs back to back.\n\n\n\n\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed both visually and with the aid of a test bench. The program is able to multiplex successfully without having the two LEDs bleed over, and all digits are equally lit for each segment, and proper calculations for the PNP transistor can be found above.\nI spent a total of 48.6 hours working on this lab, with roughly seven of them spent on the lab writeup, and three spent on fixing the github repo that I broke by uploading a video that was too big, if including the planning of the modules and compiling all of the necessary diagrams."
  },
  {
    "objectID": "projects/e-155_website/labs/lab4/lab4.html#lab-4-digital-audio",
    "href": "projects/e-155_website/labs/lab4/lab4.html#lab-4-digital-audio",
    "title": "Lab 4 Writeup",
    "section": "",
    "text": "Hours Spent: 48.6, Mapped with Toggl Track\n\n\nIn this lab, a STM32L432KCU Microcontroller Unit (the MCU) was used to control a SM231508-1 Speaker to play a series of different musical songs. In order to do so, the MCU was programmed to control the E155 Breadboard Adapter v4 board to output voltages on GPIO pins using an internall phase-lock looped clock, as well as two timers. Through the design of several structs, the enabling of cross communication between pins, and careful reading of the datasheet, the microcontroller was configured to play songs like “Fur Elise” as well as “Megalovania” and several other recognizable game tunes.\n\n\n\n\n\nSegger Embedded Studio 8.16a was used to program all modules. In order to do so, it was necessary to first find all relevant and necessary components for this lab, as well as compile a series of libraries that would be used in its construction. Of note, we were explicitly told to not use the inbuilt stm32l432xx.h header file from the Segger’s library; we wrote all headers and c code for this class from scratch to ensure that we understood all necessary components.\n\n\n\n\n\n\n\n\n\nThe system that was designed for this lab required this simple framework (Figure 1) to function: the main point was that a clock (CLOCK) would be generated and sent into two timers (FREQUENCY_TIMER and DELAY_TIMER); the first would control the frequency of the speaker (GPIO_OUT), the second would control for how long the frequency was played. As a result, we would need to make four c files:\n\nmain.c: a C file that sits above all the headers and other c files in order to properly assign the enable pins and run the actual music itself.\nclk.c/clk.h: A paired C and C header file that assign the proper variables and memory allocations for running clocks onboard the MCU. This looks specifically at pages 175-246 of the STM Reference Manual to assign all relevant materials. Further details of what needed to be assigned of this can be found in Clock Memory and Layout (Section 1.2.1.1).\ntimer.c/timer.h: A paired C and C header file that assign the proper variables and memory allocation for running timers onboard the MCU. It uses logic gathered from pages 817-980 in the STM Reference Manual and pages 51-58 in the STM32L432xx Datasheet. Further details of what needed to be assigned of this can be found in Timer Layout.\ngpio.c/gpio.h: A paired C and C header file that assign the proper variables and memory allocation for connecting to GPIO pins onboard the mcu. It uses logic gathered from pages 258-275 in the STM Reference Manual. Further details of what needed to be assigned of this can be found in Timer Layout (Section 1.2.1.3).\n\nThis expanded out into the final, overarching layout seen in Figure 2.\n\n\n\n\n\n\n\n\n\n\n\nBefore programming anything, all necessary parameters to control a clock were written out using Figure 13 in the Reference Manual. For this specific scenario, I wanted to control the phase-locked loop clock to gain experience with varying an onboard clock within the program. This required the layout of the memory bank (based on pages 243-246 in the Reference Manual), as well as the variables assigned as indicated in Table 1 and Table 2. In order to easily access each memory bit, I set up a structure within the header file (called RCC_STM32L432xx_TypeDef), which I then built off the RCC base located at 0x40021000UL to control each individual register on the MCU. There are two functions for this program: configurePLL and configureClock; configurePLL sets up the PLL to be connected to the onboard MSI clock, and configureClock sets up a clock to be delivered to the rest of the board.\n\n\n\nTable 1: configurePLL Memory Assignments\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nPLLON (beginning of configurePLL)\n0 at bit 24\nRCC, Configuration Register (CR)\nSo that the clock can be properly reconfigured, it must be turned off\n\n\nPLLRDY\nnot assigned, but wait until its 0\nRCC, Configuration Register (CR)\nWait to make sure you can reprogram this bit\n\n\nPLL_SRC\n1 at bit 0\nRCC, PLL Configuration Register (PLL_CFGR)\nTurning on PLL and connecting it to the MSI (40 MHz) internal clock\n\n\nPLLR\n0b00 from bits 25:26\nRCC, PLL Configuration Register (PLL_CFGR)\nDividing the incoming clock (MSI) by a factor of 2\n\n\nPLLM\n0b000 from bits 4:6\nRCC, PLL Configuration Register (PLL_CFGR)\nDividing the output clock (Voltage Controlled Oscillator Output) by 1\n\n\nPLLN\n10 from bits 14:18\nRCC, PLL Configuration Register (PLL_CFGR)\nMultiplying the output clock by 16\n\n\nPLLON (end of configurePLL)\n1 at bit 24\nRCC, Configuration Register (CR)\nSo that the PLL is now running again, reconfigured\n\n\nPLLCLK\n1 at bit 24\nRCC, PLL Configuration Register (PLL_CFGR)\nSo that the PLL is sent out of the register as the internal clock\n\n\n\n\n\n\n\n\n\nTable 2: configureClock Memory Assignments\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nSW\n0b11 at bits 0:1\nRCC, Configuration Register\nTo set up the output clock to be PLL\n\n\nSWS\n0b11 at bits 2:3\nRCC, Configuration Register\nTo make sure that the PLL has been configured on, we wait for this to be 1\n\n\n\n\n\n\n\n\n\nFor this specific scenario, I wanted to control two timers (as specified in Figure 1), one that would be used to control the frequency of the speaker, and the other that would be used to control how long the frequency was played. This required the layout of the memory bank (based on pages 814-816 in the Reference Manual), as well as the variables assigned as indicated in the Expandable Table. In order to easily access each memory bit, I set up three structures within the header file for Timers 2 and 3, Timers 15 and 16, and Timers 6 and 7 (since each has some variables unassigned, and I didn’t want to accidentaly assign the wrong bits if I happened to be writing to the wrong clock on accident). These structures are called TIM_67_STM32L432xx_TypeDef (Timers 6 and 7), TIM_ALL_STM32L432xx_TypeDef (Could apply to any timer, but is constrained in potential variables for more complex operations (i.e. runs all timers similar to timers 6 and 7)), TIM15_STM32L432xx_TypeDef (Timer 15), and TIM_23_STM32L432xx_TypeDef (Timers 2 and 3). Of these, I built all Timers as defined by their memory as found in Table 2, page 68 and 69 of the reference manual (placed below).\n\n\n\n\n\n\n\n\nThe variables were assigned for the following values in order to run: in total, I have four functions: delay(TIM_67_STM32L432xx_TypeDef * DELAY_TIMx, uint32_t time), configure_TIM23_PWM(TIM_23_STM32L432xx_TypeDef *  TIMx, int freq, double duty), configure_TIM2_CH1_PWM(int freq, double duty), and configure_TIMx(TIM_67_STM32L432xx_TypeDef *  TIMx). Each of these functions is meant to set up a timer or perform a function using said timer. configure_TIM23_PWM is meant to set up either Timers 2 or 3 acting in PWM mode. configure_TIM2_CH1_PWM was created to control specifically timer TIM2, and noticeably does not take in an input TypeDef clock. There is an additional function within the C file with a similar name, which overloads this function, and performs a similar function but with a predecided frequency and duty cycle for the timer, which was used to organize when designing the other functions; it cannot be called from the main C function. configure_TIMx is meant to set up a given timer to begin running in counter only (since it is for Timers 6 and 7, which cannot generate their own outputs). Finally, delay assumes that the user is using configure_TIMx to design a timer, and with the predetermined parameters for this function (i.e. generates a signal at 77 kHz), waits for time number of miliseconds. I will specify only the variables as defined in the configure_TIM23_PWM function, as this is what is used within the program to setup the desired frequencies for the speaker’s singing, and all the logic used for the configuration of CNTR, ARR, and CCR is used for setting up TIM6.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable Name\nVariable Assignment\nVariable Location\nPurpose\n\n\n\n\nCC1S\n0b00 at bits 0:1\nCapture/Compare Register 1 (CCR1)\nConfigure Channel 1 of the clock as Output\n\n\nOC1M\n0 at bit 16, 0b111 at bits 4:6\nCapture/Compare Register 1 (CCR1)\nConfigure the timer in PWM mode 2 (i.e. high when the counter is greater than the assigned CCR value)\n\n\nCC1E\n1 at bit 0\nCapture/Compare Enable Register (CCER)\nSet OC1 as the active channel\n\n\nCC1P\n0 at bit 1\nCapture/Compare Enable Register (CCER)\nMake OC1’s “active” be 1 (i.e. when its “on”, its output voltage)\n\n\nECE\n0 at bit 14\nSlave Mode Control Register (SMCR)\nSets the external clock to 0 to make sure that we are using the internal clock for this timer\n\n\nSMS\n0 at bit 16, 0b000 at bits 0:2\nSlave Mode Control Register (SMCR)\nSets the internal clock to be used when CEN is enabled\n\n\nETF\n0b011 at bit 8\nSlave Mode Control Register (SMCR)\nSets the external trigger factor such that it divides the input clock by 8\n\n\nPSC\n256\nPrescaler Register\nSets the input clock to be divided by 256 (slowing the timer down)\n\n\nARR\n9 kHz / desired frequency\nAuto-reload Register (ARR)\nSets the value the counter will get to (sets frequency of timer)\n\n\nCCR1\nduty cycle * ARR’s value\nCapture/Compare Register 1 (CCR1)\nSets the value the counter is compared against (generates output and duty cycle)\n\n\nOC1PE\n1 at bit 3\nCapture/Compare Mode Register 1 (CCMR1)\nEnables the preload for this channel. Necessary for PWM mode unless configure in One-Pulse mode\n\n\nARPE\n1 at bit 7\nControl Register 1 (CR1)\nEnable the auto-reload preload feature\n\n\nCC1G\n1 at bit 1\nEvent Generation Register (EGR)\nEnable the Capture/Compare 1 Generator\n\n\nUG\n1 at bit 0\nEvent Generation Register (EGR)\nEnable the update generation; this will allow us to continue counting over and over via taking advantage of the shadow preload registers\n\n\nCMS\n0b00 at bits 5:6\nControl Register 1 (CR1)\nSet the timer to work in edge-aligned mode\n\n\nDIR\n0 at bit 4\nControl Register 1 (CR1)\nSet the counter to be an upcounter\n\n\nCEN\n1 at bit 0\nControl Register 1 (CR1)\nEnable the counter\n\n\n\n:Timer Commands Table{tbl-colwidths=“[10,30, 30,50]”}\n\n\n\n\n\n\nThere are two primary things that need to be done to set up the GPIO pins on board the MCU: the first is that they are set up in a mode that can communicate with the timer (in this case, I chose to use Alternate Function 1, which allows PA5 to communicate with Timer 2’s Channel 1), and the second that the pin is enabled. There are four functions within my gpio.c class, but in this instance only one of these functions is necessary, the setModeOfPinA function. This function sets the GPIO’s mode into the “alternate function” mode, which will allow certain pins to interact with other on-board pins.\nTo do this, the MODER register of the GPIO structure that I constructed in header needs to have the two bits that refer to the GPIO pin on the board set to 0b10: after this, AF logic assigned within the main function will be able to correctly interact with and assign values to the pin.\n\n\n\nThe final C file of this lab is the main.c, which compiles all of the code together. Inside, it calls the configureClock function (which calls configurePLL), sets the mode of the pin, configures the timers, and connects the clocks to the timers and the pins. Finally, it also assigns the alternate function desired to the pin via the low alternate function register (GPIOA - AFRL); I referred again to Table 15 in the MCU Datasheet.\n\n\n\n\nThe frequencies generated by the speaker were confirmed to be accurate through the use of an iPhone tuner app “Tuner T1”, and via calculations for each of the relevant frequencies and time delays.\nTimer 2 was used to generate frequencies. Because it has both a prescaler and the internal variable ETF (external trigger factor), it was able to divide the incoming frequency (in this case, the 20MHz generated by the PLL timer) twice. The PSC was set to be 32, and the ETF to be 8, which effectively scales the timer to run at a 75757.58 Hz. The frequencies that it is able to send the speaker, then, vary depending on the size of the array, and potentially additional configurations you can make to the duty cycle. The highest frequency that could be produced using this PSC and ETF setup \\[\n\\frac{75757.58}{2} Hz = 37878.79 Hz\n\\]\nThis is because the speaker must be turned off and on to generate one full wave; in order for a full period to pass, the output must be turned off and on again, meaning that CCR1 would be set to 1, and ARR would be set to 2 in this scenario.\nThe lowest frequency possible with this clock would be one where the counter counts to the maximum value of ARR. I am currently assuming that the user may chose to use Timer 2 or Timer 3, so although Timer 2 could have an array of up to \\(2^{32} - 1\\) counts, I will first consider both Timers together (where Timer 3 is constrained to 16 bits). In this scenario, the maximum that the counter could ever reach would be \\(2^{16}-1\\), or 65535. In this case, the lowest possible frequency would be given by\n\\[\n\\frac{75757.58}{65535} Hz = 1.16 Hz\n\\]\nHowever, I would also like to consider possible future reiterations of this design that could allow for even more flexibility with frequency and duration: in the case where we only use Timer 2, and we include the 32 bits that Timer 2 can use for ARR, the lowest possible frequency is 17.64 µHz. If we additionally consider that we could arrange an additional function that sets the output to its inverse whenever the counter is set (effectively creating a 50% duty cycle for half the frequency), we would be able to get either 0.578 Hz for the 15 bit timer, or as low as 8.82 µHz for the 32 bit timer.\nAs it appies to the accuracy of the timer, the timer should be within 1% of of a given frequency relative to 1000 Hz; because it is an integer value, sometimes values may be clipped for the frequency. However, this is a minimal amount of frequency clipping. 1% of the frequency range, in this case is given by\n\\[\n\\frac{1000-220}{100} = 7.8 Hz\n\\]\nIn order for the frequency to be within 1% of 220 Hz, for example, it would need to be between about 213 and 227 Hz. With our current frequency, the integer division of our clock frequency over time would mean that each square wave would happen over a period of \\(\\frac{75757.58}{220} = 344.4\\) counts. If this is rounded to the nearest integer using the ceil function in C (i.e. 344), the actual Hz that would be generated by the speaker would be 220.2 Hz, well within our required frequency limit. If we go to the maximum Hz range, we can see that the final length of the cycle would be \\(\\frac{75757.58}{1000}\\) or 75.75 counts, which would become 76. In this case, the final generated frequency would be 996.81, which is 0.4% from it’s intended value relative to the range (using \\(\\frac{1000-996.81}{1000-220} = 0.4%\\)), which inside our desired 1% range.\nAs for the delay timer, I currently have it configured so that it prescales by 512. Because there is no external filter trigger in this instance, we do not divide by any additional values, and so the frequency of the counter within TIM6 is given by \\[\n\\frac{20}{512} MHz = 39 kHz\n\\]\nThe shortest possible delay for this timer would resultantly be the length of one counter, i.e. 1/39 kHz, which in this case is 25.6 µs. In the case that we would like it to last as long as possible, the longest period would be when \\(2^{16} - 1\\) clock cycles occur (i.e. ARR = 65535), which would mean a longest period of 1.678 seconds. In our case, since we are playing music that has, at maximum, a whole note that lasts a second, all the music is well within the range of possible note lengths.\n\n\n\n\nThe hardware setup for this lab was relatively simple. Because the speaker requires a greater current that the MCU GPIO pins can provide, I used an LM386 amplifier to set-up my system. This chip was set up for a gain of 50 (relative to Figure 9-5 on the data sheet), and has a 10k potentiometer place at the output of pin 3 in order to control the volume of the speaker Figure 3.\n\n\n\n\n\n\nFigure 3: Schematic Diagram\n\n\n\n\n\n\nBecause this lab required the implementation of multiple parts, I used two strategies to confirm that my code was working as expected. The first was the “Build and Debug” mode that is found inside of Segger Embedded Studio, which allows you to see the internal memory of the MCU as its running. With this, I was able to confirm when my counter was working, and additionally catch bugs. Some relevant bugs that I caught using this strategy were:\n\nI did not initially realize that Timer 2 had 32 bits, and resultantly the CCR1 was consistently being set to a negative value. This meant that counter was always greater than CCR1, and because it was set to output high when this was the case (PWM mode 2), the LED never turned off. After setting the values within counter (CNTR), ARR, and CCR1 to display their decimal values, I realized that CCR1 was displaying a negative number, and so I altered the upper bits of both ARR and CCR1 so that they were not negative.\nFor a long time I was not able to get the output traveling to GPIO A. I noticed while debugging that GPIO was not updating at all, even though I had confirmed before adding the timer that it was able to update. When I cross-checked my code with a demo I made to blink the LED, I quickly realized that I had accidentally set the GPIO B pins, not the GPIO A ones.\n\nFor an additional form of testing, specifically to confirm that I was seeing the anticipated frequencies, I hooked up an LED to my output in order to observe it blinking at low Hz. This helped me confirm that the calculations that I had made for the frequencies were correct (i.e. the delay of 1 second worked, and that the frequency of blinking was similarly accurate). Although there are no test benches for this program, I believe that in the end this worked effectively to debug my system as a whole.\n\n\n\nIn conclusion, this lab was a success in configuring an MCU board using C headers and functions. It additionally provided insight into the internal structures and memories found on an MCU, as well as provided a comprehensive understanding of all the relevant background required for working with MCU (Figure 4).\n\n\n\n\n\n\n\n\nFigure 4: Video of the MCU playing three different songs back to back.\n\n\n\n\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed both visually and with the aid of a test bench. The program is able to multiplex successfully without having the two LEDs bleed over, and all digits are equally lit for each segment, and proper calculations for the PNP transistor can be found above.\nI spent a total of 48.6 hours working on this lab, with roughly seven of them spent on the lab writeup, and three spent on fixing the github repo that I broke by uploading a video that was too big, if including the planning of the modules and compiling all of the necessary diagrams."
  },
  {
    "objectID": "projects/e-155_website/labs/lab2/lab2.html",
    "href": "projects/e-155_website/labs/lab2/lab2.html",
    "title": "Lab 2 Writeup",
    "section": "",
    "text": "Hours Spent: 13.5, Mapped with Toggl Track\n\n\nIn this lab, a design was developed to display the output of two 4-pin DIP Switches on a dual seven segmenet LED matrix, such that each four-pin switch was mapped to one display. The sum of these two values was then displayed on a set of five LEDs. The dual seven segment display is lit up using the same function as in Lab 1. Resultantly, it was necessary to multiplex the dual segment such that only one common anode was powered at a time. In addition, due to the current draw required on the display, the +3.3V regulator on the E155 Board was used to power the seven segment display (with the assumption that a computer would be able to supply the required amount of current). In addition, to prevent the current from flowing directly through the FPGA, the common anode was turned on and off using a PNP transistor setup. The LED display needed to be breadboarded, as well, because there are only a total of 4 FPGA-controllable LEDs onboard the development board. A 10-LED display was used to show the sum of each of the bits for this program.\n\n\n\n\n\nFrom the top layer down, it was understood that there would be the blocks displayed in the diagram depicted below.\n\n\n\n\n\n\nFigure 1: Block Diagram of Modules\n\n\n\nWhen encoded, the lab resultantly consisted of the above modules. They are explained in the table (Table 1) below.\n\n\n\nTable 1: Module Functions\n\n\n\n\n\n\n\n\n\nModule Name\nModule Function\n\n\n\n\ntop.sv\nPuts together lab2. Generates a clock that will run the program, and outputs variables to the necessary pins.\n\n\nlab02.sv\nRuns an always_ff block to determine the current state and the next state of the system. Runs combinational logic blocks of dual_seven_segment and led_summation for required seven segment and led logic\n\n\ndual_seven_seg.sv\nCalls on the seven segment block from Lab 1. According to the clock’s counter, half the time will return seven segment for one switch, and half the time will return the seven seg output for the other\n\n\nseven_segment.sv\nUses combinational logic to determine which seven segment cathodes to turn on, and which to turn off.\n\n\nled_summation.sv\nAdds together the collected 4-bits of the two switches and returns their binary equivalent as a 5-bit array\n\n\n\n\n\n\nSome important notes about this layout is that the clock is used to determine a state, S0 or S1, which will determine which display is turned on at any given time. In state S0, the system would rely on one switch (s1); in this case, seven_segment would be called on for that switch only. The system would then turn a corresponding anode on and off using the PNP resister; in this case, since its a PNP resistor, it needed to be turn “off” to turn the system on. In state S1, the output of seven_segment instead relies on the output of switch s2, and will return the opposite output for the anode display. The logic for this can be found in Table 2, the following can be said for each of the states.\n\n\n\nTable 2: State Logic\n\n\n\n\n\nstate\nSwitch Used for Seven Segment Logic\nAnode 1\nAnode 2\n\n\n\n\nS0\ns1\n0 (i.e. Display 1 is on)\n1 (Display 2 is off)\n\n\nS1\ns2\n1\n0\n\n\nX\nan error has occured, s = 0\n1\n1\n\n\n\n\n\n\nOnce these modules were all written, they were compiled, checked for errors, and finally put into Questa for testing.\n\n\n\nTwo test benches were written for this lab. The first one checks to make sure that lab02.sv as a whole can run, and correctly lights up the LEDs as seen fit. Because direct control of the counter can’t be gotten when calling on this upper-level module, the testbench instead only checked that at least one of the outputs of the potential seven segment outputs was correct. The second was used to determine that the proper segment was lit up when the correct switch/state was entered into the dual_seven_seg module. In the case of both, a testvector file was composed and assembled using Python to make sure that all possible options were checked for and confirmed. This Python program can be found in Github, at this_file.py\n\n\nIn order to make sure that all cases were covered, the test vectors were created by running a for-loop to generate a series of switches; each of these switch combinations was used to generate a potential segment output, and finally a summation-vector was made that could be called on to correctly add the sum of both segments to the end. The python file then printed a series of strings of the form\nswitch1_switch2_segment1_segment2_summed led values\nBy running two for loops to cycle through all potential switch values, it can be confirmed that all potential values within the system have been reached. Within the test bench itself, the system uses an or expression to confirm that at least one of the segment outputs is equal to the segment output of the system. It also confirms that the led_summation is working as anticipated.\nUsing this testbench, confirmation of the functionality of the whole of lab02 was completed, as all tests could be run without failure (Figure 2)\n\n\n\n\n\n\nFigure 2: Output of Running lab02_tb.sv in Questa\n\n\n\n\n\n\nIn order to make sure that all cases were covered, the test vectors for this testbench were created by running a for-loop to generate a series of switches, similar to lab02 testbench. However, these nested for-loops were nested in one final for-loop, which acertained which state the system was in; each of these switch combinations was used to generate a potential segment output, and finally a summation-vector was made that could be called on to correctly add the sum of both segments to the end. The python file then printed a series of strings of the form\nswitch1_switch2_state_segment_anode1_anode2\nBy running two for loops to cycle through all potential switch values, it can be confirmed that all potential values within the system have been reached. Within the test bench itself, the system uses an or expression to confirm that at least one of the segment outputs is equal to the segment output of the system. It also confirms that the led_summation is working as anticipated.\nUsing this testbench, confirmation of the functionality of the whole of lab02 was completed, as all tests could be run without failure (Figure 3)\n\n\n\n\n\n\nFigure 3: Output of Running lab02_tb.sv in Questa\n\n\n\nWith this confirmation that the logic of the modules were working, it was possible to then move on to physical implementation of the program on the actual FPGA and hardware.\n\n\n\n\n\nThe design was developed based on work from Lab 1. The same seven segmenet module was used within a double multiplexer, which used the clock to switch back and forth between powering the two common anodes of the dual display. Using multiplexing, the two values were displayed.\nBecause the final system was multiplexing between two segments, this means that the common anode of a given seven-segment LED must be able to be turned OFF. In the original design for the seven-segment display, the common anode had been plugged in directly to the +3.3V of the development board, and in this way circumvented being powered by the FPGA board (which can not supply more than 0.8 mA at a given time). Attempting to power the seven-segment display directly won’t work (as will be explained in Section 1.3.1) unless you want to short your board. Resultantly, two PNP 2N3906 transistors were used, wherein the FPGA was used only to turn the transistor on and off, allowing the +3.3V coming from the Development board to flow within the circuit (once again, circumventing using the FPGA as a current supply directly).\n\n\nBeforehand, to ensure proper requisites were met for powering the seven segment display that everything was properly set up for the PNP transistor and the resistors in the circuit, some simple mathematial calculations were performed to ensure proper voltage and current was kept throughout the circuit.\nThe transistors we were using were 2N3906 PNP transistors. PNP transistors have three terminals; the base, which controls if the PNP is on or off, the emitter, where electrons come from, and the collector, where the electrons go (Figure 4). For PNP transistors to work, there must be enough of a voltage gap between the base voltage and the emitter voltage that current can flow from one too the other; when this happens, current can also flow from the emitter to the collector, with the assumption that the voltages being used do not break or short out the transistor itself.\n\n\n\n\n\n\nFigure 4: PNP Transistor Diagram\n\n\n\nTo determine these limitations, it was necessary to know three things: the voltage drop across the collector to the emitter (V_CE), the voltage drop across the base to the emitter (V_BE), and finally the maximum current draw that would flow from the collector to the emitter (I_CE).\nAccording to the PNP’s datasheet, on average the V_CE drop is 3.3 V. The value of V_BE is, as with most transistors, assumed to be about 0.7 V. To start out with, the primary goal of this circuit should be to power the FPGA board without shorting it by sending too much current through it via the emitter to base connection on the board. Resultantly, a resistor should be placed between the FPGA’s output GPIO pin and the base of the transistor such that the current is less than the maximum possible current that can be sent into the board. This can be configured according to the datatable for the GPIO pins (Figure 5), where it can be seen that the maximum current that should be sent into or out of the FPGA board is 0.8 mA. The maximum current we will be sending into our board is based on the resistor values that we install for the diodes with the dual segment display. With the assumption that we use the same 220 Ohm resistors we were originally using, the current draw through each of these resistors will be slightly reduced from what was considered in Lab 1.\n\n\n\n\n\n\nFigure 5: GPIO Current Draw Pins for FPGA Board\n\n\n\nFirst and foremost, I intend to power the LED’s using 3.3V, but these volts will first travel across the transistor, which is dependent on the current I_C traveling through the circuit. Assuming that this is relatively negligable (see Figure 15 on the PNP Datasheet, to observe that most of the Voltage removed for current lying under 60 mA is close to 0.1 V), and knowing that per diode line there will be an anticipated voltage drop of 2.1 V, that means that any one resistor will need to remove 3.3 - 2.1 Volts, or 1.2 V, from the circuit. When traveling across a 220 Ohm resistor, this will result in a current of roughly 5.45 mA. Assuming that we’ll be powering seven segments at any one time (the maximum amount possible), this means that the total current draw that can be expected is 38.18 mA. We can then compute the necessary amount of current, I_B, that will need to travel through the base in order to turn this circuit on. Using the gain terms found in the datasheet (Figure 6), it can be seen that for a given current I_C = 40 mA, the gain will be roughly 50 around room temperature.\n\n\n\n\n\n\nFigure 6: Table of the Voltage Drop V_CE and Gain of PNP Transistor\n\n\n\nThis means that the corresponding current I_B for the circuit is 38.18 mA/50 = 0.69 mA. In the case of I_B, there is only one resistor between it and the +3.3V power supply; in addition, the transistor will remove V_BE from the circuit, which means that the resistence of this component must be roughly (3.3V - 0.7V)/(0.69 mA), or 3.745 kOhms. In my final circuit design, I used a 3.3 kOhm resistor as it was the closest one I could find in lab, meaning that the final current draw was likely 0.07 mA, which still falls far under the maximum current that the FPGA board can use.\nTable 3 below shows all the calculated voltages, currents, and resistances used for this circuit.\n\n\n\nTable 3: Calculated Component Values\n\n\n\n\n\n\n\n\n\nComponent/Measurement\nCalculated Value\n\n\n\n\nV_CE (voltage from Emitter to Collector)\n3.3 V\n\n\nV_BE (voltage drop from Base to Emitter)\n0.7 V\n\n\nI_C (anticipated current drawn from the emitter to the collector)\n38.18 mA\n\n\nh_FE (DC gain relative to current I_C)\n55\n\n\nI_B (current necessary to turn on the PNP transistor)\n0.69 mA\n\n\nR_transistor (current-limiting resistor between the FPGA and the emitter)\n3.745 kOhms\n\n\n\n\n\n\n\n\n\nSimilar to the previous Lab, in this lab each individual seven segment display was connected to a common anode (in this case, the output emitter of a PNP transistor). Each of the cathodes was attached via a resistor to the FPGA output pins onboard the E155 Breadboard Adapter. In similar fashion to what was described in Lab 1, setting the board up such that each cathode has a resistor allows for each of the diodes to be equally bright, as they all start at the same voltage drop and resultantly will draw the same current if powered (current being directly correlated with their lumosity).\nThe pin numbers, besides pin D, were kept the same as Lab 1 (it was later realized that the print of Pin 18 looks extremely similar to Pin 10, and that was why the system wasn’t working when Pin 10 was being powered; the system now works where Pin D is assigned to Pin 18). There are only three fundamental differences: two common anodes, two sets of A-G pins, and the presence of transistors within the circuit.\n\n\nThe dual display had two common anodes, which were how control over multiplexing was done. At any one time, there were two “states” assumed to exist within the system; in one state, the display on the right was turned on (S0), and in the other, the display on the left (S1)\n\n\n\nSince only a single module calculating the seven-segmenet display could be used at any one time, the corresponding pins of each cathode were connected to each other (i.e. A1 was connected to A2, B1 to B2, etc.). This meant that if both the common anodes had been lit up at the same time, both displays would show the same value, rather than only one lighting up.\n\n\n\nThe common anodes were controlled via the PNP transistors. In doing so, it was possible to only light up one display at a time, while only performing one calculation of the seven segment display.\nThe final schematic of this system can be seen in Figure 7\n\n\n\n\n\n\nFigure 7: Dual Seven Segment LED Matrix Schematic\n\n\n\n\n\n\n\n\nThere are two DIP switches used in this lab, one that is breadboarded and controls the output of the rightmost display, and one that is soldered onto the E155 board and is used the left-most display. The same logic as the previous labs applies to both DIP switches, where the rightmost pin is used as the lowest-order bit. The on-board DIP switches did not require any additional resistrs, as there is an integrated pull-up resistor as detailed on the “E155 FA Development Board Datasheet”. However, the readboarded switches did not have these pull-up resistors already; after reviewing the 78B04ST DIP switch datasheet, it was found that the switches work at 3.3V, so no voltage adjustment was necessary. However, four additional 220 Ohm resistors were added to the switch board between the switch and ground to create a pull-up resistor, and then four FPGA GPIO pins were connected into the anodes of each DIP switch. The final connections for these connections, as well as the variables to which they were assigned can be found in Figure 8\n\n\n\n\n\n\nFigure 8: 4-Pin DIP Switch Schematic\n\n\n\n\n\nThe final necessity for this lab is a set of five LEDs to display the binary summation of the two switches. For this project, a SSA-LXB10TW-GF-LP was used. Since the LED’s require a 2.1 voltage drop across them, very similar to the LEDs inside the seven segment array, 220 Ohm resistors were used for each LED while they drained to ground. This resulted in the corresponding schematic (Figure 9). Only 5 of the 10 LED-Diode Display were used.\n\n\n\n\n\n\nFigure 9: 10-LED Display Schematic\n\n\n\n\n\n\nThe final circuit is mainly controlled by the FPGA, except for the 3.3V that supplies the current for the seven segment voltage. The final circuit can be seen in Figure 10.\n\n\n\n\n\n\nFigure 10: Overall Schematic\n\n\n\n\n\n\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed.\nIf future development desired, additional phases or multiplexed digits could be added quite easily, especially if scaled by 2, as the multiplexing is controlled by each digit of counter; hypothetically, if an additional two numbers needed to be added, two more switches could be set up on the breadboard in similar fashion, the counter could be assigned based on the state of two bits within counter (for a total of four states, rather than two), and the multiplexing would occur via four PNP transistors that move to four common anodes. Scaling is extremely possible with this design.\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed both visually and with the aid of a test bench. The program is able to multiplex successfully without having the two LEDs bleed over, and all digits are equally lit for each segment, and proper calculations for the PNP transistor can be found above.\nI spent a total of 13.5 hours working on this lab, with roughly four of them spent on the lab writeup if including the planning of the modules and compiling all of the necessary diagrams."
  },
  {
    "objectID": "projects/e-155_website/labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "projects/e-155_website/labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "Lab 2 Writeup",
    "section": "",
    "text": "Hours Spent: 13.5, Mapped with Toggl Track\n\n\nIn this lab, a design was developed to display the output of two 4-pin DIP Switches on a dual seven segmenet LED matrix, such that each four-pin switch was mapped to one display. The sum of these two values was then displayed on a set of five LEDs. The dual seven segment display is lit up using the same function as in Lab 1. Resultantly, it was necessary to multiplex the dual segment such that only one common anode was powered at a time. In addition, due to the current draw required on the display, the +3.3V regulator on the E155 Board was used to power the seven segment display (with the assumption that a computer would be able to supply the required amount of current). In addition, to prevent the current from flowing directly through the FPGA, the common anode was turned on and off using a PNP transistor setup. The LED display needed to be breadboarded, as well, because there are only a total of 4 FPGA-controllable LEDs onboard the development board. A 10-LED display was used to show the sum of each of the bits for this program.\n\n\n\n\n\nFrom the top layer down, it was understood that there would be the blocks displayed in the diagram depicted below.\n\n\n\n\n\n\nFigure 1: Block Diagram of Modules\n\n\n\nWhen encoded, the lab resultantly consisted of the above modules. They are explained in the table (Table 1) below.\n\n\n\nTable 1: Module Functions\n\n\n\n\n\n\n\n\n\nModule Name\nModule Function\n\n\n\n\ntop.sv\nPuts together lab2. Generates a clock that will run the program, and outputs variables to the necessary pins.\n\n\nlab02.sv\nRuns an always_ff block to determine the current state and the next state of the system. Runs combinational logic blocks of dual_seven_segment and led_summation for required seven segment and led logic\n\n\ndual_seven_seg.sv\nCalls on the seven segment block from Lab 1. According to the clock’s counter, half the time will return seven segment for one switch, and half the time will return the seven seg output for the other\n\n\nseven_segment.sv\nUses combinational logic to determine which seven segment cathodes to turn on, and which to turn off.\n\n\nled_summation.sv\nAdds together the collected 4-bits of the two switches and returns their binary equivalent as a 5-bit array\n\n\n\n\n\n\nSome important notes about this layout is that the clock is used to determine a state, S0 or S1, which will determine which display is turned on at any given time. In state S0, the system would rely on one switch (s1); in this case, seven_segment would be called on for that switch only. The system would then turn a corresponding anode on and off using the PNP resister; in this case, since its a PNP resistor, it needed to be turn “off” to turn the system on. In state S1, the output of seven_segment instead relies on the output of switch s2, and will return the opposite output for the anode display. The logic for this can be found in Table 2, the following can be said for each of the states.\n\n\n\nTable 2: State Logic\n\n\n\n\n\nstate\nSwitch Used for Seven Segment Logic\nAnode 1\nAnode 2\n\n\n\n\nS0\ns1\n0 (i.e. Display 1 is on)\n1 (Display 2 is off)\n\n\nS1\ns2\n1\n0\n\n\nX\nan error has occured, s = 0\n1\n1\n\n\n\n\n\n\nOnce these modules were all written, they were compiled, checked for errors, and finally put into Questa for testing.\n\n\n\nTwo test benches were written for this lab. The first one checks to make sure that lab02.sv as a whole can run, and correctly lights up the LEDs as seen fit. Because direct control of the counter can’t be gotten when calling on this upper-level module, the testbench instead only checked that at least one of the outputs of the potential seven segment outputs was correct. The second was used to determine that the proper segment was lit up when the correct switch/state was entered into the dual_seven_seg module. In the case of both, a testvector file was composed and assembled using Python to make sure that all possible options were checked for and confirmed. This Python program can be found in Github, at this_file.py\n\n\nIn order to make sure that all cases were covered, the test vectors were created by running a for-loop to generate a series of switches; each of these switch combinations was used to generate a potential segment output, and finally a summation-vector was made that could be called on to correctly add the sum of both segments to the end. The python file then printed a series of strings of the form\nswitch1_switch2_segment1_segment2_summed led values\nBy running two for loops to cycle through all potential switch values, it can be confirmed that all potential values within the system have been reached. Within the test bench itself, the system uses an or expression to confirm that at least one of the segment outputs is equal to the segment output of the system. It also confirms that the led_summation is working as anticipated.\nUsing this testbench, confirmation of the functionality of the whole of lab02 was completed, as all tests could be run without failure (Figure 2)\n\n\n\n\n\n\nFigure 2: Output of Running lab02_tb.sv in Questa\n\n\n\n\n\n\nIn order to make sure that all cases were covered, the test vectors for this testbench were created by running a for-loop to generate a series of switches, similar to lab02 testbench. However, these nested for-loops were nested in one final for-loop, which acertained which state the system was in; each of these switch combinations was used to generate a potential segment output, and finally a summation-vector was made that could be called on to correctly add the sum of both segments to the end. The python file then printed a series of strings of the form\nswitch1_switch2_state_segment_anode1_anode2\nBy running two for loops to cycle through all potential switch values, it can be confirmed that all potential values within the system have been reached. Within the test bench itself, the system uses an or expression to confirm that at least one of the segment outputs is equal to the segment output of the system. It also confirms that the led_summation is working as anticipated.\nUsing this testbench, confirmation of the functionality of the whole of lab02 was completed, as all tests could be run without failure (Figure 3)\n\n\n\n\n\n\nFigure 3: Output of Running lab02_tb.sv in Questa\n\n\n\nWith this confirmation that the logic of the modules were working, it was possible to then move on to physical implementation of the program on the actual FPGA and hardware.\n\n\n\n\n\nThe design was developed based on work from Lab 1. The same seven segmenet module was used within a double multiplexer, which used the clock to switch back and forth between powering the two common anodes of the dual display. Using multiplexing, the two values were displayed.\nBecause the final system was multiplexing between two segments, this means that the common anode of a given seven-segment LED must be able to be turned OFF. In the original design for the seven-segment display, the common anode had been plugged in directly to the +3.3V of the development board, and in this way circumvented being powered by the FPGA board (which can not supply more than 0.8 mA at a given time). Attempting to power the seven-segment display directly won’t work (as will be explained in Section 1.3.1) unless you want to short your board. Resultantly, two PNP 2N3906 transistors were used, wherein the FPGA was used only to turn the transistor on and off, allowing the +3.3V coming from the Development board to flow within the circuit (once again, circumventing using the FPGA as a current supply directly).\n\n\nBeforehand, to ensure proper requisites were met for powering the seven segment display that everything was properly set up for the PNP transistor and the resistors in the circuit, some simple mathematial calculations were performed to ensure proper voltage and current was kept throughout the circuit.\nThe transistors we were using were 2N3906 PNP transistors. PNP transistors have three terminals; the base, which controls if the PNP is on or off, the emitter, where electrons come from, and the collector, where the electrons go (Figure 4). For PNP transistors to work, there must be enough of a voltage gap between the base voltage and the emitter voltage that current can flow from one too the other; when this happens, current can also flow from the emitter to the collector, with the assumption that the voltages being used do not break or short out the transistor itself.\n\n\n\n\n\n\nFigure 4: PNP Transistor Diagram\n\n\n\nTo determine these limitations, it was necessary to know three things: the voltage drop across the collector to the emitter (V_CE), the voltage drop across the base to the emitter (V_BE), and finally the maximum current draw that would flow from the collector to the emitter (I_CE).\nAccording to the PNP’s datasheet, on average the V_CE drop is 3.3 V. The value of V_BE is, as with most transistors, assumed to be about 0.7 V. To start out with, the primary goal of this circuit should be to power the FPGA board without shorting it by sending too much current through it via the emitter to base connection on the board. Resultantly, a resistor should be placed between the FPGA’s output GPIO pin and the base of the transistor such that the current is less than the maximum possible current that can be sent into the board. This can be configured according to the datatable for the GPIO pins (Figure 5), where it can be seen that the maximum current that should be sent into or out of the FPGA board is 0.8 mA. The maximum current we will be sending into our board is based on the resistor values that we install for the diodes with the dual segment display. With the assumption that we use the same 220 Ohm resistors we were originally using, the current draw through each of these resistors will be slightly reduced from what was considered in Lab 1.\n\n\n\n\n\n\nFigure 5: GPIO Current Draw Pins for FPGA Board\n\n\n\nFirst and foremost, I intend to power the LED’s using 3.3V, but these volts will first travel across the transistor, which is dependent on the current I_C traveling through the circuit. Assuming that this is relatively negligable (see Figure 15 on the PNP Datasheet, to observe that most of the Voltage removed for current lying under 60 mA is close to 0.1 V), and knowing that per diode line there will be an anticipated voltage drop of 2.1 V, that means that any one resistor will need to remove 3.3 - 2.1 Volts, or 1.2 V, from the circuit. When traveling across a 220 Ohm resistor, this will result in a current of roughly 5.45 mA. Assuming that we’ll be powering seven segments at any one time (the maximum amount possible), this means that the total current draw that can be expected is 38.18 mA. We can then compute the necessary amount of current, I_B, that will need to travel through the base in order to turn this circuit on. Using the gain terms found in the datasheet (Figure 6), it can be seen that for a given current I_C = 40 mA, the gain will be roughly 50 around room temperature.\n\n\n\n\n\n\nFigure 6: Table of the Voltage Drop V_CE and Gain of PNP Transistor\n\n\n\nThis means that the corresponding current I_B for the circuit is 38.18 mA/50 = 0.69 mA. In the case of I_B, there is only one resistor between it and the +3.3V power supply; in addition, the transistor will remove V_BE from the circuit, which means that the resistence of this component must be roughly (3.3V - 0.7V)/(0.69 mA), or 3.745 kOhms. In my final circuit design, I used a 3.3 kOhm resistor as it was the closest one I could find in lab, meaning that the final current draw was likely 0.07 mA, which still falls far under the maximum current that the FPGA board can use.\nTable 3 below shows all the calculated voltages, currents, and resistances used for this circuit.\n\n\n\nTable 3: Calculated Component Values\n\n\n\n\n\n\n\n\n\nComponent/Measurement\nCalculated Value\n\n\n\n\nV_CE (voltage from Emitter to Collector)\n3.3 V\n\n\nV_BE (voltage drop from Base to Emitter)\n0.7 V\n\n\nI_C (anticipated current drawn from the emitter to the collector)\n38.18 mA\n\n\nh_FE (DC gain relative to current I_C)\n55\n\n\nI_B (current necessary to turn on the PNP transistor)\n0.69 mA\n\n\nR_transistor (current-limiting resistor between the FPGA and the emitter)\n3.745 kOhms\n\n\n\n\n\n\n\n\n\nSimilar to the previous Lab, in this lab each individual seven segment display was connected to a common anode (in this case, the output emitter of a PNP transistor). Each of the cathodes was attached via a resistor to the FPGA output pins onboard the E155 Breadboard Adapter. In similar fashion to what was described in Lab 1, setting the board up such that each cathode has a resistor allows for each of the diodes to be equally bright, as they all start at the same voltage drop and resultantly will draw the same current if powered (current being directly correlated with their lumosity).\nThe pin numbers, besides pin D, were kept the same as Lab 1 (it was later realized that the print of Pin 18 looks extremely similar to Pin 10, and that was why the system wasn’t working when Pin 10 was being powered; the system now works where Pin D is assigned to Pin 18). There are only three fundamental differences: two common anodes, two sets of A-G pins, and the presence of transistors within the circuit.\n\n\nThe dual display had two common anodes, which were how control over multiplexing was done. At any one time, there were two “states” assumed to exist within the system; in one state, the display on the right was turned on (S0), and in the other, the display on the left (S1)\n\n\n\nSince only a single module calculating the seven-segmenet display could be used at any one time, the corresponding pins of each cathode were connected to each other (i.e. A1 was connected to A2, B1 to B2, etc.). This meant that if both the common anodes had been lit up at the same time, both displays would show the same value, rather than only one lighting up.\n\n\n\nThe common anodes were controlled via the PNP transistors. In doing so, it was possible to only light up one display at a time, while only performing one calculation of the seven segment display.\nThe final schematic of this system can be seen in Figure 7\n\n\n\n\n\n\nFigure 7: Dual Seven Segment LED Matrix Schematic\n\n\n\n\n\n\n\n\nThere are two DIP switches used in this lab, one that is breadboarded and controls the output of the rightmost display, and one that is soldered onto the E155 board and is used the left-most display. The same logic as the previous labs applies to both DIP switches, where the rightmost pin is used as the lowest-order bit. The on-board DIP switches did not require any additional resistrs, as there is an integrated pull-up resistor as detailed on the “E155 FA Development Board Datasheet”. However, the readboarded switches did not have these pull-up resistors already; after reviewing the 78B04ST DIP switch datasheet, it was found that the switches work at 3.3V, so no voltage adjustment was necessary. However, four additional 220 Ohm resistors were added to the switch board between the switch and ground to create a pull-up resistor, and then four FPGA GPIO pins were connected into the anodes of each DIP switch. The final connections for these connections, as well as the variables to which they were assigned can be found in Figure 8\n\n\n\n\n\n\nFigure 8: 4-Pin DIP Switch Schematic\n\n\n\n\n\nThe final necessity for this lab is a set of five LEDs to display the binary summation of the two switches. For this project, a SSA-LXB10TW-GF-LP was used. Since the LED’s require a 2.1 voltage drop across them, very similar to the LEDs inside the seven segment array, 220 Ohm resistors were used for each LED while they drained to ground. This resulted in the corresponding schematic (Figure 9). Only 5 of the 10 LED-Diode Display were used.\n\n\n\n\n\n\nFigure 9: 10-LED Display Schematic\n\n\n\n\n\n\nThe final circuit is mainly controlled by the FPGA, except for the 3.3V that supplies the current for the seven segment voltage. The final circuit can be seen in Figure 10.\n\n\n\n\n\n\nFigure 10: Overall Schematic\n\n\n\n\n\n\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed.\nIf future development desired, additional phases or multiplexed digits could be added quite easily, especially if scaled by 2, as the multiplexing is controlled by each digit of counter; hypothetically, if an additional two numbers needed to be added, two more switches could be set up on the breadboard in similar fashion, the counter could be assigned based on the state of two bits within counter (for a total of four states, rather than two), and the multiplexing would occur via four PNP transistors that move to four common anodes. Scaling is extremely possible with this design.\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed both visually and with the aid of a test bench. The program is able to multiplex successfully without having the two LEDs bleed over, and all digits are equally lit for each segment, and proper calculations for the PNP transistor can be found above.\nI spent a total of 13.5 hours working on this lab, with roughly four of them spent on the lab writeup if including the planning of the modules and compiling all of the necessary diagrams."
  },
  {
    "objectID": "projects/e-155_website/labs/lab7/lab7.html",
    "href": "projects/e-155_website/labs/lab7/lab7.html",
    "title": "Lab 7 Writeup",
    "section": "",
    "text": "Hours Spent: 97.5 hours, Mapped with Toggl Track\n\n\nIn this lab, a STM32L432KCU Microcontroller Unit (the MCU) was used to send and receive SPI signals to the Upduino FPGA board. After troubleshooting on the interconnection between the working FPGA board and the MCU board for fifty-three and a half hours, I finally checked my old version of the code with a new FPGA and found that the problem was my FPGA.\nThis lab requires the user to implement the AES-128 (or the Advanced Encryption Standard) program. The complexity of this lab (should have been) mainly focused on the simulation aspects the encryption standard. As described in the following sections, this encryption standard follows a few definitive steps in order to convert an input string of 128 bits into a newly encoded form - similar to how we communicate with the internet now, with a given key a user can decode and encode a string however they want to prevent unwanted eyes viewing the initial message.\n\n\n\nAES-128 fundamentally encodes a system in such a way that the same key can be used to both encrypt and decrypt a file.\nTo help myself write the functions necessary for this program, I began by drawing out all of the functions for the program so that I knew what to do within Lattice Radiant. There are, fundamentally 5 functions in this program, one of which uses two small “semi-functions”, I will term them. These are listed below:\n\nAddRoundKey(state, w_round[3:0]) - Combines the input “state” with a “word” that then converts all of the states inside the “state” listt into a state_prime variable.\nMixColumns(state) – Recombines a set of columns using a predefined matrix of hexadecimal values.\nSubBytes – Uses a function called “sbox” to substitute every word within a matrix with another word. This matrix is unique and causes a high degree of randomness within the completed function.\nShiftRows – Considering state as a matrix, shifts all the state values over by one two the left (including wrap around) depending on which row the state is.\nKeyExpansion – Defines a new list of words based on a supplied key. For each “round” of the function, new words are created, which are used in other functions to adjust the state.\n\nOverall, these functions all come together as described in the pseudocode found on page 12 of the FIPS manual, and can be seen in the image below Figure 1.\n\n\n\n\n\n\n\n\n\nI drew out each progran, and will go into further detail with each of the following diagram for my Radiant Software program.\n\n\n\nAddRoundKey is a function that is used to generate the list of words that will be used by the program to alter the incoming key; for each “round” that this cypher goes through, the program will generate a list of words that are dependent upon the initial key supplied to the program.\n\nThese values are determined with the aid of KeyExpansion Section 1.2.3.\n\n\n\nMixColumns is a fucntion that uses a XOR gate to combine a mix of rows combined with a pre-assorted list of values specific to the AES fucntion, in this case AES-128. This mixing is one of the special pieces of AES, as it is hard to decipher without the initial list of values (defined in Figure 2)\n\n\n\n\n\n\n\n\n\nFor a better perspective on what is happening, I have additionally put together a diagram below that shows the user how this is implemented.\n.\n\n\n\nKeyExpansion uses XOR and a list of ten pre-defined hexadecimal values to change the incoming list of words and alter them for the use of “AddRoundKey”.\n\nDepending on the round in which the user finds themselves, KeyExpansion will determine the next word using a mix of rotating the words, substituting the words using the SubWord function ( Section 1.2.3.1 ), and XORing values in a specific order.\n\n\nSubBytes is part of the magic of the AES Encryption algorithm, and allows the same value that goes into the matrix, when altered, to be entered again and return its original value. It alters it using something termed “sbox”, where each value is multiplied or combined with some defined list of values. This matrix is extremely large, and as found in the lab, should be implemented using the system’s RAM.\n\n\n\nThe RotWord function is implemented within a multitude of functions to rotate a row of the incoming word (termed as “state” within the pseudocode)\n\n\n\n\nShiftRows rotates the incoming word by a differing amount for each row, and as such completely rotates the entire matrix within the function.\n\n\n\n\nSubBytes uses the synchronized version of SubWord ( Section 1.2.3.1 ) to perform the sbox transformation \n\n\n\n\nThe final design can be represented in the following block diagram. As can be seen in the block diagram, sbox has two potential functions; sbox and sbox_sync. In this case, we need to have a synchronized sbox_sync because there is not enough memory on the FPGA to store the sbox memory before transmitting it. As a result, we need a way to synchronize the sbox in order to prevent its memory from being stored at the same time as other functions so that enough memory is given to the network. This problem with memory mapping can be seen in the image below, where an error message is called due to a Synthesis Error.\nAs can be seen in the diagram below, despite using synchronized sbox values, all of the RAM on the FPGA is still used by the program and overflows such that most of the registers on the board are used.\n\n\n\nThe test bench trials did function properly for both the SPI and the CORE; in order to test both of these, however, a series of smaller test benches needed to be crafted to test each function. These were made using the defined table of AES functions as defined in the PDF.\nFor each function, a set of vectors for the state input and state output were made, and the program was run to confirm that the right value was received. Since there are no such thing as edge cases in many of these functions, I didn’t construct any fringe case scenarios for this problem.\nTesting FSM Testbenches can be seen below, with various zooms on the FSM.\n    \nThese FSM’s can be further demonstrated to be working by viewing these in the SPI Tesbenches.\n  \nOnce all the trials were confirmed to have been working within the testbench, I then moved on to implementing the design onto my actual machine.\n\n\n\nThe following schematic shows how the pin connects on the MCU and FPGA builds look.\n\nI faced considerable problems with the hardware set up for this lab; I believe that this was, in part, due to a problem with my PB4 and PB5, which are shorted together due to soldering issues. With my Lab 6, I was able to avoid this issue using PB12 and PA11, but due to some of the requisites of this lab, and the time constraints on my own part, I was unable to complete this aspect of the project.\nThe majority of the time that was stocked up during this project was the time it took to troubleshoot my software to hardware connection. Compiled, three days worth of hours were spent trying to get the hardware working. Multiple variations of code were tried while troubleshooting:\n\nInitially, there was no “DONE” block in my FSM, and as a result my final program may have started in the wrong state. I fixed this by rewriting my FSM and making sure I included a state for each potential block.\nI was not initially using the right board, and instead had implemented my program with too few memory blocks; as a result, there were only 12 RAM buckets, and none of the sbox values could fit in them. When I upgraded, this issue was solved.\nI initially had 32 rather than 16 sbox modules initialized; this was because I had initialized an SubBytes register both in my fsm machine, to perform an operation before I entered rounds 1-9, and within my “rounds” function. I solved this by including a system of enables in all my functions, which allowed me to toggle what I was receiving out of “rounds”, and resultantly use rounds for every single computation.\n\nIn the end, however, the issue was not my code; I continued running into the same problem, where the SPI was outputting a variety of values, always the same, but varying with time (there were a total of three distinct SPI values that the FPGA was receiving from the MCU). However, when I programmed my code onto another person’s FPGA, my code worked. I confirmed this on two FPGA boards, and confirmed that the software was correct, but something on my hardware was gone.\n\n\n\nI learned a lot of resilience with this project; there were many points where I wanted to give up, but I would continue trying and experimenting. Even though the trial and error felt wasteful, especially close to the end, I believe I understand AES-128 far better than I ever would have if I had gotten it working on my first run through.\nAs can be seen below, all of the data was able to be seen with the use of a logic analyzer; I have put these in the listings at the bottom of this page.\nAdditionally, in the future I would like to examine my FPGA with a Logic Analyzer to troubleshoot what’s wrong with the pins, and what may be shorted together on my board.\n\n\n\nIn conclusion, after many long hours, I can consider this Lab a success. I think that AES encryption and SPI communications will always be difficult to understand, but with this Lab I’ve gotten proof that I can succeed by working hard."
  },
  {
    "objectID": "projects/e-155_website/labs/lab7/lab7.html#lab-7-aes-128",
    "href": "projects/e-155_website/labs/lab7/lab7.html#lab-7-aes-128",
    "title": "Lab 7 Writeup",
    "section": "",
    "text": "Hours Spent: 97.5 hours, Mapped with Toggl Track\n\n\nIn this lab, a STM32L432KCU Microcontroller Unit (the MCU) was used to send and receive SPI signals to the Upduino FPGA board. After troubleshooting on the interconnection between the working FPGA board and the MCU board for fifty-three and a half hours, I finally checked my old version of the code with a new FPGA and found that the problem was my FPGA.\nThis lab requires the user to implement the AES-128 (or the Advanced Encryption Standard) program. The complexity of this lab (should have been) mainly focused on the simulation aspects the encryption standard. As described in the following sections, this encryption standard follows a few definitive steps in order to convert an input string of 128 bits into a newly encoded form - similar to how we communicate with the internet now, with a given key a user can decode and encode a string however they want to prevent unwanted eyes viewing the initial message.\n\n\n\nAES-128 fundamentally encodes a system in such a way that the same key can be used to both encrypt and decrypt a file.\nTo help myself write the functions necessary for this program, I began by drawing out all of the functions for the program so that I knew what to do within Lattice Radiant. There are, fundamentally 5 functions in this program, one of which uses two small “semi-functions”, I will term them. These are listed below:\n\nAddRoundKey(state, w_round[3:0]) - Combines the input “state” with a “word” that then converts all of the states inside the “state” listt into a state_prime variable.\nMixColumns(state) – Recombines a set of columns using a predefined matrix of hexadecimal values.\nSubBytes – Uses a function called “sbox” to substitute every word within a matrix with another word. This matrix is unique and causes a high degree of randomness within the completed function.\nShiftRows – Considering state as a matrix, shifts all the state values over by one two the left (including wrap around) depending on which row the state is.\nKeyExpansion – Defines a new list of words based on a supplied key. For each “round” of the function, new words are created, which are used in other functions to adjust the state.\n\nOverall, these functions all come together as described in the pseudocode found on page 12 of the FIPS manual, and can be seen in the image below Figure 1.\n\n\n\n\n\n\n\n\n\nI drew out each progran, and will go into further detail with each of the following diagram for my Radiant Software program.\n\n\n\nAddRoundKey is a function that is used to generate the list of words that will be used by the program to alter the incoming key; for each “round” that this cypher goes through, the program will generate a list of words that are dependent upon the initial key supplied to the program.\n\nThese values are determined with the aid of KeyExpansion Section 1.2.3.\n\n\n\nMixColumns is a fucntion that uses a XOR gate to combine a mix of rows combined with a pre-assorted list of values specific to the AES fucntion, in this case AES-128. This mixing is one of the special pieces of AES, as it is hard to decipher without the initial list of values (defined in Figure 2)\n\n\n\n\n\n\n\n\n\nFor a better perspective on what is happening, I have additionally put together a diagram below that shows the user how this is implemented.\n.\n\n\n\nKeyExpansion uses XOR and a list of ten pre-defined hexadecimal values to change the incoming list of words and alter them for the use of “AddRoundKey”.\n\nDepending on the round in which the user finds themselves, KeyExpansion will determine the next word using a mix of rotating the words, substituting the words using the SubWord function ( Section 1.2.3.1 ), and XORing values in a specific order.\n\n\nSubBytes is part of the magic of the AES Encryption algorithm, and allows the same value that goes into the matrix, when altered, to be entered again and return its original value. It alters it using something termed “sbox”, where each value is multiplied or combined with some defined list of values. This matrix is extremely large, and as found in the lab, should be implemented using the system’s RAM.\n\n\n\nThe RotWord function is implemented within a multitude of functions to rotate a row of the incoming word (termed as “state” within the pseudocode)\n\n\n\n\nShiftRows rotates the incoming word by a differing amount for each row, and as such completely rotates the entire matrix within the function.\n\n\n\n\nSubBytes uses the synchronized version of SubWord ( Section 1.2.3.1 ) to perform the sbox transformation \n\n\n\n\nThe final design can be represented in the following block diagram. As can be seen in the block diagram, sbox has two potential functions; sbox and sbox_sync. In this case, we need to have a synchronized sbox_sync because there is not enough memory on the FPGA to store the sbox memory before transmitting it. As a result, we need a way to synchronize the sbox in order to prevent its memory from being stored at the same time as other functions so that enough memory is given to the network. This problem with memory mapping can be seen in the image below, where an error message is called due to a Synthesis Error.\nAs can be seen in the diagram below, despite using synchronized sbox values, all of the RAM on the FPGA is still used by the program and overflows such that most of the registers on the board are used.\n\n\n\nThe test bench trials did function properly for both the SPI and the CORE; in order to test both of these, however, a series of smaller test benches needed to be crafted to test each function. These were made using the defined table of AES functions as defined in the PDF.\nFor each function, a set of vectors for the state input and state output were made, and the program was run to confirm that the right value was received. Since there are no such thing as edge cases in many of these functions, I didn’t construct any fringe case scenarios for this problem.\nTesting FSM Testbenches can be seen below, with various zooms on the FSM.\n    \nThese FSM’s can be further demonstrated to be working by viewing these in the SPI Tesbenches.\n  \nOnce all the trials were confirmed to have been working within the testbench, I then moved on to implementing the design onto my actual machine.\n\n\n\nThe following schematic shows how the pin connects on the MCU and FPGA builds look.\n\nI faced considerable problems with the hardware set up for this lab; I believe that this was, in part, due to a problem with my PB4 and PB5, which are shorted together due to soldering issues. With my Lab 6, I was able to avoid this issue using PB12 and PA11, but due to some of the requisites of this lab, and the time constraints on my own part, I was unable to complete this aspect of the project.\nThe majority of the time that was stocked up during this project was the time it took to troubleshoot my software to hardware connection. Compiled, three days worth of hours were spent trying to get the hardware working. Multiple variations of code were tried while troubleshooting:\n\nInitially, there was no “DONE” block in my FSM, and as a result my final program may have started in the wrong state. I fixed this by rewriting my FSM and making sure I included a state for each potential block.\nI was not initially using the right board, and instead had implemented my program with too few memory blocks; as a result, there were only 12 RAM buckets, and none of the sbox values could fit in them. When I upgraded, this issue was solved.\nI initially had 32 rather than 16 sbox modules initialized; this was because I had initialized an SubBytes register both in my fsm machine, to perform an operation before I entered rounds 1-9, and within my “rounds” function. I solved this by including a system of enables in all my functions, which allowed me to toggle what I was receiving out of “rounds”, and resultantly use rounds for every single computation.\n\nIn the end, however, the issue was not my code; I continued running into the same problem, where the SPI was outputting a variety of values, always the same, but varying with time (there were a total of three distinct SPI values that the FPGA was receiving from the MCU). However, when I programmed my code onto another person’s FPGA, my code worked. I confirmed this on two FPGA boards, and confirmed that the software was correct, but something on my hardware was gone.\n\n\n\nI learned a lot of resilience with this project; there were many points where I wanted to give up, but I would continue trying and experimenting. Even though the trial and error felt wasteful, especially close to the end, I believe I understand AES-128 far better than I ever would have if I had gotten it working on my first run through.\nAs can be seen below, all of the data was able to be seen with the use of a logic analyzer; I have put these in the listings at the bottom of this page.\nAdditionally, in the future I would like to examine my FPGA with a Logic Analyzer to troubleshoot what’s wrong with the pins, and what may be shorted together on my board.\n\n\n\nIn conclusion, after many long hours, I can consider this Lab a success. I think that AES encryption and SPI communications will always be difficult to understand, but with this Lab I’ve gotten proof that I can succeed by working hard."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html",
    "href": "projects/e-155_website/labs/lab1/running_labs.html",
    "title": "How to Run FPGA Code",
    "section": "",
    "text": "The first thing that you need to do is write your code. Easy enough; let’s pretend that you’ve done that already.\nI follow Professor Brake’s tutorial for most of this, and it was quite comprehensive. However, if you’d like even more photos, and specifically information on how I personally load onto my FPGA board, read on. The next thing that you need to do is a bit more difficult if you aren’t connected to your board properly, and that’s to Synthesize your code, like the pretty image below.\n\n\n\n\n\nStart by installing Lattice Radiant. It’s straightforward, especially if you are following Professor Brake’s tutorial. I will talk specifically about installing the FTDI driver afterwards, as that was what was more difficult on my end.\nUnfortunately, unless you’ve done it before you’ll probably need to install the FTDI Drivers that Professor Brake mentions. I’ll give you a tip, though, that you shouldn’t just go blindly clicking and installing every zip file that you see – for example, clicking the linke for “setup executable” will give a file that is meant for Windows computers (x86), not for your arm64 chip. Here are the proper steps:\n\nRead through the Installation Guide for your situation. If you are like me, and are running a Windows Driver on your Mac, then use this Installation Guide. If you are even more like me, and you’re on a Mac with an M1 chip, you should carefully read and then ignore all of Sections 3.1 and 3.2 in this guide, and focuse solely on Section 3.3. As the document says, “Note: This is the only method to install the ARM64 or universal versions of the driver.”.\nThe rest of this process is quite straight forward, so long as you follow Section 3.3. The process will mainly be that you will first need to link your device into Parallels so that you can see it from inside the Parallels Device.\n\n\n\n\n\n\n\nYou will then be told that you should be able to open Device Manager within Windows (just use the search bar at the bottom to find it) and immediately see the relevant Ports. If you are like me, you don’t see this and panic. Don’t worry: it’s just hidden from you because it’s currently broken. To rectify this, you need to click View &gt; show hidden devices inside your Device Manager. Miraculously, you will suddenly see the same Ports file that they are talking about in the installation guide.\n\n\n\n\n\n\n\nContinue following their recommended steps. Note that when you install the FTDI driver, you should install it on the Parallels Window Machine and not on your home Mac, as this will cause errors when the program tries finding it (at least, it did for me)."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#first-steps",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#first-steps",
    "title": "How to Run FPGA Code",
    "section": "",
    "text": "The first thing that you need to do is write your code. Easy enough; let’s pretend that you’ve done that already.\nI follow Professor Brake’s tutorial for most of this, and it was quite comprehensive. However, if you’d like even more photos, and specifically information on how I personally load onto my FPGA board, read on. The next thing that you need to do is a bit more difficult if you aren’t connected to your board properly, and that’s to Synthesize your code, like the pretty image below.\n\n\n\n\n\nStart by installing Lattice Radiant. It’s straightforward, especially if you are following Professor Brake’s tutorial. I will talk specifically about installing the FTDI driver afterwards, as that was what was more difficult on my end.\nUnfortunately, unless you’ve done it before you’ll probably need to install the FTDI Drivers that Professor Brake mentions. I’ll give you a tip, though, that you shouldn’t just go blindly clicking and installing every zip file that you see – for example, clicking the linke for “setup executable” will give a file that is meant for Windows computers (x86), not for your arm64 chip. Here are the proper steps:\n\nRead through the Installation Guide for your situation. If you are like me, and are running a Windows Driver on your Mac, then use this Installation Guide. If you are even more like me, and you’re on a Mac with an M1 chip, you should carefully read and then ignore all of Sections 3.1 and 3.2 in this guide, and focuse solely on Section 3.3. As the document says, “Note: This is the only method to install the ARM64 or universal versions of the driver.”.\nThe rest of this process is quite straight forward, so long as you follow Section 3.3. The process will mainly be that you will first need to link your device into Parallels so that you can see it from inside the Parallels Device.\n\n\n\n\n\n\n\nYou will then be told that you should be able to open Device Manager within Windows (just use the search bar at the bottom to find it) and immediately see the relevant Ports. If you are like me, you don’t see this and panic. Don’t worry: it’s just hidden from you because it’s currently broken. To rectify this, you need to click View &gt; show hidden devices inside your Device Manager. Miraculously, you will suddenly see the same Ports file that they are talking about in the installation guide.\n\n\n\n\n\n\n\nContinue following their recommended steps. Note that when you install the FTDI driver, you should install it on the Parallels Window Machine and not on your home Mac, as this will cause errors when the program tries finding it (at least, it did for me)."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#kavis-code",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#kavis-code",
    "title": "How to Run FPGA Code",
    "section": "Kavi’s Code",
    "text": "Kavi’s Code\nThis has been posted with Kavi’s permission\nKavi was tired of needing to hunt down the .bin file every time. Kavi is also really good at writing shell code. Resultantly, Kavi wrote the following code which will find the binary file that you need, so long as you are in the proper folder for it.\nIn order to install this shortcut, first you need to open your .zshrc file. For those of you who are extremely unfamiliar with terminal code, follow the following steps.\n\nIn your terminal, type vim ~/.zshrc. This does two things; vim is a way of opening and editing a current configuration code (or any code file) from within terminal. ~/.zshrc is one of what are called “shell” code files. The ~/ indicates that the path to this file is from your current user’s home file. The “.zshrc” file itself is hidden; if you run ls in your home directory, you’ll note that it doesn’t appear; you can only see it if you list files including hidden ones (ls -a). It is what is run when your computer starts up, and helps point your computer on where to go. It is also where you can write shortcuts for running commands within terminal, which is what we are about to do. Below is an image of what my ~/.zshrc program looks like.\n\n\n\n\n\n\n\nYou’ll note that when you have this file open using vim, you can’t type anything. In order to actually insert things into this file, you need to type the letter i. This will put you into “Insert” mode, indicated by the -- INSERT -- on the bottom of your screen. You can now type in this folder! But be careful; deleting things or entering random things will likely throw errors in your terminal, which are often gross and icky to clean up.\n\n\n\n\n\n\n\nNow that you’re in Insert mode, navigate to the bottom of this file (just press/hold down on the down arrows until you get there). Paste the following code.\n\n#!/bin/bash\nalias program_fpga=\"find . -name '*.bin' -print | xargs openFPGALoader -b ice40_generic -c ft232  -f\"\nWhat this effectively does is locates the bin file (assuming that you’ve only made one – please don’t add more than one bin file or random, weird behavior will happen and the code likely won’t run), and then enters this into the openFPGALoader program. If you’re unfamiliar with terminal, you’ll notice that there’s a line (called a pipe) | in the middle of the code; this indicates that after you’ve found the *.bin file, you push the output into the next code; in this case, its being used as an argument (xargs) in openFPGA viewer.\n\nNow that you’ve inserted it, a problem that I first had when I was learning how to use vim was how to get out of it (vim is one of many ways to edit this programs, by the way: some people prefer using vi, or something else they’ve downloaded off of the interwebs. It’s really up to you how you edit files in terminal – I’m just most familiar with vim). To leave, and especially to save what you just did, use the Esc key. If you’ve decide that you don’t want to save your work, write :q! in the terminal and press Enter. This effectively quits the program without saving. If you DO want to save, instead you need to write :wq, which will save the edits that you’ve made to your ~/.zshrc file. You’ve now saved Kavi’s code, and if you want to run it, all you need to write in your terminal is program_fpga.\n\n\n\n\n\n\n\nDouble Check\n\n\n\nP.S. If you’d like to check that your changes were made inside of the program, you can experiment with that new pipe character you’ve just learned about to make sure that the file is in there. In your terminal, type cat ~/.zshrc | grep program_fpga. What this effectively does is:\n\nUses cat to return all the text inside your ~/.zshrc file\nPipelines this text and selectively sorts it, using grep, for the keyword “program_fpga”, which is the function we’ve just added.\n\nIf all went well, you should see the line alias program_fpga=\"find . -name '*.bin' -print | xargs openFPGALoader -b ice40_generic -c ft232  -f\" returned! If nothing is returned, that means it wasn’t saved properly, and you’ll need to go back and make sure that it’s there and that there are no typos."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#running-fpga-code",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#running-fpga-code",
    "title": "How to Run FPGA Code",
    "section": "Running FPGA Code",
    "text": "Running FPGA Code\nThe first step you need to take to running code off your FPGA board is locating where the folder containing this code is on your computer. Here is an example of how I find mine.\n\nI go to my Finder window, and go into Locations. This is where I can see Parallels’s virtual Windows environment.\n\n\n\n\n\n\n\nI then navigate to wherever I’ve saved my file. Note that it is also possible to save your file on your Mac, and upload it to your FPGA from there. For me, I had difficulties connecting to my FPGA whenever I was on my Mac besides when I was using the terminal, and so I chose to avoid some frustration by storing all my files solely on Parallels.\n\n\n\n\n\n\n\nBy dragging the folder for your lab into terminal, you can enter this path within your terminal in order to run your FGPA, Lattice Radiant code.\n\n\n\n\n\n\n\nNow that you are inside the program, you can run Kavi’s Code. Type program_fpga, and if you are connected to your board correctly (make sure that you have the microUSB plugged into the FPGA and that the lights are turned on), the code that you have Synthesized will automatically upload onto the FPGA, and you’ll see it running in real time. To double check and confirm, your terminal should resemble the image below (potentially without the colors). Note that if you are like me, and using the Parallel’s virtual Windows environment, if you had the Upduino linked to your parallel’s page, you won’t be able to actually load the code onto your board. Make sure to uncheck the Parallel’s connection under the logo, Devices &gt; USB & Bluetooth &gt; ... to make sure that you can actually upload your code to your board."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/running_labs.html#done",
    "href": "projects/e-155_website/labs/lab1/running_labs.html#done",
    "title": "How to Run FPGA Code",
    "section": "Done!",
    "text": "Done!\nAnd that’s it! Congratulations, you’re now able to run code from your FPGA board!"
  },
  {
    "objectID": "projects/radio_frequency/index.html",
    "href": "projects/radio_frequency/index.html",
    "title": "Radio Frequency Circuit: Python Files and writeup",
    "section": "",
    "text": "Setting all Required Values\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnalytical Chart Analysis\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPart 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS11, S21 and S22 for TL-ANT2409A measurements on broadside\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTheory Question 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html",
    "title": "Analytical Chart Analysis",
    "section": "",
    "text": "import math\nimport numpy as np\nimport skrf as rf\n# want to graph frequency vs attenuation\n\nomegas = np.linspace(70e6, 130e6) * np.pi * 2\n\nfreq_cutoff = 100e6\nomega_cutoff = freq_cutoff * 2 * np.pi\npb_allowable_ripple = 1 # 1dB of allowable ripple in the passband\n\nepsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\nn = 3 # order that we're using\n\nB = 1/n * np.arccosh(1/epsilon)\ninv_ratio = (omegas/omega_cutoff) * np.cosh(B) # (w/wc)'\n\ndef C_3 (x):\n    return 4 * np.power(x, 3) - 3 * x\n\nattenuation = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv_ratio), 2))\n\n\nimport matplotlib.pyplot as plt\n\nplt.xscale(\"log\")\nplt.plot(omegas, -attenuation)\n\n\n\n\n\n\n\n\n\n## Uses the math found within the RF Circuitry book to build an analytical model of the LPF Chebyshev filter we're building\ndef buildAtt(start_w, end_w):\n\n    omegas = np.linspace(start_w, end_w, 1000000) * np.pi * 2\n\n    freq_cutoff = 100e6\n    omega_cutoff = freq_cutoff * 2 * np.pi\n    pb_allowable_ripple = 0.5 # 1dB of allowable ripple in the passband\n    \n    epsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\n    print(\"Epsilon \", epsilon)\n    \n    n = 3 # order that we're using\n    \n    B = 1/n * np.arccosh(1/epsilon)\n    inv_ratio = (omegas/omega_cutoff) * np.cosh(B) # (w/wc)'\n\n    attenuation = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv_ratio), 2)  )\n    return (omegas, attenuation)\n\n## Finds the index of the value closest to our desired value within an array\ndef find(arr, val):\n    diff_mat = arr - np.ones(len(arr))*val\n    return np.argmin(np.abs(diff_mat))"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#predefining-the-necessary-functions-to-find-desired-values",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#predefining-the-necessary-functions-to-find-desired-values",
    "title": "Analytical Chart Analysis",
    "section": "",
    "text": "import math\nimport numpy as np\nimport skrf as rf\n# want to graph frequency vs attenuation\n\nomegas = np.linspace(70e6, 130e6) * np.pi * 2\n\nfreq_cutoff = 100e6\nomega_cutoff = freq_cutoff * 2 * np.pi\npb_allowable_ripple = 1 # 1dB of allowable ripple in the passband\n\nepsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\nn = 3 # order that we're using\n\nB = 1/n * np.arccosh(1/epsilon)\ninv_ratio = (omegas/omega_cutoff) * np.cosh(B) # (w/wc)'\n\ndef C_3 (x):\n    return 4 * np.power(x, 3) - 3 * x\n\nattenuation = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv_ratio), 2))\n\n\nimport matplotlib.pyplot as plt\n\nplt.xscale(\"log\")\nplt.plot(omegas, -attenuation)\n\n\n\n\n\n\n\n\n\n## Uses the math found within the RF Circuitry book to build an analytical model of the LPF Chebyshev filter we're building\ndef buildAtt(start_w, end_w):\n\n    omegas = np.linspace(start_w, end_w, 1000000) * np.pi * 2\n\n    freq_cutoff = 100e6\n    omega_cutoff = freq_cutoff * 2 * np.pi\n    pb_allowable_ripple = 0.5 # 1dB of allowable ripple in the passband\n    \n    epsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\n    print(\"Epsilon \", epsilon)\n    \n    n = 3 # order that we're using\n    \n    B = 1/n * np.arccosh(1/epsilon)\n    inv_ratio = (omegas/omega_cutoff) * np.cosh(B) # (w/wc)'\n\n    attenuation = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv_ratio), 2)  )\n    return (omegas, attenuation)\n\n## Finds the index of the value closest to our desired value within an array\ndef find(arr, val):\n    diff_mat = arr - np.ones(len(arr))*val\n    return np.argmin(np.abs(diff_mat))"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#original-frequency-range-set-between-0-to-300-mhz",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#original-frequency-range-set-between-0-to-300-mhz",
    "title": "Analytical Chart Analysis",
    "section": "Original Frequency Range Set Between 0 to 300 MHz",
    "text": "Original Frequency Range Set Between 0 to 300 MHz\n\nfig, axes = plt.subplots(1,1)\naxes.set_xlabel(\"Frequency (Hz)\")\naxes.set_ylabel(\"Attenuation (dB)\")\n\ncurr_start = 0; curr_end = 300e6\n[oms, at] = buildAtt(curr_start, curr_end)\nplt.xscale(\"log\")\nplt.plot(oms, -at, linewidth=2)\n\nzeroes = np.zeros(1000000)\n\nplt.plot(oms, zeroes, linewidth=1)\n\nloc_at_3 = find(-at, -3);\nfreq_at_3 = oms[loc_at_3]/(2*np.pi)\natt_at_3 = -at[loc_at_3]\n\n\nloc_at_20 = find(-at, -20);\nfreq_at_20 = oms[loc_at_20]/(2*np.pi)\natt_at_20 = -at[loc_at_20]\n\nplt.scatter(oms[loc_at_3], -at[loc_at_3], c='red')\nplt.scatter(oms[loc_at_20], -at[loc_at_20], c='red')\n\nprint(\"Passband Edge: \", freq_at_3/1e6, \"MHz\")\nprint(\"Stopband Edge: \", freq_at_20/1e6, \"MHz\")\nprint(\"Insertion Loss: \", at[0])\n\nEpsilon  0.34931140018894796\nPassband Edge:  99.95649995649997 MHz\nStopband Edge:  175.9042759042759 MHz\nInsertion Loss:  0.0"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#zooming-on-70-mhz-to-130-mhz-as-specified-by-prof.-spencer",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#zooming-on-70-mhz-to-130-mhz-as-specified-by-prof.-spencer",
    "title": "Analytical Chart Analysis",
    "section": "Zooming on 70 MHz to 130 MHz, as specified by Prof. Spencer",
    "text": "Zooming on 70 MHz to 130 MHz, as specified by Prof. Spencer\n\ncurr_start = 70e6; curr_end = 130e6\n[oms, at] = buildAtt(curr_start, curr_end)\nplt.xscale(\"log\")\nplt.plot(oms, -at, linewidth=2)\n\nzeroes = np.zeros(1000000)\n\nplt.plot(oms, zeroes, linewidth=1)\n\nEpsilon  0.34931140018894796"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#zooming-in-on-the-parts-of-the-full-frequency-span-that-we-care-about",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#zooming-in-on-the-parts-of-the-full-frequency-span-that-we-care-about",
    "title": "Analytical Chart Analysis",
    "section": "Zooming in on the Parts of the full Frequency Span that we Care About",
    "text": "Zooming in on the Parts of the full Frequency Span that we Care About\n\ncurr_start = 10e6; curr_end = 250e6\n[oms, at] = buildAtt(curr_start, curr_end)\nplt.xscale(\"log\")\nplt.plot(oms, -at, linewidth=2)\n\nzeroes = np.zeros(1000000)\n\nplt.plot(oms, zeroes, linewidth=1)\n\nloc_at_3 = find(-at, -3);\nfreq_at_3 = oms[loc_at_3]/(2*np.pi)\natt_at_3 = -at[loc_at_3]\n\n\nloc_at_20 = find(-at, -20);\nfreq_at_20 = oms[loc_at_20]/(2*np.pi)\natt_at_20 = -at[loc_at_20]\n\nplt.scatter(oms[loc_at_3], -at[loc_at_3], c='red')\nplt.scatter(oms[loc_at_20], -at[loc_at_20], c='red')\n\nprint(\"Passband Edge: \", freq_at_3/1e6, \"MHz\")\n\nprint(\"Stopband Edge: \", freq_at_20/1e6, \"MHz\")\n\nprint(\"Insertion Loss: \", at[0])\n\nEpsilon  0.34931140018894796\nPassband Edge:  99.95640995640994 MHz\nStopband Edge:  175.90424590424593 MHz\nInsertion Loss:  0.062217124664675015"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#a-closer-look-at-passband-ripple",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#a-closer-look-at-passband-ripple",
    "title": "Analytical Chart Analysis",
    "section": "A Closer Look at Passband Ripple",
    "text": "A Closer Look at Passband Ripple\n\nidx = int(1000000/8*2.5)\nplt.plot(oms[0:idx], -at[0:idx])\n\nprint(np.max(-at[0:idx]) - np.min(-at[0:idx]), \"dB of Ripple\")\n\n0.4999999999919422 dB of Ripple"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#so-we-messed-up",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#so-we-messed-up",
    "title": "Analytical Chart Analysis",
    "section": "So we messed up…",
    "text": "So we messed up…\nI create a file that runs a series of curves of different orders, which will hopefully help us find the actual Chebyshev filter\n\ndef C_1(x):\n    return x\n\ndef C_2(x):\n    cheb_2 = 2 * np.pow(x, 2) - 1\n    return cheb_2\n\ndef C_3 (x):\n    return 4 * np.power(x, 3) - 3 * x\n\ndef C_4(x):\n    cheb_4 = 8 * np.pow(x, 4) - 8 * np.pow(x, 2) + 1\n    return cheb_4\n\ndef C_5(x):\n    cheb_5 = 16 * np.pow(x, 5) - 20 * np.pow(x, 3) + 5 * x\n    return cheb_5\n    \ndef C_6(x):\n    cheb_6 = 32 * np.pow(x, 6) - 48 * np.pow(x, 4) + 18 * np.pow(x, 2) - 1\n    return cheb_6\n\ndef C_7(x):\n    cheb_7 = 64 * np.pow(x, 7) - 112 * np.pow(x, 5) + 56 * np.pow(x, 3) - 7 * x\n    return cheb_7\n\nfreq_ratios = np.linspace(0.5, 10, 10000)\npb_allowable_ripple = 0.5\nepsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\nn = 3 # order that we're using\n\nB = 1/n * np.arccosh(1/epsilon)\ninv__freq_ratios = freq_ratios * np.cosh(B) # (w/wc)'\n\natt1 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_1(inv__freq_ratios), 2))\natt2 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_2(inv__freq_ratios), 2))\natt3 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv__freq_ratios), 2))\natt4 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_4(inv__freq_ratios), 2))\natt5 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_5(inv__freq_ratios), 2))\natt6 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_6(inv__freq_ratios), 2))\natt7 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_7(inv__freq_ratios), 2))\n\nfig, axes = plt.subplots(1,1)\naxes.set_title(\"Seven Orders of Chebyshev\")\naxes.set_xlabel(\"Frequency Ratio\")\naxes.set_ylabel(\"Attenuation\")\nplt.xscale(\"log\")\nend = -1\nplt.plot(freq_ratios[:end], -att1[:end], linewidth=1, label=\"Chebyshev 1\")\nplt.plot(freq_ratios[:end], -att2[:end], linewidth=1, label=\"Chebyshev 2\")\nplt.plot(freq_ratios[:end], -att3[:end], linewidth=1, label=\"Chebyshev 3\")\nplt.plot(freq_ratios[:end], -att4[:end], linewidth=1, label=\"Chebyshev 4\")\nplt.plot(freq_ratios[:end], -att5[:end], linewidth=1, label=\"Chebyshev 5\")\nplt.plot(freq_ratios[:end], -att6[:end], linewidth=1, label=\"Chebyshev 6\")\nplt.plot(freq_ratios[:end], -att7[:end], linewidth=1, label=\"Chebyshev 7\")\nplt.legend()\n\n\n\n\n\n\n\n\n\npb_allowable_ripple = 0.5\nepsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\nn = 3 # order that we're using\nB = 1/n * np.arccosh(1/epsilon)\n\nfreq_ratios = np.linspace(0.5, 10, 10000)\ninv__freq_ratios = freq_ratios * np.cosh(B) # (w/wc)'\n\n\nfig, axes = plt.subplots(1,1)\n\natt3 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv__freq_ratios), 2))\natt4 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_4(inv__freq_ratios), 2))\natt5 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_5(inv__freq_ratios), 2))\nplt.xscale(\"log\")\nplt.axis([None, None, -1.2, 0])\naxes.set_xlabel(\"Frequency Ratio\")\naxes.set_ylabel(\"Attenuation\")\nstart=int(10000/50); end = int(10000/50 * 3)\nplt.plot(freq_ratios[start:end], -att3[start:end], linewidth=2, label=\"Chebyshev 3\")\nplt.plot(freq_ratios[start:end], -att4[start:end], linewidth=2, label=\"Chebyshev 4\")\nplt.plot(freq_ratios[start:end], -att5[start:end], linewidth=2, label=\"Chebyshev 5\")\nplt.legend()\n\ncheb_3_pB = find(-att3, -1)\ncheb_4_pB = find(-att4, -1)\ncheb_5_pB = find(-att5, -1)\n\nprint(\"cutoff omega = \", 100e6/(freq_ratios[cheb_3_pB]), \"MHz\")\nprint(\"cutoff omega = \", 100e6/(freq_ratios[cheb_4_pB]), \"MHz\")\nprint(\"cutoff omega = \", 100e6/(freq_ratios[cheb_5_pB]), \"MHz\")\n\ncutoff omega =  111465358.6756591 MHz\ncutoff omega =  113754266.21160409 MHz\ncutoff omega =  114746385.12738124 MHz\n\n\n\n\n\n\n\n\n\n\n## find attenuation at the stop band, or 200/cutoff omega\n\ncutoff_omega3 = 100e6/(freq_ratios[cheb_3_pB])\ncutoff_omega4 = 100e6/(freq_ratios[cheb_4_pB])\ncutoff_omega5 = 100e6/(freq_ratios[cheb_5_pB])\n\nomegas_new = np.linspace(10e6, 250e6, 100000)\n\nfixed_att3 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(omegas_new/cutoff_omega3), 2))\nfixed_att4 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_4(omegas_new/cutoff_omega4), 2))\nfixed_att5 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_5(omegas_new/cutoff_omega5), 2))\n\nplt.plot(omegas_new, -fixed_att3, linewidth=2, label=\"Chebyshev 3\")\nplt.plot(omegas_new, -fixed_att4, linewidth=2, label=\"Chebyshev 4\")\nplt.plot(omegas_new, -fixed_att5, linewidth=2, label=\"Chebyshev 5\")\n\nplt.legend()\n\n\n\n\n\n\n\n\n\npb_allowable_ripple = 0.5\nepsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\nn = 3 # order that we're using\nB = 1/n * np.arccosh(1/epsilon)\n\ninv_C3_20 = 200e6/cutoff_omega3 * np.cosh(B) # (w/wc)'\ninv_C4_20 = 200e6/cutoff_omega4 * np.cosh(B) # (w/wc)'\ninv_C5_20 = 200e6/cutoff_omega5 * np.cosh(B) # (w/wc)'\n\ncalc3 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv_C3_20), 2))\ncalc4 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_4(inv_C4_20), 2))\ncalc5 = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_5(inv_C5_20), 2))\n\nprint(calc3)\nprint(calc4)\nprint(calc5)\n\n20.584063176323383\n31.640562302002564\n42.90364221898756\n\n\n\nA different check, as well, to really make sure everything’s ok\n\nvals_cutoff = np.linspace(100e6, 120e6, 20)\nvarying_freq_for_cutoff = [np.ones(100000) * vals_cutoff[i] for i in range(len(vals_cutoff))]\nomegas = np.linspace(10e6, 250e6, 100000)\n\nfig, axes = plt.subplots(1,1)\n\nfreq_ratio_variedcutoff = omegas/varying_freq_for_cutoff\ninv_varying_freq_ratios = freq_ratio_variedcutoff * np.cosh(B) # (w/wc)'\n\natt3_cutoffs_varied = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv_varying_freq_ratios), 2))\ni = 0\nplt.xscale(\"log\")\naxes.set_xlabel(\"Frequency (Hz)\")\naxes.set_ylabel(\"Attenuation (dB)\")\nfor arr in att3_cutoffs_varied:\n    plt.plot(omegas, -arr)\n    loc_1dB = find(-arr, -1)\n    print(\"Cutoff Band: \", vals_cutoff[i]/1e6, \", Passband value \", omegas[loc_1dB]/1e6, \"MHz\")\n    i = i+1\n\nCutoff Band:  100.0 , Passband value  89.7359973599736 MHz\nCutoff Band:  101.05263157894737 , Passband value  90.68160681606815 MHz\nCutoff Band:  102.10526315789473 , Passband value  91.62721627216273 MHz\nCutoff Band:  103.15789473684211 , Passband value  92.57042570425705 MHz\nCutoff Band:  104.21052631578948 , Passband value  93.5160351603516 MHz\nCutoff Band:  105.26315789473684 , Passband value  94.45924459244593 MHz\nCutoff Band:  106.3157894736842 , Passband value  95.40485404854049 MHz\nCutoff Band:  107.36842105263158 , Passband value  96.35046350463504 MHz\nCutoff Band:  108.42105263157895 , Passband value  97.29367293672937 MHz\nCutoff Band:  109.47368421052632 , Passband value  98.23928239282392 MHz\nCutoff Band:  110.52631578947368 , Passband value  99.18249182491824 MHz\nCutoff Band:  111.57894736842105 , Passband value  100.1281012810128 MHz\nCutoff Band:  112.63157894736841 , Passband value  101.07131071310712 MHz\nCutoff Band:  113.6842105263158 , Passband value  102.01692016920168 MHz\nCutoff Band:  114.73684210526316 , Passband value  102.96252962529626 MHz\nCutoff Band:  115.78947368421052 , Passband value  103.90573905739058 MHz\nCutoff Band:  116.84210526315789 , Passband value  104.85134851348514 MHz\nCutoff Band:  117.89473684210527 , Passband value  105.79455794557946 MHz\nCutoff Band:  118.94736842105263 , Passband value  106.74016740167401 MHz\nCutoff Band:  120.0 , Passband value  107.68577685776857 MHz\n\n\n\n\n\n\n\n\n\n\nfreq, atten = buildAtt(50e6, 130e6)\n\nanalyticalRF = rf.Network(frequency = freq, s = atten)\n\nEpsilon  0.34931140018894796"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#defining-function-that-will-help-graph-magnitude-plots",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#defining-function-that-will-help-graph-magnitude-plots",
    "title": "Analytical Chart Analysis",
    "section": "Defining Function that will Help Graph Magnitude Plots",
    "text": "Defining Function that will Help Graph Magnitude Plots\n\ndef plotPhaseAndDb(network, plotPts, axes, c, title):\n    axes[0].set_title(f\"Magnitude of {title}\")\n    axes[1].set_title(f\"Phase of {title}\")\n    \n    network.plot_s_db(ax=axes[0], color=c[0], linewidth=4)\n\n    if(plotPts):\n        my_arr = network.s_db[:,0,0]\n        my_frq = network.f\n        \n        loc_at_3 = find(my_arr, -3)\n        freq_at_3 = my_frq[loc_at_3]/(2*np.pi)\n        att_at_3 = my_arr[loc_at_3]\n        \n        loc_at_20 = find(my_arr, -20)\n        freq_at_20 = my_frq[loc_at_20]/(2*np.pi)\n        att_at_20 = my_arr[loc_at_20]\n        \n        axes[0].scatter(my_frq[loc_at_3], my_arr[loc_at_3], c='blue')\n        axes[0].annotate(f\"   Passband Freq: ({my_frq[loc_at_3]/1e6:0.2f} MHz, {my_arr[loc_at_3]:0.2f} dB)\", (my_frq[loc_at_3], my_arr[loc_at_3]) )\n        axes[0].scatter(my_frq[loc_at_20], my_arr[loc_at_20], c='pink')\n        axes[0].annotate(f\"   Stopband Freq: ({my_frq[loc_at_20]/1e6:0.2f} MHz, {my_arr[loc_at_20]:0.2f} dB)\", (my_frq[loc_at_20], my_arr[loc_at_20]) )\n\n    network.plot_s_deg(ax=axes[1], color=c[1], linewidth=4)"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#graphing-the-s11-and-s21s-magnitude-plot-70-mhz-to-130-mhz",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#graphing-the-s11-and-s21s-magnitude-plot-70-mhz-to-130-mhz",
    "title": "Analytical Chart Analysis",
    "section": "Graphing the S11 and S21’s Magnitude Plot: 70 MHz to 130 MHz",
    "text": "Graphing the S11 and S21’s Magnitude Plot: 70 MHz to 130 MHz\n\nfilename = \"dp1_70_to_130.txt\"\n\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\nfig, axes = plt.subplots(1,4, figsize=[20,30])\n\ns11 = rf.Network(frequency = f_arr, s = svals_arr[:,0,0])\ns12 = rf.Network(frequency = f_arr, s = svals_arr[:,0,1])\ns21 = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])\ns22 = rf.Network(frequency = f_arr, s = svals_arr[:,1,1])\ns11.plot_s_smith(ax=axes[0], draw_labels=True, color='b', linewidth=2)\ns12.plot_s_smith(ax=axes[1], draw_labels=True, color='g', linewidth=2)\ns21.plot_s_smith(ax=axes[2], draw_labels=True, color='r', linewidth=2)\ns22.plot_s_smith(ax=axes[3], draw_labels=True, color='b', linewidth=2)\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(4,2, figsize=[20,20])\nmag_color = 'b'; deg_color = 'r'\n\nplotPhaseAndDb(s11, False, axes[0:2, 0], [mag_color, deg_color], \"S11\")\nplotPhaseAndDb(s12, False, axes[0:2, 1], [mag_color, deg_color], \"S12\")\nplotPhaseAndDb(s21, True, axes[2:4, 0], [mag_color, deg_color], \"S21\")\nplotPhaseAndDb(s22, False, axes[2:4, 1], [mag_color, deg_color], \"S22\")\n\n\n\n\n\n\n\n\n\nfilename = \"dsp1_50to130.txt\"\n\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\ns21_Ideal = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#graphing-the-s11-and-s21s-magnitude-plot-0hz---300-mhz",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#graphing-the-s11-and-s21s-magnitude-plot-0hz---300-mhz",
    "title": "Analytical Chart Analysis",
    "section": "Graphing the S11 and S21’s Magnitude Plot: 0Hz - 300 MHz",
    "text": "Graphing the S11 and S21’s Magnitude Plot: 0Hz - 300 MHz\n\nfilename = \"dp1_1_to_300M.txt\"\n\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\nfig, axes = plt.subplots(1,4, figsize=[20,30])\n\ns11 = rf.Network(frequency = f_arr, s = svals_arr[:,0,0])\ns12 = rf.Network(frequency = f_arr, s = svals_arr[:,0,1])\ns21 = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])\ns22 = rf.Network(frequency = f_arr, s = svals_arr[:,1,1])\ns11.plot_s_smith(ax=axes[0], draw_labels=True, color='b', linewidth=2)\ns12.plot_s_smith(ax=axes[1], draw_labels=True, color='g', linewidth=2)\ns21.plot_s_smith(ax=axes[2], draw_labels=True, color='r', linewidth=2)\ns22.plot_s_smith(ax=axes[3], draw_labels=True, color='b', linewidth=2)\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(4,2, figsize=[20,20])\nmag_color = 'b'; deg_color = 'r'\n\nplotPhaseAndDb(s11, False, axes[0:2, 0], [mag_color, deg_color], \"S11\")\nplotPhaseAndDb(s12, False, axes[0:2, 1], [mag_color, deg_color], \"S12\")\nplotPhaseAndDb(s21, True, axes[2:4, 0], [mag_color, deg_color], \"S21\")\nplotPhaseAndDb(s22, False, axes[2:4, 1], [mag_color, deg_color], \"S22\")\n\n\n\n\n\n\n\n\n\n## plotting the magnitude and phase data desired\n\nstart_val = s21.s_db[0]\n\nmy_arr = s21.s_db[:,0,0]\nmy_frq = s21.f\n\nloc_at_3 = find(my_arr, -3)\nfreq_at_3 = my_frq[loc_at_3]/(2*np.pi)\natt_at_3 = my_arr[loc_at_3]\n\nloc_at_20 = find(my_arr, -20)\nfreq_at_20 = my_frq[loc_at_20]/(2*np.pi)\natt_at_20 = my_arr[loc_at_20]\n\nfig2, ax2 = plt.subplots(2,1, figsize=[20,10])\n\ns11.plot_s_db(ax=ax2[0], color='g', linewidth=4)\ns21.plot_s_db(ax=ax2[1], color='r', linewidth=1)\n\nsval = (np.ones(len(s21.s_db)) * start_val).T\nax2[1].plot(s21.f, sval, linewidth=2)\n\nax2[1].scatter(my_frq[loc_at_3], my_arr[loc_at_3], c='blue')\nax2[1].annotate(f\"   Passband Freq: ({my_frq[loc_at_3]/1e6:0.2f} MHz, {my_arr[loc_at_3]:0.2f} dB)\", (my_frq[loc_at_3], my_arr[loc_at_3]) )\n\nax2[1].scatter(my_frq[loc_at_20], my_arr[loc_at_20], c='pink')\nax2[1].annotate(f\"   Stopband Freq: ({my_frq[loc_at_20]/1e6:0.2f} MHz, {my_arr[loc_at_20]:0.2f} dB)\", (my_frq[loc_at_20], my_arr[loc_at_20]) )\n\nprint(\"Insertion Loss: \", start_val[0][0])\n\nInsertion Loss:  -8.68584255884301e-05\n\n\n\n\n\n\n\n\n\n\nFinding the Passband of the System\n\ndb_orig = s21.s_db[:,0,0]\nwindow_db = db_orig[0:int(len(s21.s_db)*0.28)]\nplt.plot(window_db)\n\nprint(np.max(window_db) - np.min(window_db))\n\n0.4909297625102878"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#plotting-using-the-real-components",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#plotting-using-the-real-components",
    "title": "Analytical Chart Analysis",
    "section": "Plotting using the Real Components",
    "text": "Plotting using the Real Components\nThe ESR Of The Capacitors: https://www.mouser.com/datasheet/2/447/UPY_High_Q_NP0_16V_to_250V_16-3003035.pdf * “Measuring frequency: 500 ± 50MHz at room temperature. 10pF &lt; C ≤ 100pF :400mΩ max” * Q = 400 + 20*C\nhttps://www.johansontechnology.com/tech-notes/q-esr-explained/ -&gt; ESR = |X_C| / Q 47 pF – 10 pF –\nInternal Resistance of the Inductors: https://microchip.ua/shareway/SDCL1608C.pdf\nAt 100 MHz, Quality Factors: * 1.8 nH +/- 0.3, Q = 11 –&gt; R = 0.1028157596 * 100 nH, Q = 10 –&gt; R = 6.283185307\n\nprint(1/(2*np.pi*100e6*(400+20*20)))\n\n1.989436788648692e-12\n\n\n\nfilename=\"dp1_real_1to300MHz.txt\"\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\nfig, axes = plt.subplots(1,4, figsize=[20,30])\n\ns11 = rf.Network(frequency = f_arr, s = svals_arr[:,0,0])\ns12 = rf.Network(frequency = f_arr, s = svals_arr[:,0,1])\ns21 = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])\ns22 = rf.Network(frequency = f_arr, s = svals_arr[:,1,1])\ns11.plot_s_smith(ax=axes[0], draw_labels=True, color='b', linewidth=2)\ns12.plot_s_smith(ax=axes[1], draw_labels=True, color='g', linewidth=2)\ns21.plot_s_smith(ax=axes[2], draw_labels=True, color='r', linewidth=2)\ns22.plot_s_smith(ax=axes[3], draw_labels=True, color='b', linewidth=2)\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(1,1, figsize=[5,5])\ns11.plot_s_smith(m=0, n=0, ax=axes, draw_labels=True, color='r', linewidth=5)\n\nmarker_idx = [30, 60, 90]\n\nstart_val = real_data_22.s_db[0]\nsval = (np.ones(len(real_data_22.s_db)) * start_val).T\n\nmy_arr = s11.s_db[:,0,0]\nmy_frq = s11.f\n\nloc_at_3 = find(my_arr, -3)\nfreq_at_3 = my_frq[loc_at_3]/(2*np.pi)\natt_at_3 = my_arr[loc_at_3]\n\nloc_at_20 = find(my_arr, -20)\nfreq_at_20 = my_frq[loc_at_20]/(2*np.pi)\natt_at_20 = my_arr[loc_at_20]\n\nloc_100MHz = find(my_frq, 100e6)\nloc_70MHz = find(my_frq, 70e6)\nloc_300MHz = find(my_frq, 300e6)\nmarker_idx = [loc_70MHz, loc_100MHz, loc_300MHz]\n\nfor i, k in enumerate(marker_idx):\n    x = s11.s.real[k, 0, 0]\n    y = s11.s.imag[k, 0, 0]\n    f = s11.frequency.f_scaled[k]\n    axes.scatter(x, y, marker = 'v', s=200, color='b')\n    axes.annotate(f\"{my_frq[k]/1e6:.2f} MHz\", (x, y), xytext=(10, 0), textcoords='offset points', color='b')\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(4,2, figsize=[20,20])\nmag_color = 'b'; deg_color = 'r'\n\nplotPhaseAndDb(s11, False, axes[0:2, 0], [mag_color, deg_color], \"S11\")\nplotPhaseAndDb(s12, False, axes[0:2, 1], [mag_color, deg_color], \"S12\")\nplotPhaseAndDb(s21, True, axes[2:4, 0], [mag_color, deg_color], \"S21\")\nplotPhaseAndDb(s22, False, axes[2:4, 1], [mag_color, deg_color], \"S22\")\n\n\n\n\n\n\n\n\n\ndb_orig = s21.s_db[:,0,0]\nwindow_db = db_orig[int(len(s21.s_db)*0.17):int(len(s21.s_db)*0.22)]\nplt.plot(window_db)\n\nprint(np.max(window_db) - np.min(window_db))\nprint(db_orig[0])\n\n0.1348599021332898\n-0.23157802101447628\n\n\n\n\n\n\n\n\n\n\nfilename=\"dp1_real_30Mto130MHz.txt\"\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\ns21_RealSim = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#graphing-in-lab-data",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#graphing-in-lab-data",
    "title": "Analytical Chart Analysis",
    "section": "Graphing In Lab Data",
    "text": "Graphing In Lab Data\n\nimport pandas as pd\n\nfig, axes = plt.subplots(1,2, figsize=[20,30])\n\ncsv5 = pd.read_csv('CSV5.csv', skiprows=13)\ncsv5.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv5['Z_n'] = csv5['Z_Real']/50 + 1j*csv5['Z_Imag']/50\ncsv5['S_11'] = ( csv5['Z_n']-1 ) / ( csv5['Z_n']+1 )\nreal_data_11 = rf.Network(frequency = csv5['Frequency'], s = csv5['S_11'])\nreal_data_11.plot_s_smith(ax=axes[0], draw_labels=True, color='g', linewidth=4)\n\ncsv6 = pd.read_csv('CSV6.csv', skiprows=13)\ncsv6.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv6['Z_n'] = csv6['Z_Real']/50 + 1j*csv6['Z_Imag']/50\ncsv6['S_21'] = ( csv6['Z_n']-1 ) / ( csv6['Z_n']+1 )\nreal_data_22 = rf.Network(frequency = csv6['Frequency'], s = csv6['S_21'])\nreal_data_22.plot_s_smith(ax=axes[1], draw_labels=True, color='r', linewidth=4)\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(2,1, figsize=[10,6])\n\nfig.title = (\"Lost it\")\n\nreal_data_11.plot_s_db(ax=axes[0], color='g', linewidth=4)\nreal_data_22.plot_s_db(ax=axes[1], color='r', linewidth=4)\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(1,2, figsize=[20,30])\n\ncsv7 = pd.read_csv('CSV7.csv', skiprows=13)\ncsv7.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv7['Z_n'] = csv7['Z_Real']/50 + 1j*csv7['Z_Imag']/50\ncsv7['S_11'] = ( csv7['Z_n']-1 ) / ( csv7['Z_n']+1 )\nreal_data_11 = rf.Network(frequency = csv7['Frequency'], s = csv7['S_11'])\nreal_data_11.plot_s_smith(ax=axes[0], draw_labels=True, color='g', linewidth=4)\n\ncsv8 = pd.read_csv('CSV8.csv', skiprows=13)\ncsv8.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv8['Z_n'] = csv8['Z_Real']/50 + 1j*csv8['Z_Imag']/50\ncsv8['S_21'] = ( csv8['Z_n']-1 ) / ( csv8['Z_n']+1 )\nreal_data_22 = rf.Network(frequency = csv8['Frequency'], s = csv8['S_21'])\nreal_data_22.plot_s_smith(ax=axes[1], draw_labels=True, color='r', linewidth=4)\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(2,1, figsize=[10,6])\n\nreal_data_11.plot_s_db(ax=axes[0], color='g', linewidth=4)\nreal_data_22.plot_s_db(ax=axes[1], color='r', linewidth=4)\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(1,2, figsize=[20,30])\n\ncsv9 = pd.read_csv('CSV9.csv', skiprows=13)\nprint(csv9)\ncsv9.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv9['Z_n'] = csv9['Z_Real']/50 + 1j*csv9['Z_Imag']/50\ncsv9['S_11'] = ( csv9['Z_n']-1 ) / ( csv9['Z_n']+1 )\nreal_data_11 = rf.Network(frequency = csv9['Frequency'], s = csv9['S_11'])\nreal_data_11.plot_s_smith(ax=axes[0], draw_labels=True, color='g', linewidth=4)\n\n########################\ncsv10 = pd.read_csv('CSV10.csv', skiprows=13)\ncsv10.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv10['Z_n'] = csv10['Z_Real']/50 + 1j*csv10['Z_Imag']/50\ncsv10['S_21'] = ( csv10['Z_n']-1 ) / ( csv10['Z_n']+1 )\nreal_data_22 = rf.Network(frequency = csv10['Frequency'], s = csv10['S_21'], m=0, n=0)\nreal_data_22.plot_s_smith(m=0, n=0, ax=axes[1], draw_labels=True, color='r', linewidth=4)\n\nmarker_idx = [30, 60, 90]\n\nstart_val = real_data_22.s_db[0]\nsval = (np.ones(len(real_data_22.s_db)) * start_val).T\nplt.plot(real_data_22.f, sval, linewidth=2)\n\n\nmy_arr = real_data_22.s_db[:,0,0]\nmy_frq = real_data_22.f\n\nloc_at_3 = find(my_arr, -3)\nfreq_at_3 = my_frq[loc_at_3]/(2*np.pi)\natt_at_3 = my_arr[loc_at_3]\n\nloc_at_20 = find(my_arr, -20)\nfreq_at_20 = my_frq[loc_at_20]/(2*np.pi)\natt_at_20 = my_arr[loc_at_20]\n\nloc_100MHz = find(my_frq, 100e6)\nloc_70MHz = find(my_frq, 70e6)\nloc_300MHz = find(my_frq, 300e6)\nmarker_idx = [loc_70MHz, loc_100MHz, loc_300MHz]\n\nfor i, k in enumerate(marker_idx):\n    x = real_data_22.s.real[k, 0, 0]\n    y = real_data_22.s.imag[k, 0, 0]\n    f = real_data_22.frequency.f_scaled[k]\n    axes[1].scatter(x, y, marker = 'v', s=200, color='b')\n    axes[1].annotate(f\"{my_frq[k]/1e6:.2f} MHz\", (x, y), xytext=(10, 0), textcoords='offset points', color='b')\n\n    x = real_data_11.s.real[k, 0, 0]\n    y = real_data_11.s.imag[k, 0, 0]\n    f = real_data_11.frequency.f_scaled[k]\n    axes[0].scatter(x, y, marker = 'v', s=200, color='b')\n    axes[0].annotate(f\"{my_frq[k]/1e6:.2f} MHz\", (x, y), xytext=(10, 0), textcoords='offset points', color='b')\n\n     1.000000e+05  4.162457e+01  3.279533e+00  5.219538e-06  H\n0        499866.7     45.253340      1.915612  6.099210e-07  H\n1        899733.3     45.638650      1.572002  2.780735e-07  H\n2       1299600.0     45.590860      1.319891  1.616398e-07  H\n3       1699467.0     45.491010      1.028820  9.634890e-08  H\n4       2099333.0     45.166610      0.862867  6.541578e-08  H\n..            ...           ...           ...           ... ..\n745   298400500.0      1.832955    -41.253800  1.292875e-11  F\n746   298800400.0      1.776957    -40.154270  1.326500e-11  F\n747   299200300.0      1.739530    -39.069840  1.361496e-11  F\n748   299600100.0      1.710317    -38.028480  1.396913e-11  F\n749   300000000.0      1.673458    -36.995080  1.434019e-11  F\n\n[750 rows x 5 columns]\n\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(2,1, figsize=[10,6])\n\nreal_data_11.plot_s_db(ax=axes[0], color='g', linewidth=4)\nreal_data_22.plot_s_db(ax=axes[1], color='r', linewidth=1)\n\nplt.scatter(my_frq[loc_at_3], my_arr[loc_at_3], c='blue')\nplt.annotate(f\"   Passband Freq: ({my_frq[loc_at_3]/1e6:0.2f} MHz, {my_arr[loc_at_3]:0.2f} dB)\", (my_frq[loc_at_3], my_arr[loc_at_3]) )\n\nplt.scatter(my_frq[loc_at_20], my_arr[loc_at_20], c='pink')\nplt.annotate(f\"   Stopband Freq: ({my_frq[loc_at_20]/1e6:0.2f} MHz, {my_arr[loc_at_20]:0.2f} dB)\", (my_frq[loc_at_20], my_arr[loc_at_20]) )\n\nprint(real_data_22.s_db[50])\n\n[[-0.52153499]]\n\n\n\n\n\n\n\n\n\n\ndb_orig = real_data_22.s_db[:,0,0]\nwindow_db = db_orig[0:int(len(s21.s_db)*0.018)]\nplt.plot(window_db)\n\nprint(np.max(window_db) - np.min(window_db))\nprint(db_orig[0])\n\n0.9154496682728998\n-0.06881931174276346"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProject1_Analysis.html#graphing-for-the-final-figure-used-in-report",
    "href": "projects/radio_frequency/projects/designProject1_Analysis.html#graphing-for-the-final-figure-used-in-report",
    "title": "Analytical Chart Analysis",
    "section": "Graphing for the Final Figure Used in Report",
    "text": "Graphing for the Final Figure Used in Report\n\nfig, axes = plt.subplots(2,2, figsize=[10,10])\n\n## 0, 0 -&gt; analytical\naxCurr = axes[0][0]\n\naxCurr.set_title(\"Magnitude of Analytical Model S21\")\naxCurr.set_xlabel(\"Frequency\")\naxCurr.set_ylabel(\"Attenuation\")\nplt.xscale(\"log\")\nend = -1\n\npb_analytical = find(analyticalRF.s_db, -1)\nct_analytical = find(analyticalRF.s_db, -3)\nsb_analytical = find(analyticalRF.s_db, -20)\n\n#axCurr.scatter(my_frq[loc_at_3], my_arr[loc_at_3], c='blue')\n# plt.annotate(f\"   Passband Freq: ({my_frq[loc_at_3]/1e6:0.2f} MHz, {my_arr[loc_at_3]:0.2f} dB)\", (my_frq[loc_at_3], my_arr[loc_at_3]) )\n\n# plt.scatter(my_frq[loc_at_20], my_arr[loc_at_20], c='pink')\n# plt.annotate(f\"   Stopband Freq: ({my_frq[loc_at_20]/1e6:0.2f} MHz, {my_arr[loc_at_20]:0.2f} dB)\", (my_frq[loc_at_20], my_arr[loc_at_20]) )\n\nplt.plot(freq_ratios[:end], -att1[:end], linewidth=1, label=\"Chebyshev 1\")\n\n\n\nfor i, k in enumerate(marker_idx):\n    x = real_data_22.s.real[k, 0, 0]\n    y = real_data_22.s.imag[k, 0, 0]\n    f = real_data_22.frequency.f_scaled[k]\n    axes[1].scatter(x, y, marker = 'v', s=200, color='b')\n    axes[1].annotate(f\"{my_frq[k]/1e6:.2f} MHz\", (x, y), xytext=(10, 0), textcoords='offset points', color='b')"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab4_pythonfile.html",
    "href": "projects/radio_frequency/projects/Lab4_pythonfile.html",
    "title": "Part 2",
    "section": "",
    "text": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n## https://stackoverflow.com/questions/893657/how-do-i-calculate-r-squared-using-python-and-numpy\n# Polynomial Regression\ndef polyfit(x, y, degree):\n    results = {}\n\n    coeffs = np.polyfit(x, y, degree)\n\n     # Polynomial Coefficients\n    results['polynomial'] = coeffs.tolist()\n\n    # r-squared\n    p = np.poly1d(coeffs)\n    # fit values, and mean\n    yhat = p(x)                         # or [p(z) for z in x]\n    ybar = np.sum(y)/len(y)          # or sum(y)/len(y)\n    ssreg = np.sum((yhat-ybar)**2)   # or sum([ (yihat - ybar)**2 for yihat in yhat])\n    sstot = np.sum((y - ybar)**2)    # or sum([ (yi - ybar)**2 for yi in y])\n    results['determination'] = ssreg / sstot\n\n    return results\n\n\n# Create a DataFrame\nfive_Mhz = {'Voltage (mV)':         [1.5,  1.4,  1.3,  1.2,  1.1,   1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2], \n            'Amplitude Power': [11.2, 11.2, 10.2,  9,    8.2, 7.8, 6.4, 5.4, 4.2,   3, 2.7,  2,  1.7, 0.8],\n            'Power (dBm)': [-64,-64,-65,-66.5,-67,-67,-68,-69,-70.9,-71.8,-73.5,-74.6,-77.2,-79.5]}\ndf_h20_fiveMHz = pd.DataFrame(five_Mhz)\n\n\nplt.plot(df_h20_fiveMHz['Voltage (mV)'])\n\n\n\n\n\n\n\n\n\n## Find the current\nresistanceVal = 1.0\nnumTurns = 75\nradius = 2.51 / 2 * 0.01  ## in meters\n\ndf_h20_fiveMHz['Current (mA)'] = df_h20_fiveMHz['Voltage (mV)'] / resistanceVal\ndf_h20_fiveMHz['Num'] = df_h20_fiveMHz['Current (mA)'] * np.pow(10.0, -3) * numTurns * 8 * 4 * np.pi * np.pow(10.0, -7)\ndf_h20_fiveMHz['Denom'] = (radius/2)*np.sqrt(125)\ndf_h20_fiveMHz['Magnetic Field'] = df_h20_fiveMHz['Num']/df_h20_fiveMHz['Denom']\n\n\nplt.plot(df_h20_fiveMHz['Power (dBm)'], df_h20_fiveMHz['Magnetic Field'])\nplt.ylabel(\"Power dBm\")\nplt.xlabel(\"Field Strength\")\n\nText(0.5, 0, 'Field Strength')\n\n\n\n\n\n\n\n\n\n\n# Create a DataFrame\nhund_khz = {'Voltage (mV)':         [1.5,  1.4,  1.3,  1.2,  1.1,   1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3], \n            'Amplitude Power': [450,420,400,370,350,320,300,250,230,220,200,180,160],\n            'Power (dBm)': [-8.80,-9.36,-9.91,-10.55,-11.28,-12.03,-12.88,-14.01,-15.16,-16.43,-18.01,-19.99,-22.47]}\ndf_h20_hundkhz = pd.DataFrame(hund_khz)\ndf_h20_hundkhz['Current (mA)'] = df_h20_fiveMHz['Voltage (mV)'] / resistanceVal\n\n\ndf_h20_hundkhz['Current (mA)'] = df_h20_fiveMHz['Voltage (mV)'] / resistanceVal\ndf_h20_hundkhz['Num'] = df_h20_fiveMHz['Current (mA)'] * 100 * numTurns * 8 * 4 * np.pi * np.pow(10.0, -7)\ndf_h20_hundkhz['Denom'] = (0.15/2)*np.sqrt(125)\ndf_h20_hundkhz['Magnetic Field'] = df_h20_hundkhz['Num']/df_h20_fiveMHz['Denom']\n\n\nplt.plot(df_h20_hundkhz['Power (dBm)'], df_h20_hundkhz['Magnetic Field'])\nplt.xlabel(\"Power dBm\")\nplt.ylabel(\"Field Strength\")\n\nText(0, 0.5, 'Field Strength')\n\n\n\n\n\n\n\n\n\n\npow_hund = df_h20_hundkhz['Power (dBm)']\npow_fivM = df_h20_fiveMHz['Power (dBm)']\n\nrsq_hundkhz = polyfit(pow_hund, df_h20_hundkhz['Magnetic Field'], 1)\nrsp_fivemhz = polyfit(pow_fivM, df_h20_fiveMHz['Magnetic Field'], 1)\n\nplt.title(\"Low-f Field Power Calibration, H20\")\nplt.plot(pow_hund, np.log(df_h20_hundkhz['Magnetic Field']), 'r.-')\nplt.plot(pow_fivM, np.log(df_h20_fiveMHz['Magnetic Field']), 'b.-')\nplt.legend\nplt.xlabel(\"Power (dBm)\")\nplt.ylabel(\"B (Tesla)\")\n\nprint(f\"R^2 linear fit of 100 kHz: {rsq_hundkhz['determination']} with equation {rsq_hundkhz['polynomial'][1]} + {rsq_hundkhz['polynomial'][0]}*POW\")\nprint(f\"R^2 linear fit of 5 MHz:   {rsp_fivemhz['determination']} with equation {rsp_fivemhz['polynomial'][1]} + {rsp_fivemhz['polynomial'][0]}*POW\")\nintercept = rsq_hundkhz['polynomial'][1]\n\nR^2 linear fit of 100 kHz: 0.946653461235132 with equation 2.2887766684445205 + 0.09497986617819947*POW\nR^2 linear fit of 5 MHz:   0.9494685301857625 with equation 7.165163632162302e-05 + 8.94920345771188e-07*POW"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab4_pythonfile.html#calculating-the-polyfit-for-the-frequency-to-magnetic-field-data",
    "href": "projects/radio_frequency/projects/Lab4_pythonfile.html#calculating-the-polyfit-for-the-frequency-to-magnetic-field-data",
    "title": "Part 2",
    "section": "Calculating the Polyfit for the Frequency to Magnetic Field Data",
    "text": "Calculating the Polyfit for the Frequency to Magnetic Field Data\n\nfreq = [i*np.pow(10, 6) for i in df_h5_htp['Frequency (MHz)']]\npowe = df_h5_htp['Power (dBm)']\n\nrsq_freq = polyfit(np.log(freq), powe, 1)\n\nprint(f\"Slope {rsq_freq['polynomial'][0]}\")\nslope = rsq_freq['polynomial'][0] ## slope for the np.log(freq)\n\nmatching = rsq_freq['polynomial'][1] + rsq_freq['polynomial'][0]*np.log(freq)\n\nadd_pts_xaxis = [freq[0], 28*np.pow(10, 6)]\nadd_pts = [matching[0], rsq_freq['polynomial'][1] + rsq_freq['polynomial'][0]*np.log(28*np.pow(10, 6))]\n\nplt.plot(freq, powe, label=\"Original Data\", linewidth=2)\nplt.plot(freq, matching, '--', label=\"Line of Best Fit\", linewidth=3)\nplt.plot(add_pts_xaxis[1], add_pts[1], 'go', label=\"Estimated Location of dB for 28 MHz\")\nplt.xlabel(\"Frequency (MHz)\")\nplt.ylabel(\"Power\")\nplt.xscale(\"log\")\nplt.title(\"Frequency vs Power for H5 = 30 uT\")\nplt.legend()\n\npow_hund = df_h5_100k['Power (dBm)']\npow_fivM = df_h5_5M['Power (dBm)']\n\nmag_hund = df_h5_100k['Magnetic Field']\nmag_fivM = df_h5_5M['Magnetic Field']\n\nrsq_hundkhz = polyfit(np.log(mag_hund),pow_hund, 1)\nrsp_fivemhz = polyfit(np.log(mag_hund), pow_fivM, 1)\n\nprint(f\"Point at 28 MHz occurs at {rsq_freq['polynomial'][1] + rsq_freq['polynomial'][0]*np.log(28*np.pow(10, 6))}dB\")\ndB_30uT_at_28M = rsq_freq['polynomial'][1] + rsq_freq['polynomial'][0]*np.log(28*np.pow(10, 6))\n\n\n#pow_h5_hund\n#pow_h5_fivM\n#h5_mag_hund\n#h5_h10_fivM\n\nh5_hund_fit = polyfit(pow_h5_hund, np.log(h5_mag_hund), 1)\nh5_fivM_fit = polyfit(pow_h5_fivM, np.log(h5_h10_fivM), 1)\n\nprint(h5_hund_fit['polynomial'][0], \", \", h5_fivM_fit['polynomial'][0])\n\nprint(h5_hund_fit['determination'], \", \", h5_fivM_fit['determination'])\naverage_slope_h5_powToMagLog = np.average([h5_hund_fit['polynomial'][0], h5_fivM_fit['polynomial'][0]])\n\n\n# calculate the log magnitude\nplt.plot(np.log(mag_hund), rsq_hundkhz['polynomial'][1] + rsq_hundkhz['polynomial'][0]*np.log(mag_hund))\nplt.plot(np.log(mag_hund), pow_hund)\n\npoint69_tes = np.log([34.3908061414456*np.pow(10.0, -6)])\npoint69_db = [rsq_hundkhz['polynomial'][1]+rsq_hundkhz['polynomial'][0]*np.log(34.3908061414456*np.pow(10.0, -6))]\n\npoint0_tes = np.log([ np.pow(10.0, -6)]) #, df_h5_100k['Magnetic Field'][0]])\npoint0_db =  [ rsq_hundkhz['polynomial'][1]+rsq_hundkhz['polynomial'][0]*np.log(np.pow(10.0, -6))] #, df_h5_100k['Power (dBm)'][0]]\n\nplt.plot(point69_tes, point69_db, 'ro')\nplt.plot(point0_tes, point0_db, 'bo')\nplt.xlabel(\"Log of Magnetic Field\")\nplt.ylabel(\"Power\")\nplt.title(\"Log Magnitude vs Power for H5 = 100 kHz\")\n\nexpectedPower = rsq_hundkhz['polynomial'][1]+rsq_hundkhz['polynomial'][0]* np.log (34.3908061414456*np.pow(10.0, -6))\nexpectedPower0 = rsq_hundkhz['polynomial'][1]+rsq_hundkhz['polynomial'][0]*np.log(np.pow(10.0, -6))\nprint(f\"With the given slope, we have expected power {expectedPower0}dB at 100kHz, which kinda matches the plots we're seeing\")\n\nprint(f\"The slopes we're seeing are {rsq_hundkhz['polynomial'][0]} and {rsq_hundkhz['polynomial'][1]}\")\n\n\n# With this in consideration, we know that we can now find the magnetic field for any given power. \n# We have a linear relationship to go from frequency to dB, and then a way to go from dB to magnetic field\n\nrsq_freq = polyfit(np.log(df_h5_htp['Frequency (MHz)']), df_h5_htp['Power (dBm)'], 1). # MHz vs dBm\n\nexpectedPower = rsq_hundkhz['polynomial'][1]+rsq_hundkhz['polynomial'][0]* np.log (34.3908061414456*1e-6) # from T to dB\nexpectedPower0 = rsq_hundkhz['polynomial'][1]+rsq_hundkhz['polynomial'][0]*np.log(1e-6) # from T to dB\n\n# The power that we would get for 28 MHz using the H5 probe (H = 31 uT):\ndB_at_28M = rsq_freq['polynomial'][1] + rsq_freq['polynomial'][0] * np.log(28*1e6) # from frequency to dB\n\n# the slope from dB to dB is determined by the average slope found previously.\n# we know that the magnetic field we're starting at is 1 uT: resultantly, we know (slope)*(change in dB) + np.log(1 uT) = np.log(new uT)\nlog_uT_at_28M = average_slope_h5_powToMagLog*(dB_at_28M-dB_30uT_at_28M ) + np.log(34.3908061414456*1e-6)\n#^ from dB to log(T)\n\nprint(log_uT_at_28M) # should be log(T)\n\n\nh5_hund_fit = polyfit(pow_h5_hund, np.log(h5_mag_hund), 1) ## slope of log(Magnetic Field) = m(pow) + b\nh5_fivM_fit = polyfit(pow_h5_fivM, np.log(h5_h10_fivM), 1)\n\npoints_28M_uT = [np.log(34.3908061414456*1e-6), log_uT_at_28M] # magnetic fields (in log(Teslas)\npoints_28M_dB = [dB_30uT_at_28M, dB_at_28M]               # power (in dB)\n\nh5_hund_logMag = h5_hund_fit['polynomial'][1] + h5_hund_fit['polynomial'][0]*np.asarray(points_28M_dB) # in log(Tesla)\nh5_fivM_logMag = h5_fivM_fit['polynomial'][1] + h5_fivM_fit['polynomial'][0]*np.asarray(points_28M_dB) # in log(Tesla)\n\nplt.plot(points_28M_uT, points_28M_dB, 'ro-', label=\"28 MHz\") # plot the points for 28 M\n\nplt.plot(np.log(mag_hund), pow_hund, 'bo-', label=\"100 kHz\")          # \nplt.plot(np.log(mag_fivM), pow_fivM, 'go-', label=\"5 MHz\")\n\nplt.plot(h5_hund_logMag, points_28M_dB, 'bo--', label=\"Expected 100 kHz\", alpha=0.25) # plot the points for 100 kHz\nplt.plot(h5_fivM_logMag, points_28M_dB, 'go--', label=\"Expected 5 MHz\", alpha=0.25) # plot the points for 5 MHz\n\nplt.xlabel(\"Log of Magnetic Field (H)\")\nplt.ylabel(\"Power (dB)\")\nplt.legend()\n\nprint(f\"The Magnetic field at -8 dB is {log_uT_at_28M:.2f} log(T)\")\n\nprint(f\"This corresponds with {np.exp(log_uT_at_28M)} T\")\n      \n## graph the projected slopes of the lines to show what we'd expect to see\n# magnetic field =      b                     +           m * pow\n\n\nuT_at_28M = np.exp(log_uT_at_28M)\nresistance = (160) / (uT_at_28M)\nprint(resistance)\n\n\ndb_100k = rsq_freq['polynomial'][1] + rsq_freq['polynomial'][0]*np.log(0.1)\ndb_5M = rsq_freq['polynomial'][1] + rsq_freq['polynomial'][0]*np.log(5)\n\ndb_100_for_neg69 = rsq_hundkhz['polynomial'][1] + rsq_hundkhz['polynomial'][0]*np.log(69)\ndb_5M_for_neg69 = rsp_fivemhz['polynomial'][1] + rsp_fivemhz['polynomial'][0]*np.log(69)\n\nprint(f\"db_100k = {db_100k}dB, and db_5M = {db_5M}dB\")\nprint(f\"For the actual plots of H5: 100 kHz has 69uT at {db_100_for_neg69}, and 5 MHz has 69uT at {db_5M_for_neg69}\")\n\n\n## we know the magnetic field is constant; for these, we only vary the frequency and find the power\nh5_htp_1uT = {'Frequency (MHz)':         [1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3], \n            'Power (dBm)': [-80, -80.5, -81, -82.5, -84.5, -86.5, -88, -90]}\n\nh10_htp_1uT = {'Frequency (MHz)':         [1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3], \n           'Power (dBm)': [-57, -57.5, -58.5, -60, -61.5, -63, -65.5, -69]}\n\nh20_htp_1uT = {'Frequency (MHz)':         [1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3], \n           'Power (dBm)': [-39, -40, -41, -42.5, -44, -45, -47, -50]}\n\ndf_h5_htp_1uT = pd.DataFrame(h5_htp_1uT)\ndf_h10_htp_1uT = pd.DataFrame(h10_htp_1uT)\ndf_h20_htp_1uT = pd.DataFrame(h20_htp_1uT)\n\n\nplt.plot(df_h10_htp['Frequency (MHz)'], df_h10_htp['Power (dBm)'], 'ro-', label=\"H10, 34.3908061414456 uT\")\nplt.plot(df_h10_htp_1uT['Frequency (MHz)'], df_h10_htp_1uT['Power (dBm)'], 'r.-', label=\"H10, 1 uT\", alpha = 0.35)\n\n\nplt.plot(df_h5_htp['Frequency (MHz)'], df_h5_htp['Power (dBm)'], 'bo-', label=\"H5, 34.3908061414456 uT\")\nplt.plot(df_h5_htp_1uT['Frequency (MHz)'], df_h5_htp_1uT['Power (dBm)'], 'b.-', label=\"H5, 1 uT\", alpha = 0.35)\n\n#df_h20_freqtopow_4_8mV\nplt.plot(df_h20_freqtopow_4_8mV['Frequency (MHz)'], df_h20_freqtopow_4_8mV['Power (dBm)'], 'go-', label=\"H20, 25.7931046060842 uT\")\nplt.plot(h20_htp_1uT['Frequency (MHz)'], h20_htp_1uT['Power (dBm)'], 'g.-', label=\"H20, 1 uT\", alpha = 0.35)\n\n\nplt.xlabel(\"Frequency (MHz)\")\nplt.ylabel(\"Power (dBm)\")\nplt.xscale(\"log\")\nplt.legend()\nplt.title(\"Frequency vs Power for all H values\")\n\n\nplt.plot(df_h10_htp['Frequency (MHz)'][:-2], df_h10_htp['Power (dBm)'][:-2], 'ro-', label=\"H10, 34.3908061414456 uT\")\nplt.plot(df_h10_htp_1uT['Frequency (MHz)'], df_h10_htp_1uT['Power (dBm)'], 'r.-', label=\"H10, 1 uT\", alpha = 0.35)\n\n\nplt.plot(df_h5_htp['Frequency (MHz)'][:-2], df_h5_htp['Power (dBm)'][:-2], 'bo-', label=\"H5, 34.3908061414456 uT\")\nplt.plot(df_h5_htp_1uT['Frequency (MHz)'], df_h5_htp_1uT['Power (dBm)'], 'b.-', label=\"H5, 1 uT\", alpha = 0.35)\n\n#df_h20_freqtopow_4_8mV\nplt.plot(df_h20_freqtopow_4_8mV['Frequency (MHz)'][:-2], df_h20_freqtopow_4_8mV['Power (dBm)'][:-2], 'go-', label=\"H20, 25.7931046060842 uT\")\nplt.plot(h20_htp_1uT['Frequency (MHz)'], h20_htp_1uT['Power (dBm)'], 'g.-', label=\"H20, 1 uT\", alpha = 0.35)\n\navg_dif_h5 = np.mean(df_h5_htp['Power (dBm)'][:-2] - df_h5_htp_1uT['Power (dBm)'])\navg_dif_h10 = np.mean(df_h10_htp['Power (dBm)'][:-2] - df_h10_htp_1uT['Power (dBm)'])\navg_dif_h20 = np.mean(df_h20_freqtopow_4_8mV['Power (dBm)'][:-2] - h20_htp_1uT['Power (dBm)'])\n\nplt.legend()\nplt.title(\"Plotting Power by Frequencies, calculating Average Difference\")\nplt.xlabel(\"Frequency (MHz)\")\nplt.ylabel(\"Power (dBm)\")\nplt.xscale(\"log\")\n\nprint(\"Average Differences: \")\nprint(f\"H20: {avg_dif_h20} (25.7931046060842 times greater)\")\nprint(f\"H10: {avg_dif_h10} (34.3908061414456 times greater)\")\nprint(f\"H5: {avg_dif_h5} (34.3908061414456 times greater)\")"
  },
  {
    "objectID": "projects/mcf_lci.html",
    "href": "projects/mcf_lci.html",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "",
    "text": "Brain imaging capabilities such as fMRI scans, although broad in capability, normally face issues when it comes to creating images with spatial and temporal resolution. Light increases the capabilities of both of these, but is limited by conventional lenses, which though non-intrusive causes a great degree of scatter, and GRIN lenses, which are wide, stiff intrusions in the context of optical imaging and risk damaging the subject while preventing in-situ imaging. Multicore fibers lie in the middle of these two. Capable of in-situ imaging and minimally invasive, this system would allow for the high temporal and spatial resolution of light and the benefits of non optical system."
  },
  {
    "objectID": "projects/mcf_lci.html#what-is-the-goal",
    "href": "projects/mcf_lci.html#what-is-the-goal",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "",
    "text": "Brain imaging capabilities such as fMRI scans, although broad in capability, normally face issues when it comes to creating images with spatial and temporal resolution. Light increases the capabilities of both of these, but is limited by conventional lenses, which though non-intrusive causes a great degree of scatter, and GRIN lenses, which are wide, stiff intrusions in the context of optical imaging and risk damaging the subject while preventing in-situ imaging. Multicore fibers lie in the middle of these two. Capable of in-situ imaging and minimally invasive, this system would allow for the high temporal and spatial resolution of light and the benefits of non optical system."
  },
  {
    "objectID": "projects/mcf_lci.html#what-i-worked-on",
    "href": "projects/mcf_lci.html#what-i-worked-on",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "What I Worked On",
    "text": "What I Worked On\n\nSimulations – …\nSLM Calibrations – …\nInterferometry – …\nSoftware Connections – U1800 Camera, pco.panda Camera, NiDAQmx…"
  },
  {
    "objectID": "projects/mcf_lci.html#want-to-learn-more",
    "href": "projects/mcf_lci.html#want-to-learn-more",
    "title": "Multicore Fiber Bundle Low Coherence Interferometry Research",
    "section": "Want to Learn More?",
    "text": "Want to Learn More?\nSee the HMC Biophotonics Lab page.\nMulticore Fiber Bundle LCI is one of the research projects run by Mudd Professor Josh Brake at Harvey Mudd College."
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab5_PythonFile.html",
    "href": "projects/radio_frequency/projects/Lab5_PythonFile.html",
    "title": "S11, S21 and S22 for TL-ANT2409A measurements on broadside",
    "section": "",
    "text": "import skrf as rf\n%matplotlib inline\nfrom matplotlib import pyplot as plt  # for advanced smith chart only\nimport skrf as rf\nimport numpy as np\n\nfilenames = []\nnetworks = []\n\n\nnetworks.append(rf.Network(\"Lab_5/0-360/0d.S2P\"))\n\nfor i in range(36):\n    # we're looking at txt files first\n    filename = 'Lab_5/0-360/' + f\"{(i+1)*10}.S2P\"\n\n    networks.append(rf.Network(filename))\n\n\n## plot s11\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nrf.stylely()\nnetworks[0].plot_s_smith(draw_labels=True, linewidth=1, ax=axs[0])\nnetworks[15].plot_s_smith(draw_labels=True, linewidth=1, ax=axs[1])\naxs[0].set_title(\"Smith Chart, 0º\", fontsize=10)\naxs[1].set_title(\"Smith Chart, 160º\", fontsize=10)\n\nText(0.5, 1.0, 'Smith Chart, 160º')\n\n\n\n\n\n\n\n\n\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nrf.stylely()\nnetworks[0].s11.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[0])\nnetworks[15].s11.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[1])\naxs[0].set_title(\"Smith Chart, 0º\", fontsize=10)\naxs[1].set_title(\"Smith Chart, 160º\", fontsize=10)\n\nText(0.5, 1.0, 'Smith Chart, 160º')\n\n\n\n\n\n\n\n\n\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nrf.stylely()\nnetworks[0].s21.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[0])\nnetworks[15].s21.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[1])\naxs[0].set_title(\"Smith Chart, 0º\", fontsize=10)\naxs[1].set_title(\"Smith Chart, 160º\", fontsize=10)\n\nText(0.5, 1.0, 'Smith Chart, 160º')\n\n\n\n\n\n\n\n\n\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nrf.stylely()\nnetworks[0].s22.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[0])\naxs[0].set_title(\"Smith Chart, 0º\", fontsize=10)\naxs[1].set_title(\"Smith Chart, 160º\", fontsize=10)\nnetworks[15].s22.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[1])\n\n\n\n\n\n\n\n\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nrf.stylely()\nnetworks[0].plot_s_db(lw=2, ax=axs[0])\naxs[0].set_title(\"All S Parameter Measurements for Unknown Antenna, 0º\", fontsize=10)\nnetworks[15].plot_s_db(lw=2, ax=axs[1])\naxs[1].set_title(\"All S Parameter Measurements for Unknown Antenna, 150º\", fontsize=10)\n\nText(0.5, 1.0, 'All S Parameter Measurements for Unknown Antenna, 150º')\n\n\n\n\n\n\n\n\n\n\nnetworks[0][\"2400mHz\"].s21.s_db\n\narray([[[-61.10657392]]])\n\n\n\nnetworks[0]['2.45-2.5ghz'].plot_s_db(lw=2)\nplt.title(\"S Parameters, Unknown Antenna, Spanning 2.45-2.5 GHz, 0º\")\n\nText(0.5, 1.0, 'S Parameters, Unknown Antenna, Spanning 2.45-2.5 GHz, 0º')"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab5_PythonFile.html#calculations-showing-gain-extraction-from-tl-ant2409a",
    "href": "projects/radio_frequency/projects/Lab5_PythonFile.html#calculations-showing-gain-extraction-from-tl-ant2409a",
    "title": "S11, S21 and S22 for TL-ANT2409A measurements on broadside",
    "section": "Calculations showing gain extraction from TL-ANT2409A",
    "text": "Calculations showing gain extraction from TL-ANT2409A\n\nCalculate the Gain of Antenna\n\n## Gather all of the S21 data together\n\ns21_data_q1 = []\n\nfor i in range(len(networks)):\n    s21_v = networks[i]['2.48ghz'].s21.s_db[0][0][0]\n    s21_data_q1.append(s21_v)\n\n\n## Gain of Horn Antenna (G_TX) at 2.4 GHz\ng_tx = 13.03 # dBm\nl_val = 3e8/(2.48e9) # meters\nD_val = 1.4478 # meters\nair_loss = 20 * np.log10(l_val / (4 * np.pi * D_val))\n\n\ng_rx_list_q1 = []\n\nfor s21 in s21_data_q1:\n    val = s21 - g_tx - air_loss\n    g_rx_list_q1.append(val)"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab5_PythonFile.html#radiation-pattern-for-tl-ant2409a",
    "href": "projects/radio_frequency/projects/Lab5_PythonFile.html#radiation-pattern-for-tl-ant2409a",
    "title": "S11, S21 and S22 for TL-ANT2409A measurements on broadside",
    "section": "Radiation pattern for TL-ANT2409A",
    "text": "Radiation pattern for TL-ANT2409A"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab5_PythonFile.html#discussion-of-antenna-type-for-tl-ant2409a",
    "href": "projects/radio_frequency/projects/Lab5_PythonFile.html#discussion-of-antenna-type-for-tl-ant2409a",
    "title": "S11, S21 and S22 for TL-ANT2409A measurements on broadside",
    "section": "Discussion of antenna type for TL-ANT2409A",
    "text": "Discussion of antenna type for TL-ANT2409A\n\nangles = np.linspace(0, 360, 37)\nangles = angles * 2 * np.pi / 360.0\n\n# plot\nax = plt.subplot(111, polar=True)\nplt.suptitle(\"Radiation Pattern of Unknown Antenna\")\n# set zero west\n# let set an azimuth for example, pi\nplt.plot(angles[1:], g_rx_list_q1[1:])\n\n\n\n\n\n\n\n\n\n# plot the impedance vs frequency - need to use s11\n\ns11_val = networks[0].s11.s_db\n\ns11_val = np.expand_dims(s11_val, [1,2] )\ns11_val = s11_val[:,0,0,0,0]\nz_impedance_map = [ np.abs(50*(1-i)/(i + 1)) for i in s11_val]\nplt.plot(networks[0].f, z_impedance_map, label=\"Impedance [Ohms]\")\nplt.plot(networks[0].f, s11_val*100, label=\"S11 Value\", alpha=0.5)\nplt.title(\"Plot of the Impedance value with Backdrop showing S11\")\nplt.xlabel(\"frequency (Hz)\")\nplt.ylabel(\"Impedance [Ohms]\")\nplt.legend()"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab5_PythonFile.html#discussion-of-patch-antenna-theory-for-machined-antenna",
    "href": "projects/radio_frequency/projects/Lab5_PythonFile.html#discussion-of-patch-antenna-theory-for-machined-antenna",
    "title": "S11, S21 and S22 for TL-ANT2409A measurements on broadside",
    "section": "Discussion of patch antenna theory for machined antenna",
    "text": "Discussion of patch antenna theory for machined antenna\n\nfilenames_patch = []\nnetworks_patch = []\n\nangles_patch = [0,20,40,60,80,100,120,140,160,180,200,220,240,260,280,300,320,340,360]\n\nfor i in angles_patch:\n    # we're looking at txt files first\n    filenames_patch = 'Lab_5/patch-0-360/' + f\"{i}.S1P\"\n\n    networks_patch.append(rf.Network(filenames_patch))\n\n# networks_patch[0].plot_s_db(lw=2)\n\n\n## Gather all of the S21 data together\n\ns21_data_q2_1 = []\n\nfor i in range(len(networks_patch)):\n    s21_v = networks_patch[i]['1.4Ghz'].s_db[0][0][0]\n    s21_data_q2_1.append(s21_v)\n\n\n## Gain of Horn Antenna (G_TX) at 2.4 GHz\ng_tx = 4.55 # dBm\nl_val = 3e8/(1.4e9) # meters\nD_val = 1.4478 # meters\nair_loss = 20 * np.log10(l_val / (4 * np.pi * D_val))\n\n\ng_rx_list_q2_1 = []\n\nfor s21 in s21_data_q2_1:\n    # print(s21)\n    val = s21 - g_tx - air_loss\n    g_rx_list_q2_1.append(val)\n\n# print(g_rx_list_q2)"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab5_PythonFile.html#extracted-radiation-pattern-of-patch-antenna",
    "href": "projects/radio_frequency/projects/Lab5_PythonFile.html#extracted-radiation-pattern-of-patch-antenna",
    "title": "S11, S21 and S22 for TL-ANT2409A measurements on broadside",
    "section": "Extracted radiation pattern of patch antenna",
    "text": "Extracted radiation pattern of patch antenna\n\n# plot\nax = plt.subplot(111, polar=True)\n# set zero west\n# let set an azimuth for example, pi\nangles_patch = [p * 2 * np.pi / 360 for p in angles_patch]\n\nplt.plot(angles_patch, g_rx_list_q2_1)\nplt.title(\"Patch Antenna, Double Resonant Frequency\")\n\nText(0.5, 1.0, 'Patch Antenna, Double Resonant Frequency')\n\n\n\n\n\n\n\n\n\n\nA little over resonant frequency\n\nfilenames_2 = []\nnetworks_2 = []\n\ns21_data_q2_2 = []\n\nnum_points=18\nfor i in range(num_points):\n    # we're looking at txt files first\n    filenames_2 = 'Lab_5/patch-0-360-better/' + f\"{i*20}.S2P\"\n    networks_2.append(rf.Network(filenames_2))\n\nfor i in range(len(networks_2)):\n    s21_v = networks_2[i]['728.155Mhz'].s21.s_db[0][0][0]\n    s21_data_q2_2.append(s21_v)\n    \ng_tx = 4.55 # dBm\nl_val = 3e8/(728.155e6) # meters\nD_val = 1.4478 # meters\nair_loss = 20 * np.log10(l_val / (4 * np.pi * D_val))\n\ng_rx_list_q2_2 = []\n\nfor s21 in s21_data_q2_2:\n    val = s21 - g_tx - air_loss\n    g_rx_list_q2_2.append(val)\n\n# plot\nax = plt.subplot(111, polar=True)\n\n# set zero west\n# let set an azimuth for example, pi\nangles_2 = np.linspace(0, 360, num_points)\nangles_2 = angles_2 * 2 * np.pi / 360\nplt.plot(angles_2, g_rx_list_q2_2)\nplt.title(\"Patch Antenna Frequency\")\n\nprint(max(g_rx_list_q2_2))\n\n-9.445195174000219\n\n\n\n\n\n\n\n\n\n\nnetworks_2[0].s21.plot_s_db(label=\"S21\")"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab5_PythonFile.html#s11-s21-and-s22-for-patch-antenna-measurements-on-broadside",
    "href": "projects/radio_frequency/projects/Lab5_PythonFile.html#s11-s21-and-s22-for-patch-antenna-measurements-on-broadside",
    "title": "S11, S21 and S22 for TL-ANT2409A measurements on broadside",
    "section": "S11, S21 and S22 for patch antenna measurements on broadside",
    "text": "S11, S21 and S22 for patch antenna measurements on broadside\n\n## plot s11\nfig, axs = plt.subplots(1, 5, figsize=(50, 10))\nrf.stylely()\nnetworks_2[0].s11.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[0])\nnetworks_2[5].s11.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[1])\nnetworks_2[10].s11.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[2])\nnetworks_2[14].s11.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[3])\nnetworks_2[17].s11.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[4])\naxs[0].set_title(\"Smith Chart, Patch Antenna 0º\", fontsize=10)\naxs[1].set_title(\"Smith Chart, Patch Antenna 160º\", fontsize=10)\n\nText(0.5, 1.0, 'Smith Chart, Patch Antenna 160º')\n\n\n\n\n\n\n\n\n\n\n## plot s21\nfig, axs = plt.subplots(1, 5, figsize=(50, 10))\nrf.stylely()\nnetworks_2[0].s21.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[0])\nnetworks_2[5].s21.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[1])\nnetworks_2[10].s21.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[2])\nnetworks_2[14].s21.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[3])\nnetworks_2[17].s21.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[4])\n\n\n\n\n\n\n\n\n\n## plot s22\nfig, axs = plt.subplots(1, 5, figsize=(50, 10))\nrf.stylely()\nnetworks_2[0].s22.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[0])\nnetworks_2[5].s22.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[1])\nnetworks_2[10].s22.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[2])\nnetworks_2[14].s22.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[3])\nnetworks_2[17].s22.plot_s_smith(draw_labels=True, linewidth=1, ax=axs[4])\n\n\n\n\n\n\n\n\n\nfig, axs = plt.subplots(1, 5, figsize=(50, 10))\nrf.stylely()\nnetworks_2[0].plot_s_db(lw=2, ax=axs[0])\naxs[0].set_title(\"All S Parameter Measurements for Unknown Antenna, 0º\", fontsize=20)\n\nnetworks_2[4].plot_s_db(lw=2, ax=axs[1])\naxs[1].set_title(\"All S Parameter Measurements for Unknown Antenna, 80º\", fontsize=20)\n\nnetworks_2[8].plot_s_db(lw=2, ax=axs[2])\naxs[2].set_title(\"All S Parameter Measurements for Unknown Antenna, 160º\", fontsize=20)\n\nnetworks_2[12].plot_s_db(lw=2, ax=axs[3])\naxs[3].set_title(\"All S Parameter Measurements for Unknown Antenna, 240º\", fontsize=20)\n\nnetworks_2[16].plot_s_db(lw=2, ax=axs[4])\naxs[4].set_title(\"All S Parameter Measurements for Unknown Antenna, 320º\", fontsize=20)\n\nText(0.5, 1.0, 'All S Parameter Measurements for Unknown Antenna, 320º')\n\n\n\n\n\n\n\n\n\n\nActual Resonant Frequency\n\n\nPlotting all Frequencies\n\nfilenames_q2_3 = []\nnetworks_q2_3 = []\n\ns21_data_q2_3 = []\n\npoints=[0,20,40,60,80,90,100,120,140,160,180,200,220,240,260,270,280,300,320,340]\nfor i in points:\n    # we're looking at txt files first\n    filenames_q2_3 = 'Lab_5/Q2-680MHz/' + f\"{i}.S1P\"\n    networks_q2_3.append(rf.Network(filenames_q2_3))\n\nfor net in networks_q2_3:\n    s21_v = net['680.5Mhz'].s_db[0][0][0]\n    s21_data_q2_3.append(s21_v)\n    \ng_tx = 4.03 # dBi -- Isotropic Gain with 680 MHz\nl_val = 3e8/(680e6) # meters\nD_val = 1.4478 # meters\nair_loss = 20 * np.log10(l_val / (4 * np.pi * D_val))\n\ng_rx_list_q2_3 = []\n\nfor s21 in s21_data_q2_3:\n    val = s21 - g_tx - air_loss\n    g_rx_list_q2_3.append(val)\n\n# plot\nax = plt.subplot(111, polar=True)\n\n# set zero west\n# let set an azimuth for example, pi\nangles_q2_3 = [p * 2 * np.pi / 360 for p in points]\nplt.plot(angles_q2_3, g_rx_list_q2_3)\nplt.title(\"Patch Antenna Frequency\")\n\nprint(max(g_rx_list_q2_3))\n\n0.8242584027777866\n\n\n\n\n\n\n\n\n\n\nfilename_q2_3 = 'Lab_5/Q2-680MHz/0.S2P'\nnetwork_q2_3 = rf.Network(filename_q2_3)\n\nfig, axs = plt.subplots(1, 1, figsize=(20, 10))\nrf.stylely()\nnetwork_q2_3.plot_s_db(lw=5, axis=axs)\naxs.set_title(\"All S Parameter Measurements for Patch Antenna, 0º\", fontsize=50)\n\nText(0.5, 1.0, 'All S Parameter Measurements for Patch Antenna, 0º')\n\n\n\n\n\n\n\n\n\n\nplt.xticks([np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4])\nplt.plot(angles_patch, g_rx_list_q2_1, 'ro-', label=\"1.455MHz\")\nplt.plot(angles_2, g_rx_list_q2_2, 'bo-', label=\"728.155MHz\")\nplt.plot(angles_q2_3, g_rx_list_q2_3, 'go-', label=\"680MHz\")\nprint(g_rx_list_q2_3[0])\nplt.legend()\nplt.title(\"Gain of S21 at Different Frequencies\")\nplt.ylabel(\"Gain of S21\")\nplt.xlabel(\"Angle (CCW) [rad/sec]\")\n\n0.8236438713486223\n\n\nText(0.5, 0, 'Angle (CCW) [rad/sec]')\n\n\n\n\n\n\n\n\n\n\n\nYagi Antenna\n\nfilenames_yagi = []\nnetworks_yagi = []\n\ns21_data_yagi = []\n\ng_tx = 7.44 # dBi -- Isotropic Gain with 680 MHz\nl_val = 3e8/(680e6) # meters\nD_val = 1.4478 # meters\nair_loss = 20 * np.log10(l_val / (4 * np.pi * D_val))\n\npoints=[0,20,40,60,80,90,100,120,140,160,180,200,220,240,260,270,280,300,320,340]\nfor i in points:\n    # we're looking at txt files first\n    filenames_yagi = 'Lab_5/Q3/' + f\"{i}.S2P\"\n    networks_yagi.append(rf.Network(filenames_yagi))\n\nfor net in networks_yagi:\n    s21_v = net['915Mhz'].s21.s_db[0][0][0]\n    s21_data_yagi.append(s21_v)\n\ng_rx_list_yagi = []\n\nfor s21 in s21_data_yagi:\n    val = s21 - g_tx - air_loss\n    g_rx_list_yagi.append(val)\n\n# plot\nax = plt.subplot(111, polar=True)\n\n# set zero west\n# let set an azimuth for example, pi\nangles_yagi = [p * 2 * np.pi / 360 for p in points]\nplt.plot(angles_yagi, g_rx_list_yagi)\nplt.title(\"Yagi Antenna Frequency\")\n\nText(0.5, 1.0, 'Yagi Antenna Frequency')\n\n\n\n\n\n\n\n\n\n\nnetworks_yagi[0].s21.plot_s_db(label=\"yagi\")\nnetworks[0].s21.plot_s_db(label=\"1.455 GHz\")\nnetworks_2[0].s21.plot_s_db(label=\"728.155MHz\")\nnetworks_q2_3[0].plot_s_db(label=\"680MHz\")\n\n/Users/zoeworrall/Desktop/Mudd/2024_4/RF_Circuitry/rf_venv/lib/python3.12/site-packages/skrf/mathFunctions.py:268: RuntimeWarning: divide by zero encountered in log10\n  out = 20 * np.log10(z)"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab5_PythonFile.html#extracted-impedance-of-patch-antenna-and-comparison-to-theory",
    "href": "projects/radio_frequency/projects/Lab5_PythonFile.html#extracted-impedance-of-patch-antenna-and-comparison-to-theory",
    "title": "S11, S21 and S22 for TL-ANT2409A measurements on broadside",
    "section": "Extracted impedance of patch antenna and comparison to theory",
    "text": "Extracted impedance of patch antenna and comparison to theory\n\n# we're looking at txt files first\nfilename_q2 = 'Lab_5/Q2-680MHz/0.S2P'\nnetwork_q2 = rf.Network(filename_q2)\n\nnetwork_q2.plot_s_db()\n\nS11_pow = network_q2['680MHz'].s11.s_db\n\n\n\n\n\n\n\n\n\n## calculate S11 at 0º - Gain\nprint(f\"S11 in dB is {S11_pow}\")\nS11_volt = np.exp(S11_pow/20)\n\nz0 = 50\nZ_a = z0 * (S11_pow-1)/(S11_pow+1)\n\nprint(f\"The impedance of the system is {Z_a}\")\n\nS11 in dB is [[[-11.04927354]]]\nThe impedance of the system is [[[59.95096806]]]\n\n\n\n## calculating the impedance with measurements\n\ne_r = 4\nL = 0.103\nW = 0.131\n\nfirst_mult = e_r**2 / (e_r - 1)\nsecnd_mult = (L/W)**2\n\nx_p = 0.025\nZ_a_theory_0 = 90 * first_mult * secnd_mult\n\ninternal_mult = np.pi * x_p / L\nthird_mult = np.pow( np.cos( internal_mult ) , 2 )\n\nZ_a_theory = Z_a_theory_0 * third_mult\nprint(Z_a_theory)\n\n155.1546891529339\n\n\n\nZ_"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProjec1_Plotting.html",
    "href": "projects/radio_frequency/projects/designProjec1_Plotting.html",
    "title": "Setting all Required Values",
    "section": "",
    "text": "import math\nimport numpy as np\nimport skrf as rf\nimport matplotlib.pyplot as plt\nimport pandas as pd\n# want to graph frequency vs attenuation\n\nomegas = np.linspace(70e6, 130e6) * np.pi * 2\n\nfreq_cutoff = 100e6\nomega_cutoff = freq_cutoff * 2 * np.pi\npb_allowable_ripple = 1 # 1dB of allowable ripple in the passband\n\nepsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\nn = 3 # order that we're using\n\nB = 1/n * np.arccosh(1/epsilon)\ninv_ratio = (omegas/omega_cutoff) * np.cosh(B) # (w/wc)'\n\ndef C_3 (x):\n    return 4 * np.power(x, 3) - 3 * x\n\nattenuation = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv_ratio), 2))\n\n## Uses the math found within the RF Circuitry book to build an analytical model of the LPF Chebyshev filter we're building\ndef buildAtt(start_w, end_w):\n\n    omegas = np.linspace(start_w, end_w, 1000000) * np.pi * 2\n\n    freq_cutoff = 100e6\n    omega_cutoff = freq_cutoff * 2 * np.pi\n    pb_allowable_ripple = 0.5 # 1dB of allowable ripple in the passband\n    \n    epsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\n    print(\"Epsilon \", epsilon)\n    \n    n = 3 # order that we're using\n    \n    B = 1/n * np.arccosh(1/epsilon)\n    inv_ratio = (omegas/omega_cutoff) * np.cosh(B) # (w/wc)'\n\n    attenuation = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv_ratio), 2)  )\n    return (omegas, attenuation)\n\n## Finds the index of the value closest to our desired value within an array\ndef find(arr, val):\n    diff_mat = arr - np.ones(len(arr))*val\n    return np.argmin(np.abs(diff_mat))\n\ndef C_3 (x):\n    return 4 * np.power(x, 3) - 3 * x"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProjec1_Plotting.html#defining-the-things-i-will-be-comparing",
    "href": "projects/radio_frequency/projects/designProjec1_Plotting.html#defining-the-things-i-will-be-comparing",
    "title": "Setting all Required Values",
    "section": "Defining the Things I will be Comparing",
    "text": "Defining the Things I will be Comparing\n\nanalytical_freq, analytical_db = buildAtt(40e6, 130e6)\ns21_AnalyticalSim = rf.Network(frequency = analytical_freq, s = analytical_db)\n\nanalytical_freq = analytical_freq/(2*np.pi)\nanalytical_db = -analytical_db\n\nEpsilon  0.34931140018894796\n\n\n\nfilename = \"dp1_40to130.txt\"\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\ns21_IdealSim = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])\n\n\nfilename = \"dp1_40to130_real.txt\"\n\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\ns21_RealSim = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])\n\n\ncsv13 = pd.read_csv('CSV13.csv', skiprows=13)\ncsv13.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv13['Z_n'] = csv13['Z_Real']/50 + 1j*csv13['Z_Imag']/50\ncsv13['S_21'] = ( csv13['Z_n']-1 ) / ( csv13['Z_n']+1 )\nreal_data_21 = rf.Network(frequency = csv13['Frequency'], s = csv13['S_21'], m=0, n=0)\nmarker_idx = [30, 60, 90]\n\nstart_val = real_data_21.s_db[0]\nsval = (np.ones(len(real_data_21.s_db)) * start_val).T\n\nmy_arr = real_data_21.s_db[:,0,0]\nmy_frq = real_data_21.f\n\nloc_at_3 = find(my_arr, -3)\nfreq_at_3 = my_frq[loc_at_3]/(2*np.pi)\natt_at_3 = my_arr[loc_at_3]\n\nloc_at_20 = find(my_arr, -20)\nfreq_at_20 = my_frq[loc_at_20]/(2*np.pi)\natt_at_20 = my_arr[loc_at_20]\n\nloc_100MHz = find(my_frq, 100e6)\nloc_70MHz = find(my_frq, 70e6)\nloc_300MHz = find(my_frq, 300e6)\nmarker_idx = [loc_70MHz, loc_100MHz, loc_300MHz]\n\n\nfig, axes = plt.subplots(2,2, figsize=[15,10])\n\n## 0, 0 -&gt; analytical\naxCurr = axes[0][0]\naxCurr.set_title(\"Magnitude of Analytical Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Magnitude (dB)\")\nend = -1\n\ndb = analytical_db; freq = analytical_freq\n\nloc1 = find(db, -1)\nloc3 = find(db, -3)\nlocMax = find(db, 100)\nlocMin = find(db[:int(len(db)/4)], -1000)\n\naxCurr.plot(freq, db)\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\n\n\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", \n                                   (    freq[loc1],                db[loc1]))\n\naxCurr.scatter(freq[loc3], db[loc3], c='blue')\naxCurr.annotate(f\"   Cutoff Freq: \\n({freq[loc3]/1e6:0.2f} MHz, {db[loc3]:0.2f} dB)\", \n                                     (freq[loc3],                db[loc3]) )\n\nmaxLine = np.ones(len(db)) * freq[locMax]\ntoPeak = np.linspace(min(db), db[locMax], len(db))\naxCurr.plot(maxLine, toPeak, c=\"red\")\naxCurr.scatter(freq[locMax], db[locMax], c='red')\naxCurr.annotate(f\"Maximum Attenuation: \\n({freq[locMax]/1e6:0.2f} MHz, {db[locMax]:0.2f} dB)\", \n                                   (    freq[locMax] * 14/16,  -5 ), color=\"red\" , rotation='vertical')\n\n\nminLine = np.ones(len(db)) * freq[locMin]\ntoMinPeak = np.linspace(min(db), db[locMin], len(db))\naxCurr.plot(minLine, toMinPeak, c=\"orange\")\naxCurr.scatter(freq[locMin], db[locMin], c='orange')\naxCurr.annotate(f\"Minimum Attenuation: \\n({freq[locMin]/1e6:0.2f} MHz, {db[locMin]:0.2f} dB)\", \n                                   (    freq[locMin] * 17/16,  -10 ), color=\"orange\" , rotation='vertical')\n\n\n## 0, 1 -&gt; idealized components\naxCurr = axes[0][1]\naxCurr.set_title(\"Magnitude of Ideal Component Simulated Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\ndb = s21_IdealSim.s_db[:,0,0]\nfreq = s21_IdealSim.f\n\ns21_IdealSim.plot_s_db(ax=axCurr, color=\"red\", linewidth=2)\n\nloc1 = find(db, -1)\nloc3 = find(db, -3)\nlocMax = find(db, 100)\nlocMin = find(db[:int(len(db)/4)], -1000)\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", (freq[loc1], db[loc1]))\naxCurr.scatter(freq[loc3], db[loc3], c='blue')\naxCurr.annotate(f\"   Cutoff Freq: \\n({freq[loc3]/1e6:0.2f} MHz, {db[loc3]:0.2f} dB)\", (freq[loc3], db[loc3]) )\n\nmaxLine = np.ones(len(db)) * freq[locMax]\ntoPeak = np.linspace(min(db), db[locMax], len(db))\naxCurr.plot(maxLine, toPeak, c=\"red\")\naxCurr.scatter(freq[locMax], db[locMax], c='red')\naxCurr.annotate(f\"Maximum Attenuation: \\n({freq[locMax]/1e6:0.2f} MHz, {db[locMax]:0.2f} dB)\", \n                                   (    freq[locMax] * 14/16,  -5 ), color=\"red\" , rotation='vertical')\n\nminLine = np.ones(len(db)) * freq[locMin]\ntoMinPeak = np.linspace(min(db), db[locMin], len(db))\naxCurr.plot(minLine, toMinPeak, c=\"orange\")\naxCurr.scatter(freq[locMin], db[locMin], c='orange')\naxCurr.annotate(f\"Minimum Attenuation: \\n({freq[locMin]/1e6:0.2f} MHz, {db[locMin]:0.2f} dB)\", \n                                   (    freq[locMin] * 17/16,  -10 ), color=\"orange\" , rotation='vertical')\n\n\n## 1, 0 -&gt; real simulated components\naxCurr = axes[1][0]\naxCurr.set_title(\"Magnitude of Real Components Simulated Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\ndb = s21_RealSim.s_db[:,0,0]\nfreq = s21_RealSim.f\n\ns21_RealSim.plot_s_db(ax=axCurr, color=\"orange\", linewidth=2)\n\nloc1 = find(db, -1)\nloc3 = find(db, -3)\nlocMax = find(db, 100)\nlocMin = find(db[:int(len(db)/4)], -1000)\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", \n                                   ( freq[loc1], db[loc1]))\n\naxCurr.scatter(freq[loc3], db[loc3], c='blue')\naxCurr.annotate(f\"   Cutoff Freq: \\n({freq[loc3]/1e6:0.2f} MHz, {db[loc3]:0.2f} dB)\", \n                                     (freq[loc3],                db[loc3]) )\n\nmaxLine = np.ones(len(db)) * freq[locMax]\ntoPeak = np.linspace(min(db), db[locMax], len(db))\naxCurr.plot(maxLine, toPeak, c=\"red\")\naxCurr.scatter(freq[locMax], db[locMax], c='red')\naxCurr.annotate(f\"Maximum Attenuation: \\n({freq[locMax]/1e6:0.2f} MHz, {db[locMax]:0.2f} dB)\", \n                                   (    freq[locMax] * 14.7/16,  -5 ), color=\"red\" , rotation='vertical')\n\n\nminLine = np.ones(len(db)) * freq[locMin]\ntoMinPeak = np.linspace(min(db), db[locMin], len(db))\naxCurr.plot(minLine, toMinPeak, c=\"orange\")\naxCurr.scatter(freq[locMin], db[locMin], c='orange')\naxCurr.annotate(f\"Minimum Attenuation: \\n({freq[locMin]/1e6:0.2f} MHz, {db[locMin]:0.2f} dB)\", \n                                   (    freq[locMin] * 17/16,  -10 ), color=\"orange\" , rotation='vertical')\n\n## 1, 1 -&gt; lab data\naxCurr = axes[1][1]\naxCurr.set_title(\"Magnitude of Measured S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\nreal_data_21.plot_s_db(ax=axCurr, color=\"green\", linewidth=2)\n\ndb = real_data_21.s_db[:,0,0]\nfreq = real_data_21.f\n\nloc1 = find(db[int(len(db)/10):], -1) + int(len(db)/10)\nloc3 = find(db, -3)\nlocMax = find(db, 100)\nlocMin = find(db[:int(len(db)/4)], -1000)\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", \n                                   (    freq[loc1],                db[loc1]))\n\naxCurr.scatter(freq[loc3], db[loc3], c='blue')\naxCurr.annotate(f\"   Cutoff Freq: \\n({freq[loc3]/1e6:0.2f} MHz, {db[loc3]:0.2f} dB)\", \n                                     (freq[loc3],                db[loc3]) )\n\nmaxLine = np.ones(len(db)) * freq[locMax]\ntoPeak = np.linspace(min(db), db[locMax], len(db))\naxCurr.plot(maxLine, toPeak, c=\"red\")\naxCurr.scatter(freq[locMax], db[locMax], c='red')\naxCurr.annotate(f\"Maximum Attenuation: \\n({freq[locMax]/1e6:0.2f} MHz, {db[locMax]:0.2f} dB)\", \n                                   (    freq[locMax] * 14/16,  -5 ), color=\"red\" , rotation='vertical')\n\n\nminLine = np.ones(len(db)) * freq[locMin]\ntoMinPeak = np.linspace(min(db), db[locMin], len(db))\naxCurr.plot(minLine, toMinPeak, c=\"orange\")\naxCurr.scatter(freq[locMin], db[locMin], c='orange')\naxCurr.annotate(f\"Minimum Attenuation: \\n({freq[locMin]/1e6:0.2f} MHz, {db[locMin]:0.2f} dB)\", \n                                   (    freq[locMin] * 17/16,  -10 ), color=\"orange\" , rotation='vertical')\n\nText(46707500.0, -10, 'Minimum Attenuation: \\n(43.96 MHz, -1.02 dB)')\n\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots(1,1, figsize=[15,10])\nplt.rcParams['font.size'] = 15\n\n ################################## 0, 0 -&gt; analytical ################################\naxCurr = ax\naxCurr.set_title(\"Magnitude of Analytical Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Phase (Degrees)\")\nend = -1\n\ndb = analytical_db; freq = analytical_freq; deg = s21_AnalyticalSim.s_deg[:,0,0]\n\nloc1 = find(db, -1)\nloc3 = find(db, -3)\nlocMax = find(db, 100)\nlocMin = find(db[:int(len(db)/4)], -1000)\n\nline1 = axCurr.plot(freq, deg, label=\"Analytical Simulation\")\n\nplt.rcParams['font.size'] = 14\n# axCurr.scatter(freq[loc1], deg[loc1], c='blue')\n# s21_AnalyticalSim.plot_s_deg(ax=axCurr, color=\"blue\", linewidth=2)\n\n\n ################################## 0, 1 -&gt; idealized components ################################\naxCurr = ax\naxCurr.set_title(\"Magnitude of Ideal Component Simulated Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\ndb = s21_IdealSim.s_db[:,0,0]\nfreq = s21_IdealSim.f\ndeg = s21_IdealSim.s_deg[:,0,0]\n\nline2 = s21_IdealSim.plot_s_deg(ax=axCurr, color=\"red\", linewidth=2, label=\"Ideal Components\")\n\nloc1 = find(db, -1)\nloc3 = find(db, -3)\nlocMax = find(db, 100)\nlocMin = find(db[:int(len(db)/4)], -1000)\n\n\naxCurr.scatter(freq[loc3], deg[loc3], c='red', s=100)\naxCurr.annotate(f\"   Cutoff Freq: \\n({freq[loc3]/1e6:0.2f} MHz, {deg[loc3]:0.2f}º)\", \n                                     (freq[loc3] * 7.5/8,    deg[loc3] * 7.2/8) , color=\"red\")\n\n\n ################################## 1, 0 -&gt; real simulated components ################################\naxCurr = ax\naxCurr.set_title(\"Magnitude of Real Components Simulated Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\ndb = s21_RealSim.s_db[:,0,0]\nfreq = s21_RealSim.f\ndeg = s21_RealSim.s_deg[:,0,0]\n\nline3 = s21_RealSim.plot_s_deg(ax=axCurr, color=\"orange\", linewidth=2, label=\"Real Value Simulated Components\")\n\nloc1 = find(db, -1)\nloc3 = find(db, -3)\nlocMax = find(db, 100)\nlocMin = find(db[:int(len(db)/4)], -1000)\n\n\naxCurr.scatter(freq[loc3], deg[loc3], c='orange', s=100)\naxCurr.annotate(f\"   Cutoff Freq: \\n({freq[loc3]/1e6:0.2f} MHz, {deg[loc3]:0.2f}º)\", \n                                     (freq[loc3] * 7/8,    6/8 * deg[loc3]), color=\"orange\" )\n\n ################################## 1, 1 -&gt; lab data ################################\naxCurr = ax\naxCurr.set_title(\"Phase of S21 at Three Different Values\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\nline4 = real_data_21.plot_s_deg(ax=axCurr, color=\"green\", linewidth=2, label=\"Real Measurements\")\n\ndb = real_data_21.s_db[:,0,0]\nfreq = real_data_21.f\ndeg = real_data_21.s_deg[:,0,0]\n\nloc1 = find(db[int(len(db)/10):], -1) + int(len(db)/10)\nloc3 = find(db, -3)\nlocMax = find(db, 100)\nlocMin = find(db[:int(len(db)/4)], -1000)\n\naxCurr.scatter(freq[loc1], deg[loc1], c='green', s=100)\naxCurr.annotate(f\"   Cutoff Freq: \\n({freq[loc3]/1e6:0.2f} MHz, {deg[loc3]:0.2f}º)\", \n                                     (freq[loc3] * 6.5/8,   9/8*deg[loc3]), color=\"green\" )\n\n\nText(78325000.0, -189.6991730668151, '   Cutoff Freq: \\n(96.40 MHz, -168.62º)')\n\n\n\n\n\n\n\n\n\n\nanalytical_freq, analytical_db = buildAtt(0, 300e6)\ns21_AnalyticalSim = rf.Network(frequency = analytical_freq, s = analytical_db)\n\nanalytical_freq = analytical_freq/(2*np.pi)\nanalytical_db = -analytical_db\n\nEpsilon  0.34931140018894796\n\n\n\nfilename = \"dp1_1_to_300M.txt\"\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\ns21_IdealSim = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])\n\n\nfilename = \"dp1_0to300M_real.txt\"\n\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\ns21_RealSim = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])\n\n\ncsv10 = pd.read_csv('CSV10.csv', skiprows=13)\ncsv10.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv10['Z_n'] = csv10['Z_Real']/50 + 1j*csv10['Z_Imag']/50\ncsv10['S_21'] = ( csv10['Z_n']-1 ) / ( csv10['Z_n']+1 )\nreal_data_21 = rf.Network(frequency = csv10['Frequency'], s = csv10['S_21'], m=0, n=0)\n\n\nprint(csv10['S_21'])\n\n0      0.991975-0.016237j\n1      0.988340-0.022850j\n2      0.989480-0.039872j\n3      0.988569-0.047667j\n4      0.986244-0.059877j\n              ...        \n745    0.004045+0.011138j\n746    0.004102+0.011102j\n747    0.003906+0.010960j\n748    0.004084+0.011052j\n749    0.004021+0.010935j\nName: S_21, Length: 750, dtype: complex128\n\n\n\nfig, axes = plt.subplots(2,2, figsize=[15,10])\naxes[0][0].set_xscale(\"log\")\naxes[0][1].set_xscale(\"log\")\naxes[1][0].set_xscale(\"log\")\naxes[1][1].set_xscale(\"log\")\n\n############################# 0, 0 -&gt; analytical #############################\naxCurr = axes[0][0]\naxCurr.set_title(\"Magnitude of Analytical Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Magnitude (dB)\")\nend = -1\n\ndb = analytical_db; freq = analytical_freq\n\ninsertionLoss = db[0]\ninsertion_line = insertionLoss * np.ones(len(db))\naxCurr.plot(freq, insertion_line, c=\"black\")\naxCurr.annotate(f\"   Insertion Loss: ({insertionLoss:0.2f} dB)\", (0.001*freq[loc1]*10,  -3), color=\"black\")\n\nloc1 = find(db, -1)\nloc3 = find(db, -3)\nloc20 = find(db, -20)\n\nprint(\"Cutoff: \", freq[loc3])\n\nprint(\"0, 0: Max-Min:\", db[find(db, 100)]-db[find(db[:int(len(db)/4)], -1e10)], \"Insertion: \", db[0])\naxCurr.plot(freq, db)\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", \n                                   (    0.02 *freq[loc3],       4 * db[loc3]))\n\naxCurr.scatter(freq[loc20], db[loc20], c='blue')\naxCurr.annotate(f\"   Stopband Freq: \\n({freq[loc20]/1e6:0.2f} MHz, {db[loc20]:0.2f} dB)\", \n                                     (0.02 * freq[loc20],          9/8 * db[loc20]) )\n\naxes[0][0].set_xscale(\"log\")\n\n############################# 0, 1 -&gt; idealized components #############################\naxCurr = axes[0][1]\naxCurr.set_title(\"Magnitude of Ideal Component Simulated Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\ndb = s21_IdealSim.s_db[:,0,0]\nfreq = s21_IdealSim.f\n\ns21_IdealSim.plot_s_db(ax=axCurr, color=\"red\", linewidth=2)\n\nloc1 = find(db, -1)\nloc3 = find(db, -3)\nloc20 = find(db, -20)\n\nprint(\"Cutoff: \", freq[loc3])\n\nprint(\"0, 0: Max-Min:\", db[find(db, 100)]-db[find(db[:int(len(db)/4)], -1e10)], \"Insertion: \", db[0])\n\ninsertionLoss = db[0]\ninsertion_line = insertionLoss * np.ones(len(db))\naxCurr.plot(freq, insertion_line, c=\"black\")\naxCurr.annotate(f\"   Insertion Loss: ({insertionLoss:0.2f} dB)\", (1e-6*freq[loc1],  -3), color=\"black\")\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", \n                                   (    freq[loc1]* 0.02/4,     4 * db[loc1]))\n\naxCurr.scatter(freq[loc20], db[loc20], c='blue')\naxCurr.annotate(f\"   Stopband Freq: \\n({freq[loc20]/1e6:0.2f} MHz, {db[loc20]:0.2f} dB)\", \n                                     (freq[loc20] * 0.01/4,                db[loc20]) )\n\n############################# 1, 0 -&gt; real simulated components #############################\naxCurr = axes[1][0]\naxCurr.set_title(\"Magnitude of Real Components Simulated Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\ndb = s21_RealSim.s_db[:,0,0]\nfreq = s21_RealSim.f\n\ns21_RealSim.plot_s_db(ax=axCurr, color=\"orange\", linewidth=2)\n\nloc1 = find(db, -1)\nloc3 = find(db, -3)\nloc20 = find(db, -20)\n\nprint(\"Cutoff: \", freq[loc3])\n\nprint(\"0, 0: Max-Min:\", db[find(db, 100)]-db[find(db[:int(len(db)/4)], -1e10)], \"Insertion: \", db[0])\n\ninsertionLoss = db[0]\ninsertion_line = insertionLoss * np.ones(len(db))\naxCurr.plot(freq, insertion_line, c=\"black\")\naxCurr.annotate(f\"   Insertion Loss: ({insertionLoss:0.2f} dB)\", (1e-8*freq[loc3],  -3), color=\"black\")\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", \n                                   (    freq[loc1]* 0.005/4,     4 * db[loc1]))\n\naxCurr.scatter(freq[loc20], db[loc20], c='blue')\naxCurr.annotate(f\"   Stopband Freq: \\n({freq[loc20]/1e6:0.2f} MHz, {db[loc20]:0.2f} dB)\", \n                                     (freq[loc20] * 0.001/4,                db[loc20]) )\n\n\n############################# 1, 1 -&gt; lab data #############################\naxCurr = axes[1][1]\naxCurr.set_title(\"Magnitude of Measured S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\nreal_data_21.plot_s_db(ax=axCurr, color=\"green\", linewidth=2)\n\ndb = real_data_21.s_db[:,0,0]\nfreq = real_data_21.f\n\nloc1 = find(db[int(len(db)/10):], -1) + int(len(db)/10)\nloc3 = find(db, -3)\nloc20 = find(db, -20)\n\nprint(\"Cutoff: \", freq[loc3])\n\nprint(\"0, 0: Max-Min:\", db[find(db, 100)]-db[find(db[:int(len(db)/4)], -1e10)], \"Insertion: \", real_data_21.s_db[:,0,0][0])\n\ninsertionLoss = db[0]\ninsertion_line = insertionLoss * np.ones(len(db))\naxCurr.plot(freq, insertion_line, c=\"black\")\naxCurr.annotate(f\"   Insertion Loss: ({insertionLoss:0.2f} dB)\", (0.001*freq[loc1]*10,  -3), color=\"black\")\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", \n                                   (    freq[loc1]* 0.9/4,     4 * db[loc1]))\n\naxCurr.scatter(freq[loc20], db[loc20], c='blue')\naxCurr.annotate(f\"   Stopband Freq: \\n({freq[loc20]/1e6:0.2f} MHz, {db[loc20]:0.2f} dB)\", \n                                     (freq[loc20] * 0.6/4,                db[loc20]) )\n\nCutoff:  99956499.95649996\n0, 0: Max-Min: 0.4999990511340464 Insertion:  -0.0\nCutoff:  100330033.668862\n0, 0: Max-Min: 0.49092962564262177 Insertion:  -8.68584255884301e-05\nCutoff:  96939693.9694646\n0, 0: Max-Min: 0.6381058895463632 Insertion:  -0.23157802098913333\nCutoff:  96467870.0\n0, 0: Max-Min: 0.9154496682728998 Insertion:  -0.06881931174276346\n\n\nText(25386540.0, -20.008790200904443, '   Stopband Freq: \\n(169.24 MHz, -20.01 dB)')"
  },
  {
    "objectID": "projects/radio_frequency/projects/designProjec1_Plotting.html#calculate-s11-of-the-analytical-model",
    "href": "projects/radio_frequency/projects/designProjec1_Plotting.html#calculate-s11-of-the-analytical-model",
    "title": "Setting all Required Values",
    "section": "Calculate S11 of the Analytical Model",
    "text": "Calculate S11 of the Analytical Model\nS_21^2 + S_11^2 = 1; in a lossless circuit, then, the value of S_11 = sqrt(1 - S_21^2)\nhttps://www.edaboard.com/threads/convert-s11-into-s21-graph-for-filter-passband-sweeps.349264/\n\nf_11, analytical_model_11 = buildAtt(0, 300e6)\n\nEpsilon  0.34931140018894796\n\n\n\nfilename = \"dp1_1_to_300M.txt\"\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\ns11_IdealSim = rf.Network(frequency = f_arr, s = svals_arr[:,0,0])\n\n\nfilename = \"dp1_0to300M_real.txt\"\n\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\ns11_RealSim = rf.Network(frequency = f_arr, s = svals_arr[:,0,0])\n\n\ncsv6 = pd.read_csv('CSV9.csv', skiprows=13)\ncsv6.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv6['Z_n'] = csv6['Z_Real']/50 + 1j*csv6['Z_Imag']/50\ncsv6['S_21'] = ( csv6['Z_n']-1 ) / ( csv6['Z_n']+1 )\nreal_data_11 = rf.Network(frequency = csv6['Frequency'], s = csv6['S_21'])\n\n\ndef getOneAtt(w):\n\n    freq_cutoff = 100e6\n    omega_cutoff = freq_cutoff * 2 * np.pi\n    pb_allowable_ripple = 0.5 # 1dB of allowable ripple in the passband\n    \n    epsilon = np.sqrt( np.pow(10, pb_allowable_ripple / 10) - 1)\n    print(\"Epsilon \", epsilon)\n    \n    n = 3 # order that we're using\n    \n    B = 1/n * np.arccosh(1/epsilon)\n    inv_ratio = (w/omega_cutoff) * np.cosh(B) # (w/wc)'\n\n    attenuation = 10 * np.log10(1 + np.power(epsilon, 2) * np.power( C_3(inv_ratio), 2)  )\n    return attenuation\n\n\nfig, axes = plt.subplots(2,2, figsize=[15,10])\naxes[0][0].set_xscale(\"log\")\naxes[0][1].set_xscale(\"log\")\naxes[1][0].set_xscale(\"log\")\naxes[1][1].set_xscale(\"log\")\n\n############################# 0, 0 -&gt; analytical #############################\naxCurr = axes[0][0]\naxCurr.set_title(\"Magnitude of Analytical Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Magnitude (dB)\")\nend = -1\n\ns21_linear = np.power(10, -analytical_model_11)\nprint(s21_linear)\ns11_linear = np.sqrt(np.square(1) - np.square(s21_linear))\ns11_vals = 10 * np.log(s11_linear)\n\nfreq = analytical_freq\n\nanalytical_loc_pb = find(analytical_db, -1) # finds for s21\nanalytical_loc_stop = find(analytical_db, -20)\n\naxCurr.plot(freq, s11_vals)\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[analytical_loc_pb], s11_vals[analytical_loc_pb], c='blue')\naxCurr.annotate(f\"   Passband Freq: ({freq[analytical_loc_pb]/1e6:0.2f} MHz, {s11_vals[analytical_loc_pb]:0.2f} dB)\", \n                                   (  0.0005 * freq[analytical_loc_pb],   0.9 * s11_vals[analytical_loc_pb]), color=\"blue\")\n\naxCurr.scatter(freq[analytical_loc_stop], s11_vals[analytical_loc_stop], c='orange')\naxCurr.annotate(f\"   Stopband Freq: \\n({freq[analytical_loc_stop]/1e6:0.2f} MHz, {s11_vals[analytical_loc_stop]:0.2f} dB)\", \n                                     ( freq[analytical_loc_stop],          -50), color=\"orange\", rotation=\"vertical\")\n\naxes[0][0].set_xscale(\"log\")\n\n############################# 0, 1 -&gt; idealized components #############################\naxCurr = axes[0][1]\naxCurr.set_title(\"Magnitude of Ideal Component Simulated Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\ndb = s11_IdealSim.s_db[:,0,0]\nfreq = s11_IdealSim.f\n\ns11_IdealSim.plot_s_db(ax=axCurr, color=\"red\", linewidth=2)\n\ns21_ideal = s21_IdealSim.s_db[:,0,0]\nloc1 = find(s21_ideal, -1)\nloc3 = find(s21_ideal, -3)\nloc20 = find(s21_ideal, -20)\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(                         freq[loc1],                 db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, { db[loc1]:0.2f} dB)\", \n                                   (    freq[loc1] * 0.01/4,  1.6 *  db[loc1]), color=\"blue\")\n\naxCurr.scatter(freq[loc20], db[loc20], c='orange')\naxCurr.annotate(f\"   Stopband Freq: \\n({freq[loc20]/1e6:0.2f} MHz, {db[loc20]:0.2f} dB)\", \n                                     (freq[loc20] * 0.01/4,      0.7e2 * db[loc20]), color=\"orange\")\n\n############################ 1, 0 -&gt; real world components #############################\naxCurr = axes[1][0]\naxCurr.set_title(\"Magnitude of Real Component Simulated Model S21\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\ndb = s11_RealSim.s_db[:,0,0]\nfreq = s11_RealSim.f\n\ns11_RealSim.plot_s_db(ax=axCurr, color=\"orange\", linewidth=2)\n\ns21_real = s21_RealSim.s_db[:,0,0]\nloc1 = find(s21_RealSim.s_db[:,0,0], -1)\nloc3 = find(s21_RealSim.s_db[:,0,0], -3)\nloc20 = find(s21_RealSim.s_db[:,0,0], -20)\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", \n                                   ( 0.0001 * freq[loc1],  db[loc1]), color=\"blue\")\n\naxCurr.scatter(freq[loc20], db[loc20], c='orange')\naxCurr.annotate(f\"   Stopband Freq: \\n({freq[loc20]/1e6:0.2f} MHz, {db[loc20]:0.2f} dB)\", \n                                     (freq[loc20] * 0.0005,     25 *  db[loc20]), color=\"orange\" )\n\n############################# 1, 1 -&gt; lab data #############################\naxCurr = axes[1][1]\naxCurr.set_title(\"Magnitude of Measured S11\")\naxCurr.set_xlabel(\"Frequency (Hz)\")\naxCurr.set_ylabel(\"Attenuation (dB)\")\n\nreal_data_11.plot_s_db(ax=axCurr, color=\"green\", linewidth=2)\n\ndb = real_data_11.s_db[:,0,0]\nfreq = real_data_11.f\n\nrdb_21 = real_data_21.s_db[:,0,0]\nloc1 = find(rdb_21[int(len(rdb_21)/10):], -1) + int(len(rdb_21)/10)\nloc3 = find(rdb_21, -3)\nloc20 = find(rdb_21, -20)\n\n\nplt.rcParams['font.size'] = 8\naxCurr.scatter(freq[loc1], db[loc1], c='blue')\naxCurr.annotate(f\"   Passband Freq: \\n({freq[loc1]/1e6:0.2f} MHz, {db[loc1]:0.2f} dB)\", \n                                   (  0.5 * freq[loc1],    1.3 * db[loc1]), color=\"blue\")\n\naxCurr.scatter(freq[loc20], db[loc20], c='orange')\naxCurr.annotate(f\"   Stopband Freq: \\n({freq[loc20]/1e6:0.2f} MHz, {db[loc20]:0.2f} dB)\", \n                                     (freq[loc20] * 0.6/4,            3 * db[loc20]), color=\"orange\" )\n\n[1.00000000e+00 1.00000000e+00 9.99999999e-01 ... 9.52455850e-36\n 9.52396242e-36 9.52336638e-36]\n\n\n/var/folders/rj/sr4h5_xd2g9bw0xqc0qk5wm40000gn/T/ipykernel_47897/4037145578.py:17: RuntimeWarning: divide by zero encountered in log\n  s11_vals = 10 * np.log(s11_linear)\n\n\nText(25386540.0, -1.1675073608352342, '   Stopband Freq: \\n(169.24 MHz, -0.39 dB)')\n\n\n\n\n\n\n\n\n\n\ncsv6 = pd.read_csv('CSV10.csv', skiprows=13)\ncsv6.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\nprint(min(csv6['Frequency'])/1e6)\n\n0.4998667\n\n\n\nfilename = \"dp1_1_to_300M.txt\"\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\nsmith_11_IdealSim = rf.Network(frequency = f_arr, s = svals_arr[:,0,0])\nsmith_21_IdealSim = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])\n\n\nfilename = \"dp1_0to300M_real.txt\"\n\nfrequency_arr = []\ns_arr = []\n\nwith open(filename, 'r') as input_file:\n    line_array = input_file.readlines()\n\n    # Change first line to s1p format\n    line_array[0] = \"# MHz S MA R 50\"\n\n    j = 0\n    # LTspice exports with commas, change to spaces\n    for idx, line in enumerate(line_array[1:]):\n        line_array[idx] = line.replace(\",\", \" \")\n        \n        arr = [float(x) for x in line_array[idx].split()]\n        \n        frequency_arr.append(arr[0])\n        \n        s_arr.append([[arr[1]+1j*arr[2], arr[3]+1j*arr[4]],\n                      [arr[5]+1j*arr[6], arr[7]+1j*arr[8]]])\n\nf_arr = np.array(frequency_arr)\nsvals_arr = np.array(s_arr)\n\nsmith_11_RealSim = rf.Network(frequency = f_arr, s = svals_arr[:,0,0])\nsmith_21_RealSim = rf.Network(frequency = f_arr, s = svals_arr[:,1,0])\n\n\ncsv_s11 = pd.read_csv('CSV9.csv', skiprows=13)\ncsv_s11.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv_s11['Z_n'] = csv_s11['Z_Real']/50 + 1j*csv_s11['Z_Imag']/50\ncsv_s11['S_21'] = ( csv_s11['Z_n']-1 ) / ( csv_s11['Z_n']+1 )\nreal_data_11 = rf.Network(frequency = csv_s11['Frequency'], s = csv_s11['S_21'])\n\ncsv_s21 = pd.read_csv('CSV10.csv', skiprows=13)\ncsv_s21.columns = ['Frequency', 'Z_Real', 'Z_Imag', 'components', 'H']\ncsv_s21['Z_n'] = csv_s21['Z_Real']/50 + 1j*csv_s21['Z_Imag']/50\ncsv_s21['S_21'] = ( csv_s21['Z_n']-1 ) / ( csv_s21['Z_n']+1 )\nreal_data_21 = rf.Network(frequency = csv_s21['Frequency'], s = csv_s21['S_21'], m=0, n=0)\n\n\nfig, axes = plt.subplots(3,2, figsize=[20,30])\nplt.rcParams['font.size'] = 15\n\n############################# 0, 0 -&gt; ideal #############################\naxCurr = axes[0,0]\naxCurr.set_title(\"S11 Smith Chart, Ideal Components\")\n\nsmith_11_IdealSim.plot_s_smith(ax=axCurr, draw_labels=True, color='r', linewidth=4)\n\n############################# 0, 0 -&gt; analytical #############################\naxCurr = axes[0,1]\naxCurr.set_title(\"S21 Smith Chart, Ideal Components\")\n\nsmith_21_IdealSim.plot_s_smith(ax=axCurr, draw_labels=True, color='b', linewidth=4)\n\n############################# 0, 0 -&gt; real #############################\naxCurr = axes[1,0]\naxCurr.set_title(\"S11 Smith Chart, Real Simulated Components\")\n\nsmith_11_RealSim.plot_s_smith(ax=axCurr, draw_labels=True, color='r', linewidth=4)\n\n############################# 0, 0 -&gt; analytical #############################\naxCurr = axes[1,1]\naxCurr.set_title(\"S21 Smith Chart, Real Simulated Components\")\n\nsmith_21_RealSim.plot_s_smith(ax=axCurr, draw_labels=True, color='b', linewidth=4)\n\n############################# 0, 0 -&gt; ideal #############################\naxCurr = axes[2,0]\naxCurr.set_title(\"S11 Smith Chart, Measurements\")\n\nreal_data_11.plot_s_smith(ax=axCurr, draw_labels=True, color='r', linewidth=4)\n\n############################# 0, 0 -&gt; analytical #############################\naxCurr = axes[2,1]\naxCurr.set_title(\"S21 Smith Chart, Measurements\")\n\nreal_data_21.plot_s_smith(ax=axCurr, draw_labels=True, color='b', linewidth=4)"
  },
  {
    "objectID": "projects/radio_frequency/projects/Lab6_PythonFile.html",
    "href": "projects/radio_frequency/projects/Lab6_PythonFile.html",
    "title": "Theory Question 4",
    "section": "",
    "text": "Compare computed results to “what you expect” (I.E. Hand Calculations)\nFFT annotated with important extracted values (i.e. signal and noise) for each step\nRepresent the power in each FFT bin, not fft coefficients, in units of dBm.\n\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\n\n\n## make the initial plot\nnum_cycles = 20.0  # cycles\nfrequency  = 20e3  # Hz\npower_dBm  = 0     # dBm\nZ_l        = 50    # Ohms\nf_sampling = 2e6   # Hz\nnoise_v    = 10e-3 # V\n\nnum_samples_period = int(f_sampling/frequency)\nnum_samples_total  = int(num_cycles * num_samples_period)\n\npower_mW   = np.pow(10, power_dBm/10)    # mW\nvoltage = np.sqrt(power_mW * 1e-3 * Z_l)   # V\n\nsample_times = np.linspace(0.0, 1.0, num_samples_total)\n\nsample_phases = np.linspace(0.0, 2*np.pi*20, num_samples_total)\nvoltage_wave = voltage*np.sin(sample_phases)\n\nplt.plot(sample_times, voltage_wave)\n\n\n\n\n\n\n\n\n\n## add noise to the signal\n\nreal_wave = [ v + np.random.normal(loc=v, scale=noise_v) for v in voltage_wave]\n\nplt.plot(sample_times[:300], real_wave[:300])\nplt.ylabel(\"Voltage [V]\")\nplt.xlabel(\"Time [s]\")\n\nText(0.5, 0, 'Time [s]')\n\n\n\n\n\n\n\n\n\n\ndef create_real_wave(freq, fs, voltage, cycles, white_noise):\n    num_samples_period = int(fs/freq)\n    num_samples_total  = int(cycles * num_samples_period)\n    sample_times = np.linspace(0.0, 1.0, num_samples_total)\n    sample_phases = np.linspace(0.0, 2*np.pi*cycles, num_samples_total)\n    voltage_wave = voltage*np.sin(sample_phases)\n    real_wave = [ v + np.random.normal(loc=v, scale=white_noise) for v in voltage_wave]\n\n    fig, axs = plt.subplots(1, 2, figsize=(50, 10))\n    axs[0].plot(sample_phases, voltage_wave)\n    axs[1].plot(sample_phases, real_wave)\n\n    return real_wave\n\n\nreal_wave = create_real_wave(20e3, 2e6, voltage, 20, 10e-3)\n\n\n\n\n\n\n\n\n\npower_real_wave = [v**2 * Z_l for v in real_wave] # W\npower_real_wave = 10 * np.log10(power_real_wave)  # dBm\nplt.plot(power_real_wave[0:300])\n\n\n\n\n\n\n\n\n\nfrom scipy.fft import fft, ifft, fftshift\n# used http://blog.dddac.com/noise-floor-and-s-n-ratio-in-and-with-fft-graphs/\n\n## reassigning the number of points to the number of bins\nnum_bins = num_samples_total\nfreqPlot = fft(real_wave, num_bins)  # power is in dBm\n\n\nbin_width = f_sampling / len(freqPlot)   # (np.max(np.abs(freqPlot)) - np.min(np.abs(freqPlot)))/num_bins\nnumber_bins = len(freqPlot)\nprint(f\"Bin Width is {bin_width} Hz\")\nprint(f\"There are {number_bins} bins\")\n\nsample_wavenum =   np.linspace(int(-len(freqPlot)/2), int(len(freqPlot)/2 - 1), len(freqPlot))\nsample_freq    = [k*bin_width/2 for k in sample_wavenum]\n# sample_freq    = [k*int(f_sampling/(2*len(freqPlot))) for k in sample_wavenum]\n\nfig, axs2 = plt.subplots(2, 1, figsize=(5, 5))\naxs2[0].plot(sample_freq, np.abs(fftshift(freqPlot)))\naxs2[1].stem(sample_freq[0:400], np.abs(fftshift(freqPlot))[0:400])\naxs2[1].grid()\n\nprint(f\"Recalculating Bin Width: {f_sampling/(len(freqPlot)*2)}\")\n\nBin Width is 1000.0 Hz\nThere are 2000 bins\nRecalculating Bin Width: 500.0\n\n\n\n\n\n\n\n\n\n\n## Part B - Convert to 8-Bit ADC with max at 5A\n\ndef create_ADC_wave_pre_amp(freq, fs, voltage, cycles, white_noise, scaling):\n    num_samples_period = int(fs/freq)\n    num_samples_total  = int(cycles * num_samples_period)\n    sample_times = np.linspace(0.0, 1.0, num_samples_total)\n    sample_phases = np.linspace(0.0, 2*np.pi*cycles, num_samples_total)\n    voltage_wave = voltage*np.sin(sample_phases)\n\n    real_wave = []\n    print(real_wave)\n    for i in voltage_wave:\n        if i &lt; voltage * -3.0/4:\n            # print(i, \" lowest\")\n            real_wave.append(scaling*0)\n        elif i &lt; voltage * -2.0/4:\n            # print(i, \" sec lowest\")\n            real_wave.append(scaling*1.0/8)\n        elif i &lt; voltage * -1.0/4:\n            # print(i, \" third lowest\")\n            real_wave.append(scaling*2.0/8)\n        elif i &lt; voltage * 0:\n            # print(i, \" mid\")\n            real_wave.append(scaling*3.0/8)\n        elif i &lt; voltage * 1.0/4:\n            # print(i, \" third highest\")\n            real_wave.append(scaling*4.0/8)\n        elif i &lt; voltage * 2.0/4:\n            # print(i, \" sec highest\")\n            real_wave.append(scaling*5.0/8)\n        elif i &lt; voltage * 3.0/4:\n            # print(i, \" highest\")\n            real_wave.append(scaling*6.0/8)\n        else:\n            # print(i, \" real high\")\n            real_wave.append(scaling*7.0/8)\n\n    real_wave = [ (v + np.random.normal(loc=v, scale=white_noise)) for v in real_wave]\n\n    fig, axs = plt.subplots(1, 2, figsize=(50, 10))\n    axs[0].plot(sample_phases, voltage_wave)\n    axs[1].plot(sample_phases, real_wave, '-o')\n\n    return real_wave\n\n## Part C - Convert to 8-Bit ADC with max at 5A\n\ndef create_ADC_wave_post_amp(freq, fs, voltage, cycles, white_noise, scaling):\n    num_samples_period = int(fs/freq)\n    num_samples_total  = int(cycles * num_samples_period)\n    sample_times = np.linspace(0.0, 1.0, num_samples_total)\n    sample_phases = np.linspace(0.0, 2*np.pi*cycles, num_samples_total)\n    voltage_wave = scaling*voltage*np.sin(sample_phases)\n\n    real_wave = []\n    print(real_wave)\n    for i in voltage_wave:\n        if i &lt; scaling*voltage * -3.0/4:\n            # print(i, \" lowest\")\n            real_wave.append(0)\n        elif i &lt; scaling*voltage * -2.0/4:\n            # print(i, \" sec lowest\")\n            real_wave.append(1.0/8)\n        elif i &lt; scaling*voltage * -1.0/4:\n            # print(i, \" third lowest\")\n            real_wave.append(2.0/8)\n        elif i &lt; scaling*voltage * 0:\n            # print(i, \" mid\")\n            real_wave.append(3.0/8)\n        elif i &lt; scaling*voltage * 1.0/4:\n            # print(i, \" third highest\")\n            real_wave.append(4.0/8)\n        elif i &lt; scaling*voltage * 2.0/4:\n            # print(i, \" sec highest\")\n            real_wave.append(5.0/8)\n        elif i &lt; scaling*voltage * 3.0/4:\n            # print(i, \" highest\")\n            real_wave.append(6.0/8)\n        else:\n            # print(i, \" real high\")\n            real_wave.append(7.0/8)\n\n    real_wave = [ (v + np.random.normal(loc=v, scale=white_noise)) for v in real_wave]\n\n    fig, axs = plt.subplots(1, 2, figsize=(50, 10))\n    axs[0].plot(sample_phases, voltage_wave)\n    axs[1].plot(sample_phases, real_wave, '-o')\n\n    return real_wave\n\n\nadc_wav_b = create_ADC_wave_pre_amp(20000, 1000000, voltage, 20, 10e-3, 5)\nadc_wav_c = create_ADC_wave_post_amp(20000, 1000000, voltage, 20, 10e-3, 5)\n\n[]\n[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npower_adc_wave_b = [v**2 * Z_l for v in adc_wav_b] # W\npower_adc_wave_b = 10 * np.log10(power_adc_wave_b)  # dBm\nplt.plot(power_adc_wave_b[0:300])\n\npower_adc_wave_c = [v**2 * Z_l for v in adc_wav_c] # W\npower_adc_wave_c = 10 * np.log10(power_adc_wave_c)  # dBm\nplt.plot(power_adc_wave_c[0:300])\n\n\n\n## reassigning the number of points to the number of bins\nnum_bins = num_samples_total\nadc_fft_plot_b = fft(adc_wav_b, num_bins)  # power is in dBm\n\nnum_bins = num_samples_total\nadc_fft_plot_c = fft(adc_wav_c, num_bins)  # power is in dBm\n\n###\n\nbin_width = f_sampling / len(adc_fft_plot_b)   # (np.max(np.abs(freqPlot)) - np.min(np.abs(freqPlot)))/num_bins\nnumber_bins = len(adc_fft_plot_b)\nprint(f\"Bin Width is {bin_width} Hz\")\nprint(f\"There are {number_bins} bins\")\n\nbin_width = f_sampling / len(adc_fft_plot_c)   # (np.max(np.abs(freqPlot)) - np.min(np.abs(freqPlot)))/num_bins\nnumber_bins = len(adc_fft_plot_c)\nprint(f\"Bin Width is {bin_width} Hz\")\nprint(f\"There are {number_bins} bins\")\n\n\n\nsample_wavenum_b =   np.linspace(int(-len(adc_fft_plot_b)/2), int(len(adc_fft_plot_b)/2 - 1), len(adc_fft_plot_b))\nsample_freq    = [k*bin_width/2 for k in sample_wavenum]\n# sample_freq    = [k*int(f_sampling/(2*len(freqPlot))) for k in sample_wavenum]\n\nfig, axs2 = plt.subplots(2, 1, figsize=(5, 5))\naxs2[0].plot(sample_freq, np.abs(fftshift(adc_fft_plot_b)))\naxs2[1].stem(sample_freq[100:200], np.abs(fftshift(adc_fft_plot_b))[100:200])\naxs2[1].grid()\n\nprint(f\"Recalculating Bin Width: {f_sampling/(len(adc_fft_plot_b)*2)}\")\n\n\n\nsample_wavenum =   np.linspace(int(-len(adc_fft_plot_c)/2), int(len(adc_fft_plot_c)/2 - 1), len(adc_fft_plot_c))\nsample_freq    = [k*bin_width/2 for k in sample_wavenum]\n# sample_freq    = [k*int(f_sampling/(2*len(freqPlot))) for k in sample_wavenum]\n\nfig, axs2 = plt.subplots(2, 1, figsize=(5, 5))\naxs2[0].plot(sample_freq, np.abs(fftshift(adc_fft_plot_c)))\naxs2[1].stem(sample_freq[100:200], np.abs(fftshift(adc_fft_plot_c))[100:200])\naxs2[1].grid()\n\nprint(f\"Recalculating Bin Width: {f_sampling/(len(adc_fft_plot_c)*2)}\")\n\nBin Width is 1000.0 Hz\nThere are 2000 bins\nBin Width is 1000.0 Hz\nThere are 2000 bins\nRecalculating Bin Width: 500.0\nRecalculating Bin Width: 500.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Comparing Real Signal and ADC Signal (i.e. looking at impact of quantization)\n\nfig, axs2 = plt.subplots(2, 3, figsize=(16, 7))\naxs2[0][0].plot(sample_freq, np.abs(fftshift(freqPlot)))\naxs2[0][0].set_title(\"FFT Plot\")\n# axs2[0][0].set_ylim([0,17500])\n\naxs2[1][0].stem(sample_freq[0:400], np.abs(fftshift(freqPlot))[0:400])\naxs2[1][0].set_title(\"Zoom on FFT Plot\")\n# axs2[1][0].set_ylim([0,800])\n\naxs2[0][1].plot(sample_freq, np.abs(fftshift(adc_fft_plot_b)))\naxs2[0][1].set_title(\"FFT Plot with ADC\")\n# axs2[0][1].set_ylim([0,17500])\n\naxs2[1][1].stem(sample_freq[0:400], np.abs(fftshift(adc_fft_plot_b))[0:400])\naxs2[1][1].set_title(\"Zoom on FFT Plot with ADC\")\n\n\naxs2[0][2].plot(sample_freq, np.abs(fftshift(adc_fft_plot_c)))\naxs2[0][2].set_title(\"FFT Plot with ADC post 5 V\")\n# axs2[0][2].set_ylim([0,17500])\n\naxs2[1][2].stem(sample_freq[0:400], np.abs(fftshift(adc_fft_plot_c))[0:400])\naxs2[1][2].set_title(\"Zoom on FFT Plot with ADC post 5 V\")\n\n\n# axs2.grid()\n\nText(0.5, 1.0, 'Zoom on FFT Plot with ADC post 5 V')\n\n\n\n\n\n\n\n\n\n\nPlot Time Vs RBW/VBW\n\ncenter_freq = 2.4e9       # Hz\nrbw = [1e6, 300e3, 30e3]  # rate bandwidth\nvbw = [1e6, 300e3, 30e3]  # video bandwidth\nsweep_time = [14.43e-3, 10e-3, 26.03e-3] # seconds\nspan = [400, 40, 4]\navg_noise_lvl = [-50, -60, -70]\n\nfig, axs = plt.subplots(1, 3, figsize=(20, 2))\naxs[0].plot(rbw, sweep_time)\naxs[0].set_title(\"Ratio RBW/VBW=1, RBW vs Time\")\naxs[0].set_xlabel(\"RBW\")\naxs[0].set_ylabel(\"Sweep Time (s)\")\n\naxs[1].plot(avg_noise_lvl, sweep_time)\naxs[1].set_title(\"Avg Noise Level (dBm) vs Sweep Time (s)\")\naxs[1].set_xlabel(\"Average Noise Level (dBm)\")\naxs[1].set_ylabel(\"Sweep Time (s)\")\n\naxs[2].plot(span, sweep_time)\naxs[2].set_title(\"Avg Noise Level (dBm) vs Sweep Time (s)\")\naxs[2].set_xlabel(\"Span [dBm]\")\naxs[2].set_ylabel(\"Sweep Time (s)\")\n\nText(0, 0.5, 'Sweep Time (s)')\n\n\n\n\n\n\n\n\n\n\nrbw =        [10,    30,      100,   300,   1e3, 3e3,   10e3,  30e3, 100e3, 300e3, 1e6]\nsweep_time = [321600, 110900, 36130, 14000, 550, 215.4, 85.12, 16.03,   10,    10,  10]\nsweep_time = [i*1e-3 for i in sweep_time]\navg_noise =  [-100, -100,     -90,   -87,  -85, -80,    -80,   -70,    -65,   -60, -50]\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 2))\naxs[0].plot(rbw, sweep_time)\naxs[0].set_title(\"Ratio RBW/VBW=1, RBW vs Time\")\naxs[0].set_xlabel(\"RBW\")\naxs[0].set_xscale(\"log\")\naxs[0].set_ylabel(\"Sweep Time (s)\")\naxs[0].set_yscale(\"log\")\n\n# fitted = np.polyfit(rbw, sweeptime\n\naxs[1].plot(avg_noise, sweep_time)\naxs[1].set_title(\"Avg Noise Level (dBm) vs Sweep Time (s)\")\naxs[1].set_xlabel(\"Average Noise Level (dBm)\")\naxs[1].set_yscale(\"log\")\naxs[1].set_ylabel(\"Sweep Time (s)\")\n\nText(0, 0.5, 'Sweep Time (s)')\n\n\n\n\n\n\n\n\n\n\n\nfig, axs = plt.subplots(1, 1, figsize=(10, 2))\nslp_1b, int_1b = np.polyfit(np.log(sweep_time), np.log(rbw), 1)\npoints = np.linspace(10, 1000000, 1000)\ngg = [np.exp(int_1b + slp_1b*np.log(i)) for i in points]\n\n# print(gg)\naxs.plot(points, gg, 'bo-')\naxs.plot(rbw, sweep_time, 'ro-')\naxs.set_title(\"Ratio RBW/VBW=1, RBW vs Time\")\naxs.set_xlabel(\"RBW\")\naxs.set_xscale(\"log\")\naxs.set_ylabel(\"Sweep Time (s)\")\naxs.set_yscale(\"log\")\n\nprint(slp_1b)\nprint(int_1b)\n\n-0.9191863612715845\n7.547308909146294\n\n\n\n\n\n\n\n\n\n\n#ratio rbw to vbw\nvbw_r30k = [3e3, 10e3, 100e3, 300e3]\nsweep_time_r30k = [141.6e-3, 42.76e-3, 16.03e-3, 16.03e-3]\n\nrbw_v3k = [10e3, 30e3, 100e3, 300e3]\nsweep_time_v3k = [227.1e-3, 141.6e-3, 53.11e-3, 31.87e-3]\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 2))\naxs[0].plot(sweep_time_r30k, vbw_r30k)\naxs[0].plot(sweep_time_v3k, rbw_v3k)\n\n\n\n\n\n\n\n\n\n#ratio rbw to vbw\nvbw_r30k = [3e3, 10e3, 100e3, 300e3]\nsweep_time_r30k = [141.6e-3, 42.76e-3, 16.03e-3, 16.03e-3]\n\nvbw_r30k_vtr = [i/30e3 for i in vbw_r30k]\n\nrbw_v3k = [10e3, 30e3, 100e3, 300e3]\nsweep_time_v3k = [227.1e-3, 141.6e-3, 53.11e-3, 31.87e-3]\n\nrbw_v3k_vtr = [3e3/i for i in rbw_v3k]\n\nprint(vbw_r30k_vtr)\nprint(rbw_v3k_vtr)\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 2))\naxs[0].plot(sweep_time_r30k, vbw_r30k_vtr)\naxs[0].plot(sweep_time_v3k, rbw_v3k_vtr)\n\ncombined = np.concatenate((vbw_r30k_vtr, rbw_v3k_vtr), axis=0)\nsorted_indices = np.argsort(combined)\ncombined_sorted = combined[sorted_indices]\n\ncombined_time = np.concatenate((sweep_time_r30k, sweep_time_v3k), axis=0)\nsorted_indices_time = np.argsort(combined_time)\ncombined_time_sorted = combined_time[sorted_indices_time]\n\n# print(sorted_indices_time)\n\naxs[1].plot(combined_time_sorted, combined_sorted, 'ro-')\n\n[0.1, 0.3333333333333333, 3.3333333333333335, 10.0]\n[0.3, 0.1, 0.03, 0.01]\n\n\n\n\n\n\n\n\n\n\nrbw_1b = [10e3,10,30,100,300,1e3,3e3,30e3,100e3,300e3,1e6,30e3,30e3,30e3,30e3,10e3,30e3,100e3,300e3,1e6,300e3,30e3] # db\nvbw_1b = [10e3,10,30,100,300,1e3,3e3,30e3,100e3,300e3,1e6,100e3,300e3,10e3,3e3,3e3,3e3,3e3,3e3,1e6,300e3,30e3] # db\nsweep_time_1b = [85.12, 321600,110900,36130,14000,550,215.4,16.03,10,10,10,16.03,16.03,42.76,141.6,227.1,141.6,53.11,31.87, 14.43,10,26.03]\n\ndata = np.zeros([10000, 10000])\n# for i in range(len(rbw_1b)):\n#     print(np.log10(rbw_1b))\n\n# Create the colorplot\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.scatter(rbw_1b, vbw_1b, c=sweep_time_1b, norm=\"log\", edgecolors=\"none\")\nplt.colorbar()\nplt.xlabel(\"RBW (Hz)\")\nplt.ylabel(\"VBW (Hz)\")\nplt.title(\"VBW vs RBW, Sweep Time Colormap\")\nplt.show()\n\n\n\n\n\n\n\n\n\nrbw_1b_1 = rbw_1b[15:19]\nvbw_1b_1 = vbw_1b[11:15]\n\nplt.plot(sweep_time_1b[11:15], vbw_1b_1, 'ro-')\n\nplt.xlabel(\"Sweep Time\")\nplt.ylabel(\"VBW\")\nplt.title(\"Plot of VBW vs Sweep Time (RBW = 30kHz)\")\nplt.yscale(\"log\")\n\nlinear_fit_vbw_sweeptime = np.polyfit(sweep_time_1b[11:15], np.log10(vbw_1b_1), 1)\nslp_1b_VvT, in_1b_VvT = linear_fit_vbw_sweeptime\npoints = np.linspace(0, 300, 1000)\nlinFit = [in_1b_VvT + slp_1b_VvT*i for i in points]\n\n\n\n\n\n\n\n\n\nplt.plot(points, np.pow(10, linFit))\nplt.plot(sweep_time_1b[11:15], vbw_1b_1, \"ro-\")\n\n\nprint(\"Slope: \", slp_1b_VvT, \"Intercept: \", in_1b_VvT)\n\nSlope:  -0.013110472149667589 Intercept:  5.197902723017598\n\n\n\n\n\n\n\n\n\n\nrbw_1b_2 = rbw_1b[15:19]\n\nplt.plot(sweep_time_1b[15:19], rbw_1b_2, 'go-')\nplt.xlabel(\"Sweep Time\")\nplt.ylabel(\"RBW\")\nplt.title(\"Plot of RBW vs Sweep Time (VBW = 3kHz)\")\nplt.yscale(\"log\")\n\nprint(sweep_time_1b[15:19])\n\nlinear_fit_rbw_sweeptime = np.polyfit(sweep_time_1b[15:19], np.log10(rbw_1b_2), 1)\nslp_1b_RvT, in_1b_RvT = linear_fit_rbw_sweeptime\npoints = np.linspace(0, 300, 1000)\nlinFit = [in_1b_RvT + slp_1b_RvT*i for i in points]\n\n[227.1, 141.6, 53.11, 31.87]\n\n\n\n\n\n\n\n\n\n\nplt.plot(points, np.pow(10, linFit))\nplt.plot(sweep_time_1b[15:19], rbw_1b_2)\nprint(\"Slope: \", slp_1b_RvT, \"Intercept: \", in_1b_RvT)\n\nSlope:  -0.006970393092468513 Intercept:  5.529142611907611\n\n\n\n\n\n\n\n\n\n\n# st_r30k_log = [i for i in vbw_r30k]\nst_v3k_log = [np.log(i) for i in rbw_v3k]\n\n[slope2, slope, interc] = np.polyfit(sweep_time_r30k, np.log(vbw_r30k), 2)\npolyfitted_r30k = [ interc + slope*i + slope2*i**2 for i in sweep_time_r30k]\npolyfitted_v3k = [ interc + slope*i + slope2*i**2 for i in sweep_time_v3k]\n\nplt.plot(sweep_time_r30k, polyfitted_r30k)\nplt.plot(sweep_time_r30k, np.log(vbw_r30k))\nplt.plot(sweep_time_v3k, polyfitted_v3k)\nplt.plot(sweep_time_v3k, np.log(rbw_v3k))\n\n\n\n\n\n\n\n\n\n## with a 30 dB Attenuation\n\natten_3a = 30\nin_pow_3a = [-78, -68, -58, -48,-38,-28,-20,-18,-17,-16,-15,-14,-13,-12,-11]\nout_pow_3a = [-77.5,-67.7,-57.5,-47.6,-37.4,-27.36,-19.5,-17.55,-16.62,-15.71,-14.81,-13.88,-13.14,-12.51,-12.04]\n\nout_pow_noatten_3a = [i + atten_3a for i in out_pow_3a]\n\n## Gain equation given by P_out - P_in + Attenuation\n\ngain_3a = []\nfor i in range(len(in_pow_3a)):\n    val = out_pow_3a[i] - in_pow_3a[i] + atten_3a\n    gain_3a.append(val)\n    # print(out_pow_3a[i])\n    # print(val)\n    # print(in_pow_3a[i], '\\n')\n\nplt.plot(in_pow_3a, out_pow_3a)\n\n\n\n\n\n\n\n\n\n## 3a polyfit and finding what happens at P = -1 dB\nplt.plot(in_pow_3a, out_pow_3a, 'ro-', label=\"Measured Values\")\n\n[slope_3a, interc_3a] = np.polyfit(in_pow_3a, out_pow_3a, 1)\n\nin_pow_3a_polyfit = in_pow_3a\nin_pow_3a_polyfit.append(-1)\npolyfit_3a = [interc_3a + slope_3a*i for i in in_pow_3a_polyfit]\nplt.plot(in_pow_3a_polyfit, polyfit_3a, 'go--', alpha=0.5, label=\"Fitted Line for Input to Power\")\n\nprint(in_pow_3a_polyfit[-1], \" \", polyfit_3a[-1])\n\nplt.xlabel(\"Input Power (dB)\") ## is it dB or dBm???\nplt.ylabel(\"Output Power (dB)\")\nplt.title(\"Input Power vs Output Power, 600 MHz Signal\")\n\nplt.xlim([-15, -10])\nplt.ylim([-16, -11])\n\nplt.legend()\n\n-1   -1.0662265753215467\n\n\n\n\n\n\n\n\n\n\n\n## with a 30 dB Attenuation\n\natten_3a = 30\nin_pow_3a = [-78, -68, -58, -48,-38,-28,-20,-18,-17,-16,-15,-14,-13,-12,-11]\nout_pow_3a = [-77.5,-67.7,-57.5,-47.6,-37.4,-27.36,-19.5,-17.55,-16.62,-15.71,-14.81,-13.88,-13.14,-12.51,-12.04]\n\nout_pow_noatten_3a = [i + atten_3a for i in out_pow_3a]\n\n## Gain equation given by P_out - P_in + Attenuation\n\ngain_3a = []\nfor i in range(len(in_pow_3a)):\n    val = out_pow_3a[i] - in_pow_3a[i] + atten_3a\n    gain_3a.append(val)\n    # print(out_pow_3a[i])\n    # print(val)\n    # print(in_pow_3a[i], '\\n')\n\n# plt.plot(in_pow_3a, out_pow_3a)\n\n\n\n\n## 3a polyfit and finding what happens at P = -1 dB\n\n[slope_3a, interc_3a] = np.polyfit(in_pow_3a, out_pow_3a, 1)\npolyfit_3a_x2 = [interc_3a + slope_3a*i for i in in_pow_3a]\n\ndiff = [polyfit_3a_x2[i] - out_pow_3a[i] for i in range(len(out_pow_3a))]\n[quad_3a_x2, slope_3a_x2, interc_3a_x2] = np.polyfit(in_pow_3a, diff, 2)\n\npoints = np.linspace(-15, 10, 20)\nmatched_diff = [ quad_3a_x2*i**2 + slope_3a_x2*i + interc_3a_x2 for i in points]\n\nplt.plot(in_pow_3a, out_pow_3a)\nplt.plot(in_pow_3a, polyfit_3a_x2)\nplt.plot(points, matched_diff, 'ro-')\nplt.xlabel(\"Input Power\")\nplt.ylabel(\"Output Power\")\nplt.title(\"Graph of Likely Difference Between Planned slope and the Slope of the Curved Value\")\n\nText(0.5, 1.0, 'Graph of Likely Difference Between Planned slope and the Slope of the Curved Value')\n\n\n\n\n\n\n\n\n\n\n## 3a, looking only at the region around -15 to -11\n\nin_pow_3a_curved  = in_pow_3a[-9:-1]\nout_pow_3a_curved = out_pow_3a[-9:-1]\n\n\n# converting from dB to mW so that I can do some fun log scale things\nin_pow_3a_curved = [np.pow(10, i/10) for i in in_pow_3a_curved]\nout_pow_3a_curved = [np.pow(10, i/10) for i in out_pow_3a_curved]\n\n# continuing as usual\n\n\n[slope_3a_curved, interc_3a_curved] = np.polyfit(np.log10(in_pow_3a_curved), out_pow_3a_curved, 1)\n\nin_pow_3a_curved_polyfit = [i for i in in_pow_3a_curved]\nin_pow_3a_curved_polyfit.append(0.1) # power -1 dB means that we have 10*(-1/10) which means log10(x/1mW), x = 0.1 mW\n\npolyfit_3a_curved = [interc_3a_curved + slope_3a_curved*i for i in np.log10(in_pow_3a_curved_polyfit)]\n\nplt.plot(np.log10(in_pow_3a_curved), out_pow_3a_curved, 'ro-', label=\"Measured Data Points\")\nplt.plot(np.log10(in_pow_3a_curved_polyfit), polyfit_3a_curved, 'go--', alpha=0.5, label=\"Fitted Line for Input to Power\")\nprint(np.log10(in_pow_3a_curved_polyfit[-1]), ' ', polyfit_3a_curved[-1])\n\nplt.xlabel(\"Log of Input Power (mW)\")\nplt.ylabel(\"Output Power (dB)\")\nplt.title(\"Logarithmic Comparison to Find Output Power at -1 dB\")\nplt.legend()\n\n-1.0   0.06053390606272718\n\n\n\n\n\n\n\n\n\n\n# plotting difference between linear and logarithmic slope\n\npoints_for_compare = np.linspace(-1, 6, 100)\nlin_val = [interc_3a + slope_3a*i for i in points_for_compare]\n\ndiff_val = []\n\nfor i in range(len(polyfit_3a_curved)):\n    diff_val.append(polyfit_3a_curved[i] - (interc_3a + slope_3a*in_pow_3a_curved_polyfit[i]))\n\nplt.plot(in_pow_3a_curved_polyfit, diff_val)\nplt.plot(in_pow_3a_curved_polyfit, [interc_3a + slope_3a*i for i in in_pow_3a_curved_polyfit])\n# plt.plot(in_pow_3a_curved_polyfit[0:8], out_pow_3a[-9:-1])\n\n\n\n\n\n\n\n\n\naverage_dif = \n\n\n## 3b - Defining IIP1, IIP2, IIP3\n\n## IIP1\natten_3b_iip1 = [30,30,30,30,30,30]\nin_pow_3b_iip1 = [-58,-48,-38,-28,-20,-18]\nout_pow_3b_iip1 = [-60.5,-50.5,-40.6,-30.5,-22.6,-20.8]\niip1_3b_no_atten = []\nfor i in range(len(out_pow_3b_iip1)):\n    iip1_3b_no_atten.append(out_pow_3b_iip1[i] + atten_3b_iip1[i])\nplt.plot(in_pow_3b_iip1, iip1_3b_no_atten)\n\n## IIP2\natten_3b_iip2 = [30,30,30,30,30]\nin_pow_3b_iip2 = [-18,-19,-20,-21,-23]\nout_pow_3b_iip2_mid_peak = [-54.36,-56.65,-58.4,-61.11,-65.81]\niip2_3b_no_atten = []\nfor i in range(len(out_pow_3b_iip2_mid_peak)):\n    iip2_3b_no_atten.append(out_pow_3b_iip2_mid_peak[i] + atten_3b_iip2[i])\nplt.plot(in_pow_3b_iip2, iip2_3b_no_atten)\n\n## IIP3\natten_3b_iip3 = [30, 30, 10, 10, 10, 0, 0]\nin_pow_3b_iip3 = [-18, -19, -20, -22, -25, -30, -32]\nout_pow_3b_iip3_2f1_1f2 = [-61.31, -65.89, -48.5, -54.6, -63.63, -66, -68.5]\nout_pow_3b_iip3_1f1_2f2 = [-61.3, -65.37, -48.3, -54.5, -63.6, -66.2, -69.1]\nout_pow_3b_iip3_avg = [(out_pow_3b_iip3_2f1_1f2[i]+out_pow_3b_iip3_1f1_2f2[i])/2 for i in range(len(out_pow_3b_iip3_2f1_1f2))]\niip3_3b_no_atten = []\nfor i in range(len(out_pow_3b_iip3_avg)):\n    iip3_3b_no_atten.append(out_pow_3b_iip3_avg[i] + atten_3b_iip3[i])\nplt.plot(in_pow_3b_iip3, iip3_3b_no_atten)\n\n\n## Getting Polyfits for the IIPx Values\n[slp_3b_1, ic_3b_1] = np.polyfit(in_pow_3b_iip1, iip1_3b_no_atten,1)\n[slp_3b_2, ic_3b_2] = np.polyfit(in_pow_3b_iip2, iip2_3b_no_atten,1)\n[slp_3b_3, ic_3b_3] = np.polyfit(in_pow_3b_iip3, iip3_3b_no_atten,1)\n\npoints = np.linspace(-60, 35, 1000000)\npolyfit_3b_iip1 = [ic_3b_1 + slp_3b_1*p for p in points]\npolyfit_3b_iip2 = [ic_3b_2 + slp_3b_2*p for p in points]\npolyfit_3b_iip3 = [ic_3b_3 + slp_3b_3*p for p in points]\n\nplt.plot(points, polyfit_3b_iip1, alpha=0.5)\nplt.plot(points, polyfit_3b_iip2, alpha=0.5)\nplt.plot(points, polyfit_3b_iip3, alpha=0.5)\nplt.plot(in_pow_3b_iip1, iip1_3b_no_atten)\nplt.plot(in_pow_3b_iip2, iip2_3b_no_atten)\nplt.plot(in_pow_3b_iip3, iip3_3b_no_atten)\n\nx_val_3b = (iip1_3b_no_atten[0] - slp_3b_1*in_pow_3b_iip1[0] - (iip3_3b_no_atten[0] - slp_3b_3*in_pow_3b_iip3[0]))/(slp_3b_3-slp_3b_1)\ny_val_3b = ic_3b_3 + slp_3b_3*x_val_3b\n\nplt.scatter(x_val_3b, y_val_3b, c='red', label=f\"IIP3 = ({x_val_3b:.2f}, {y_val_3b:.2f})\")\n\nx_val_3b_iip2 = (iip1_3b_no_atten[0] - slp_3b_1*in_pow_3b_iip1[0] - (iip2_3b_no_atten[0] - slp_3b_2*in_pow_3b_iip2[0]))/(slp_3b_2-slp_3b_1)\ny_val_3b_iip2 = ic_3b_3 + slp_3b_3*x_val_3b_iip2\nplt.scatter(x_val_3b_iip2, y_val_3b_iip2, c='blue', label=f\"IIP2 =  = ({x_val_3b_iip2:.2f}, {y_val_3b_iip2:.2f})\")\n\nplt.xlabel(\"input power (dB)\")\nplt.ylabel(\"output power - no attenuation (dB)\")\nplt.title(\"Locating IIP3 and IIP2 on Graph\")\nplt.legend()\n\n# print(x_val_3b, \" \", y_val_3b)\n# print(y_val_3b-30)\n# print(x_val_3b_iip2, \" \", y_val_3b_iip2)\n\n\n## 3d - Defining IIP1, IIP2, IIP3\n\n## IIP1\natten_3d_iip1 = [30,30,30,30,30]\nin_pow_3d_iip1 = [-50, -53, -55, -57, -58.2]\nout_pow_3d_iip1 = [-16, -16.96, -18.08, -19.66, -20.74]\niip1_3d_no_atten = []\nfor i in range(len(out_pow_3d_iip1)):\n    iip1_3d_no_atten.append(out_pow_3d_iip1[i] + atten_3d_iip1[i])\nplt.plot(in_pow_3d_iip1, iip1_3d_no_atten, label=\"First Harmonic\")\n\n## IIP3\natten_3d_iip3 = [30,30,30,30,30]\nin_pow_3d_iip3 = [-50, -53, -55, -57, -58.2]\nout_pow_3d_iip3 = [-31.6, -38.2, -45.8, -53.6, -58.3]\niip3_3d_no_atten = []\nfor i in range(len(out_pow_3d_iip1)):\n    iip3_3d_no_atten.append(out_pow_3d_iip3[i] + atten_3d_iip3[i])\nplt.plot(in_pow_3d_iip3, iip3_3d_no_atten, label=\"Third Harmonic\")\n\n## Getting Polyfits for the IIPx Values\n[slp_3d_1, ic_3d_1] = np.polyfit(in_pow_3d_iip1, iip1_3d_no_atten,1)\n[slp_3d_3, ic_3d_3] = np.polyfit(in_pow_3d_iip3, iip3_3d_no_atten,1)\n\npoints = np.linspace(-60, -30, 100000)\npolyfit_3d_iip1 = [ic_3d_1 + slp_3d_1*p for p in points]\npolyfit_3d_iip3 = [ic_3d_3 + slp_3d_3*p for p in points]\n\nplt.plot(points, polyfit_3d_iip1, alpha=0.5)\nplt.plot(points, polyfit_3d_iip3, alpha=0.5)\n\nx_val_3d = (iip1_3d_no_atten[0] - slp_3d_1*in_pow_3d_iip1[0] - (iip3_3d_no_atten[0] - slp_3d_3*in_pow_3d_iip3[0]))/(slp_3d_3-slp_3d_1)\ny_val_3d = ic_3d_3 + slp_3d_3*x_val_3d\nplt.scatter(x_val_3d, y_val_3d, c='red', label=f\"IIP3 = ({x_val_3d:.2f}, {y_val_3d:.2f})\")\n\nplt.title(\"Cascaded Amplifier IIP3 Calculation, No Attenuation\")\nplt.xlabel(\"Input Power (dB)\")\nplt.ylabel(\"Output Power (dB)\")\nplt.legend()\n\n\nnoise_value = power_real_wave / (bin_width/2 * np.ones(len(power_real_wave))) # noise value in dBm\n\nnoise_mW = [np.pow(10, n/10) for n in noise_value]\nnoisePower = np.sum(noise_mW)\n\n# noiseVoltage = np.sqrt(noisePower**2 * 4 * Z_l)\n\n# plt.plot(noise_value)\nprint(f\"Total Voltage: {np.sum(noiseVoltage)} V\")\n\n\n# https://www.ap.com/news/fft-scaling-for-noise\npower_spectral_density = [p**2 / (bin_width * 2.73) for p in power_wave]  ## 1.73 comes from a table for Blackman Harris 3-term\namplitude_spectral_density = np.sqrt(power_spectral_density)\n\nnoise_density = np.sqrt([(np.sum(psd_i * bin_width)) for psd_i in power_spectral_density])\ntotal_noise = np.sum(noise_density)\nprint(total_noise)"
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/lab1.html",
    "href": "projects/e-155_website/labs/lab1/lab1.html",
    "title": "Lab 1 Writeup",
    "section": "",
    "text": "Hours Spent: 21.3, Mapped with Toggl Track\n\n\nThe goal of this lab was to program an FPGA board to do two things: 1. Control a set of 3 on-board LEDs to follow XOR, AND, and clock counter logic 2. Control a seven-segment array using the E155 Breadboard Adapter v4 The clock was configured to run at 48MHz, and connected to an LED such that it blinked at ~2.4 Hz. Additional details about the first goal may be foudn in (Section 1.4).\n\n\n\nThe goal of this lab was initial setup and confirmation of FPGA control of on-board LEDs and attached GPIO pin. This was done through the control of three leds: D6, D7, and D8, as well as seven GPIO pins: 45, 3, 44, 9, 13, 12, and 20 through the readout of on-board 4-pin DIP switch.\n\n\nThe first stage of this lab involved the soldering of the MCU and the FPGA, as well as all additional SMD and THT pins. To do this, the E155 FA23 Development Board schematic was used. To begin, the SMD components were soldered. Careful consideration was given to make sure that the diodes were soldered in the right order and facing the correct direction. After these were soldered, THT components were then soldered, including the 4-pin DIP switch, the 8-pin DIP switch, and the female headers (Figure 1).\n\n\n\n\n\n\nFigure 1: SMD and THT pins soldered\n\n\n\nA board was connected via ribbon cable to the main Development board to allow for control of a breadboard via on-board GPIO pins (Figure 2). Once all pieces had been put together, the board was tested via a voltmeter via the screw terminal to ensure that the board could be properly powered (Figure 3)(Figure 4). The board through the screw terminal required +6 - +20 V; testing was done using 6V, and the board was confirmed to be running. The breadboard was tested using a multimeter to ensure that the 3.3V, 5.0V, and GND pins were properly generating the right voltage.\n\n\n\n\n\n\n\n\n\nFigure 2: Board assembled with ribbon cable\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Powering the board with the screw terminal at +6V\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: The Voltmeter while powering the screw terminal\n\n\n\n\n\nAll soldered pins and the required impedance values and relevant pin numbers can be found in the E155 FA23 Development Board pdf, linked in “Other Links” on this page. Once confirmation was had that the board was properly powering all pins using the screw terminal, the transition was then made to powering the board using both the MCU and the FPGA individually via a micro-USB cable.\nThe final schematic for this design can be seen below.\n\n\n\n\n\n\n\n\n\n\n\n\nWhen attaching the seven segment display, I took care to note the design specifications. My board was a common-anode, single-seven segment display, which means that it was a MAN6460 on the data sheet. All segments had a test operating current of 20mA, and a dynamic resistance of 26 ohms when running. Additionally, I found that the average test voltage drop across was 2.1 V; I did not want to design for the maximum voltage scenario (which was 2.8 V), as I’d rather avoid getting too close to any risk of burning the matrix out. Considering that the current draw ought to be 20 mA, and that the voltage drop across a given segment is 2.1 V, I know that the resistors have to remove 1.2V at 20mA of current; when calculating according to the equation V/I = R, this means that the final resistance ought to be about 60 ohms. For the sake of safety and with confirmation from Kavi, I used 220 ohm resistors to connect each of the cathodes of the board to their relative pins, and supplied both of the common anode pins with 3.3 V from the GPIO board. This means that each segment, when powered, has a current of 1.2/220 ohms or about 5 mA of current, which would map to 0.5 relative luminosity on their supplied data sheet (Figure 6)\n\n\n\n\n\n\n\n\n\nThis leads to the question of why I didn’t put a single resistor at the common anode, and chose instead to use seven different ones. The answer to this lies within the design constraints; we want each of the segments to light up equal amounts every time. If the resistor came before the diode’s power drop, the current through each diode would vary as the number of diodes lighting up varied. A very simple example can be seen with the setup seen in Figure 7.\n\n\n\n\n\n\n\n\n\nIf we compare A and B, we can see how the current through the diodes will differ between each situation. In case A, the one that I used, if one diode isn’t lit up, it has no impact on the current traveling through the other diode: in every case, the voltage drop will assuredly be either 0V or 2.1 V across a given diode, irrelevant to any other segment within this case. However in case B, the same can not be said. If two diodes are lit up, they will be using double the amount of current, and resultantly the voltage drop caused by the single resistor will double. This means that there will be a smaller voltage drop across the diodes, which means that the more segments that are lit up, the less bright the matrix will glow - if it glows at all. This is why all of the resistors were attached to each cathode in the final design, rather than one resistor being connected to the common anode.\nThe FPGA board maps to all pins starting with P; the MCU maps to all pins starting with PA. In order to accomplish the correct mapping, I drew a diagram (Figure 8) that mapped the pin number, the segment controlled, and then the GPIO pin I intended for each part of the device. I knew that seg[0] was assigned to segA, seg[6] to segG, etc., and resultantly I was able to make a basic table that I then implemented on my breadboard (Table 1)\n\n\n\n\n\n\n\n\n\n\n\n\nTable 1: Mapping of Pins to Segments\n\n\n\n\n\nsegment number\nGPIO Pin\n\n\n\n\n0\nP20\n\n\n1\nP12\n\n\n2\nP13\n\n\n3\nP45\n\n\n4\nP9\n\n\n5\nP44\n\n\n6\nP3\n\n\n\n\n\n\n\n\n\n\nI own a Mac computer, so I needed to go through a broad array of necessary preparation in order to begin generating the code for my computer. First, I installed SEGGER Embedded Studio 8.16a on my computer. Following the SEGGER Embedded Studio Tutorial, I confirmed that I was able to load designs onto my MCU board.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nUnfortunately, because I don’t have a Windows, it was necessary to run to the laboratory and use an actual Windows computer in order to install J-Link. The only thing you need to download is the third link on the download links, specifically the one called “SEGGER STLinkReflash utility”. You shouldn’t need to install anything additional, since the supplied boards already had J-Link installed.\n\n\nThe FPGA proved to be a little more difficult. This was a multiple step process, and required a bit of troubleshooting.\nFirst, I installed Parallels on my computer: I know that not everyone has $80 lined up to pay for a virtual Windows Machine. I recommend, if possible, use a student discount; when I got it, I managed to find a 50% student discount, which meant in the end I only spent $40. Parallels is one of the best ways to interact with your FPGA besides being in-lab, and I highly recommend it after using it for the past few days.\nOnce I had that downloaded, I installed Lattice Radiant for Windows 64 inside of the Parallels machine. In all, this process took me about two hours, so make sure to budget some time beforehand if you’re planning on doing this on a Mac. As noted by Professor Brake on his page explaining how to use Lattice Radiant, if you build a design within this program you won’t be able to run it like you would on a Windows, even if you are able to Synthesize the board. Instead, you need to go back to your home screen and find the correct pathing to the file on your Windows computer.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nNot many people seem to know this, but if you have a folder or file open in your File Manager, you can drag the file into an open terminal window in order to get the complete file path; I’m sure there are other ways to do this, but this is the fastest way for me to open most programs.\n\n\nAlthough you could run the same terminal code that Professor Brake advises, I personally have been using code given to my by Kavi Dey, which works better most of the time because I don’t need to figure out pathing to the .bin file on my computer. If you’re interested, follow this tutorial.\n\n\n\nBy the end of the laboratory, the three switches were controlled as defined as seen in Tables 1(a) and 1(b), and the seven segment LED matrix as defined in the set of tables below:\n\n\n\n\n\nTable 2: LED Logic for Table {#tbl-first}\n\n\n\n\n\n\n\n(a) LED 1 (D7)\n\n\n\n\n\ns[3]\ns[2]\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) LED 0 (D6)\n\n\n\n\n\ns[1]\ns[0]\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\n\n\n\n\n\nThe logic tables that were used for the led to switch mapping. Table 2 (a) refers to s[3] and s[2]; on the board, these are switches 1 and 2 (pins P32 and P31 respectively) to match where the highest order digits would be in a four digit number. By extensino, Table 2 (b) uses the two right-most switches (P35 and P32)\n\n\n\n\n\nTable 3: Seven Segment LED Matrix Logic\n\n\n\n\n\nSwitch Base 10 Value\nSeven Segment Display\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n2\n\n\n3\n3\n\n\n4\n4\n\n\n5\n5\n\n\n6\n6\n\n\n7\n7\n\n\n8\n8\n\n\n9\n9\n\n\n10\nA\n\n\n11\nB\n\n\n12\nC\n\n\n13\nD\n\n\n14\nE\n\n\n15\nF\n\n\n\n\n\n\nThe mapping from the decimal readout of the switches in hexadecimal.\n\n\nThese table, in turn, will follow the schematic drawing seen in Figure 5.\nThe lab is composed of three modules, one test bench, and one basic text file of test vectors. The modules are assumbled such that there is one for the combinational logic used for the LEDs called led_control.sv, and another that is used for the combinational logic of the seven segment array, called seven_segments.sv. The connection of these modules can be visualized in the block diagram below.\n\n\n\nIn this design approach, I noted that the led’s followed very basic boolean logic; LED 0 followed XOR logic with the lowest order two bits supplied by the DIP switch, and LED 1 followed AND logic with the two highest bits (see table in Section 1.4). LED 2 was very simple to program, as it followed similar logic to that used in the iCE_40.sv tutorial.\nResultantly, the led_control module consists of three assign statements. The first two are combination logic for XOR and AND gates. The final part takes in a counter input, and uses it to decide whether to turn on/off the LED based on its most prominent bit in a 2^24 bit counter.\n\n\n\nThe design approach for the seven segment array required some more thoughtful setup. First, I constructed a table for each of the 16 possible arrangements of the DIP switch. Following the general logic that 0 should be mapped to 0x0, 1 to 0x1, etc. etc. until 15 was mapped to 0xF, I then created a table Table 4 that mapped out which parts of the segment would need to turn on to display the correct number. This gave me a list of seven bits arrange in 16 ways, which I then used inside a case statement when assigning according to the decimal value held by the DIP switch. Note that in the following table, segA was seg[0], or the least significant bit of the seven_segment array inside of the module; I initially had an issue debugging where I reversed the values on accident, and it created some odd shapes on the seven-segment matrix.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\nTable 4: Table of Switches Mapped to Segments\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ns[3]\ns[2]\ns[2]\ns[0]\n0x___\nsegA\nsegB\nsegC\nsegD\nsegE\nsegF\nsegG\n\n\n\n\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n0\n0\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n\n\n0\n0\n1\n0\n2\n0\n0\n1\n0\n0\n1\n0\n\n\n0\n0\n1\n1\n3\n0\n0\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n0\n4\n1\n0\n0\n1\n1\n0\n0\n\n\n0\n1\n0\n1\n5\n0\n1\n0\n0\n1\n0\n0\n\n\n0\n1\n1\n0\n6\n0\n1\n0\n0\n0\n0\n0\n\n\n0\n1\n1\n1\n7\n0\n0\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n8\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n0\n0\n1\n9\n0\n0\n0\n0\n1\n0\n0\n\n\n1\n0\n1\n0\n“A”\n0\n0\n0\n1\n0\n0\n0\n\n\n1\n0\n1\n1\n“b”\n1\n1\n0\n0\n0\n0\n0\n\n\n1\n1\n0\n0\n“C”\n0\n1\n1\n0\n0\n0\n1\n\n\n1\n1\n0\n1\n“d”\n1\n0\n0\n0\n0\n1\n0\n\n\n1\n1\n1\n0\n“E”\n0\n1\n1\n0\n0\n0\n0\n\n\n1\n1\n1\n1\n“F”\n0\n1\n1\n1\n0\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\nIn all, the combinational logic for this program was very straight forward. The next challenge came when mapping pins to the GPIO pins, and subsequent mapping to each individual segment on the matrix. The two modules for controlling the LEDs and the seven-segment matrix were both placed into a module called “lab01.sv”. On a top layer, the Python file “top.sv” generated a clock using an instatiation of an HSOSC module, which it fed into an instance of lab01.\n\n\n\n\nTo confirm that the system worked, a very basic testbench was written that ran through every potential arrangement of the 4-Pin system, checking expected LED values and seven-segment outputs. The value of led[2] was ignored in this testbench, as it was assumed to be working given that it had worked in the previous lab, and is extremely difficult to check (with my current knowledge as of September 2024) within a Questa Testbench.\nWhen writing a testbench, I ran into several problems with using test vectors, to the point where I initially just wanted to program a for-loop to check my results. However, I realized after multiple hours of debugging and talking with Kavi that I had saved the file as the wrong type of text file, and resultantly my code couldn’t find the file (not for lack of me putting the textfile in every place)\n\n\n\n\n\n\nCan’t Find *.tv File\n\n\n\nBecause Windows doesn’t show the full extension, it wasn’t until I was looking through Windows via Terminal that I saw that the .tv file was, in fact, not a .tv file but a .tv.rtf file; this meant that when the program looked for the file that it wanted to run to test the vectors, it was unable to load it, even if the pathing to the text file was correct. Be very careful in Windows that the extension you see in the Finder window may not be the complete extension.\n\n\nThe final test bench that I made controlled the four bit input of the switches, and the cross checked the output of top with the values I knew ought to be in the led and seven segment array. The simulation takes a long time to run: I believe in order for it to complete all test vectors, I need to use the command run 1000000 (with six 0’s) in order to see the full thing and confirm that it is working. I removed $finish from the initial testbench file I was using as a baseline, as I wanted to be able to see the finished Waveform generator in Questa.\n\nThis final design meets all the requirements for this lab. The bits are arranged in increasing order, left to right, on the DIP switches, and correspond to the LED’s when everything is oriented the same way (i.e. the seven segment array is facing the correct direction, and the ribbon cable keeps everything close to the development board) without any twisting. Listing the requirements, and going over each one, we see that: 1. The development board is fully assembled and all its components are soldered. This was confirmed for the screw panel as well as the GPIO pins using a multimeter in lab. 2. There are three verilog modules written, one that serves at the top wrapper module, and two the serve to individually control the LEDs and control the 7-segment display 3. The FPGA has been programmed to run with this Verilog code. 4. The 7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF 5. All digits for the board are unique, with no repeats 6. The DIP switches are sequentially ordered, with P37 being the highest order and P32 the lowest. This is true for both the LED logic and the seven segment logic. 7. The LEDs display the specified logic operations properly. 8. I have provided calculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions, as 1.2V/220ohms = about 20 mA, which is within the device’s marked operating current. 9. I have generated a ModelSim (or specifically Questa) simulation with an automatic test bench that walks through each potential switch combination and ensures that the design is working properly. 10. Finally, I have performed the necessary calcualtions to ensure that all digits, specifically of the seven-segment array, are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "projects/e-155_website/labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "Lab 1 Writeup",
    "section": "",
    "text": "Hours Spent: 21.3, Mapped with Toggl Track\n\n\nThe goal of this lab was to program an FPGA board to do two things: 1. Control a set of 3 on-board LEDs to follow XOR, AND, and clock counter logic 2. Control a seven-segment array using the E155 Breadboard Adapter v4 The clock was configured to run at 48MHz, and connected to an LED such that it blinked at ~2.4 Hz. Additional details about the first goal may be foudn in (Section 1.4).\n\n\n\nThe goal of this lab was initial setup and confirmation of FPGA control of on-board LEDs and attached GPIO pin. This was done through the control of three leds: D6, D7, and D8, as well as seven GPIO pins: 45, 3, 44, 9, 13, 12, and 20 through the readout of on-board 4-pin DIP switch.\n\n\nThe first stage of this lab involved the soldering of the MCU and the FPGA, as well as all additional SMD and THT pins. To do this, the E155 FA23 Development Board schematic was used. To begin, the SMD components were soldered. Careful consideration was given to make sure that the diodes were soldered in the right order and facing the correct direction. After these were soldered, THT components were then soldered, including the 4-pin DIP switch, the 8-pin DIP switch, and the female headers (Figure 1).\n\n\n\n\n\n\nFigure 1: SMD and THT pins soldered\n\n\n\nA board was connected via ribbon cable to the main Development board to allow for control of a breadboard via on-board GPIO pins (Figure 2). Once all pieces had been put together, the board was tested via a voltmeter via the screw terminal to ensure that the board could be properly powered (Figure 3)(Figure 4). The board through the screw terminal required +6 - +20 V; testing was done using 6V, and the board was confirmed to be running. The breadboard was tested using a multimeter to ensure that the 3.3V, 5.0V, and GND pins were properly generating the right voltage.\n\n\n\n\n\n\n\n\n\nFigure 2: Board assembled with ribbon cable\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Powering the board with the screw terminal at +6V\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: The Voltmeter while powering the screw terminal\n\n\n\n\n\nAll soldered pins and the required impedance values and relevant pin numbers can be found in the E155 FA23 Development Board pdf, linked in “Other Links” on this page. Once confirmation was had that the board was properly powering all pins using the screw terminal, the transition was then made to powering the board using both the MCU and the FPGA individually via a micro-USB cable.\nThe final schematic for this design can be seen below.\n\n\n\n\n\n\n\n\n\n\n\n\nWhen attaching the seven segment display, I took care to note the design specifications. My board was a common-anode, single-seven segment display, which means that it was a MAN6460 on the data sheet. All segments had a test operating current of 20mA, and a dynamic resistance of 26 ohms when running. Additionally, I found that the average test voltage drop across was 2.1 V; I did not want to design for the maximum voltage scenario (which was 2.8 V), as I’d rather avoid getting too close to any risk of burning the matrix out. Considering that the current draw ought to be 20 mA, and that the voltage drop across a given segment is 2.1 V, I know that the resistors have to remove 1.2V at 20mA of current; when calculating according to the equation V/I = R, this means that the final resistance ought to be about 60 ohms. For the sake of safety and with confirmation from Kavi, I used 220 ohm resistors to connect each of the cathodes of the board to their relative pins, and supplied both of the common anode pins with 3.3 V from the GPIO board. This means that each segment, when powered, has a current of 1.2/220 ohms or about 5 mA of current, which would map to 0.5 relative luminosity on their supplied data sheet (Figure 6)\n\n\n\n\n\n\n\n\n\nThis leads to the question of why I didn’t put a single resistor at the common anode, and chose instead to use seven different ones. The answer to this lies within the design constraints; we want each of the segments to light up equal amounts every time. If the resistor came before the diode’s power drop, the current through each diode would vary as the number of diodes lighting up varied. A very simple example can be seen with the setup seen in Figure 7.\n\n\n\n\n\n\n\n\n\nIf we compare A and B, we can see how the current through the diodes will differ between each situation. In case A, the one that I used, if one diode isn’t lit up, it has no impact on the current traveling through the other diode: in every case, the voltage drop will assuredly be either 0V or 2.1 V across a given diode, irrelevant to any other segment within this case. However in case B, the same can not be said. If two diodes are lit up, they will be using double the amount of current, and resultantly the voltage drop caused by the single resistor will double. This means that there will be a smaller voltage drop across the diodes, which means that the more segments that are lit up, the less bright the matrix will glow - if it glows at all. This is why all of the resistors were attached to each cathode in the final design, rather than one resistor being connected to the common anode.\nThe FPGA board maps to all pins starting with P; the MCU maps to all pins starting with PA. In order to accomplish the correct mapping, I drew a diagram (Figure 8) that mapped the pin number, the segment controlled, and then the GPIO pin I intended for each part of the device. I knew that seg[0] was assigned to segA, seg[6] to segG, etc., and resultantly I was able to make a basic table that I then implemented on my breadboard (Table 1)\n\n\n\n\n\n\n\n\n\n\n\n\nTable 1: Mapping of Pins to Segments\n\n\n\n\n\nsegment number\nGPIO Pin\n\n\n\n\n0\nP20\n\n\n1\nP12\n\n\n2\nP13\n\n\n3\nP45\n\n\n4\nP9\n\n\n5\nP44\n\n\n6\nP3\n\n\n\n\n\n\n\n\n\n\nI own a Mac computer, so I needed to go through a broad array of necessary preparation in order to begin generating the code for my computer. First, I installed SEGGER Embedded Studio 8.16a on my computer. Following the SEGGER Embedded Studio Tutorial, I confirmed that I was able to load designs onto my MCU board.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nUnfortunately, because I don’t have a Windows, it was necessary to run to the laboratory and use an actual Windows computer in order to install J-Link. The only thing you need to download is the third link on the download links, specifically the one called “SEGGER STLinkReflash utility”. You shouldn’t need to install anything additional, since the supplied boards already had J-Link installed.\n\n\nThe FPGA proved to be a little more difficult. This was a multiple step process, and required a bit of troubleshooting.\nFirst, I installed Parallels on my computer: I know that not everyone has $80 lined up to pay for a virtual Windows Machine. I recommend, if possible, use a student discount; when I got it, I managed to find a 50% student discount, which meant in the end I only spent $40. Parallels is one of the best ways to interact with your FPGA besides being in-lab, and I highly recommend it after using it for the past few days.\nOnce I had that downloaded, I installed Lattice Radiant for Windows 64 inside of the Parallels machine. In all, this process took me about two hours, so make sure to budget some time beforehand if you’re planning on doing this on a Mac. As noted by Professor Brake on his page explaining how to use Lattice Radiant, if you build a design within this program you won’t be able to run it like you would on a Windows, even if you are able to Synthesize the board. Instead, you need to go back to your home screen and find the correct pathing to the file on your Windows computer.\n\n\n\n\n\n\nMac Users Aid\n\n\n\nNot many people seem to know this, but if you have a folder or file open in your File Manager, you can drag the file into an open terminal window in order to get the complete file path; I’m sure there are other ways to do this, but this is the fastest way for me to open most programs.\n\n\nAlthough you could run the same terminal code that Professor Brake advises, I personally have been using code given to my by Kavi Dey, which works better most of the time because I don’t need to figure out pathing to the .bin file on my computer. If you’re interested, follow this tutorial.\n\n\n\nBy the end of the laboratory, the three switches were controlled as defined as seen in Tables 1(a) and 1(b), and the seven segment LED matrix as defined in the set of tables below:\n\n\n\n\n\nTable 2: LED Logic for Table {#tbl-first}\n\n\n\n\n\n\n\n(a) LED 1 (D7)\n\n\n\n\n\ns[3]\ns[2]\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) LED 0 (D6)\n\n\n\n\n\ns[1]\ns[0]\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\n\n\n\n\n\nThe logic tables that were used for the led to switch mapping. Table 2 (a) refers to s[3] and s[2]; on the board, these are switches 1 and 2 (pins P32 and P31 respectively) to match where the highest order digits would be in a four digit number. By extensino, Table 2 (b) uses the two right-most switches (P35 and P32)\n\n\n\n\n\nTable 3: Seven Segment LED Matrix Logic\n\n\n\n\n\nSwitch Base 10 Value\nSeven Segment Display\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n2\n\n\n3\n3\n\n\n4\n4\n\n\n5\n5\n\n\n6\n6\n\n\n7\n7\n\n\n8\n8\n\n\n9\n9\n\n\n10\nA\n\n\n11\nB\n\n\n12\nC\n\n\n13\nD\n\n\n14\nE\n\n\n15\nF\n\n\n\n\n\n\nThe mapping from the decimal readout of the switches in hexadecimal.\n\n\nThese table, in turn, will follow the schematic drawing seen in Figure 5.\nThe lab is composed of three modules, one test bench, and one basic text file of test vectors. The modules are assumbled such that there is one for the combinational logic used for the LEDs called led_control.sv, and another that is used for the combinational logic of the seven segment array, called seven_segments.sv. The connection of these modules can be visualized in the block diagram below.\n\n\n\nIn this design approach, I noted that the led’s followed very basic boolean logic; LED 0 followed XOR logic with the lowest order two bits supplied by the DIP switch, and LED 1 followed AND logic with the two highest bits (see table in Section 1.4). LED 2 was very simple to program, as it followed similar logic to that used in the iCE_40.sv tutorial.\nResultantly, the led_control module consists of three assign statements. The first two are combination logic for XOR and AND gates. The final part takes in a counter input, and uses it to decide whether to turn on/off the LED based on its most prominent bit in a 2^24 bit counter.\n\n\n\nThe design approach for the seven segment array required some more thoughtful setup. First, I constructed a table for each of the 16 possible arrangements of the DIP switch. Following the general logic that 0 should be mapped to 0x0, 1 to 0x1, etc. etc. until 15 was mapped to 0xF, I then created a table Table 4 that mapped out which parts of the segment would need to turn on to display the correct number. This gave me a list of seven bits arrange in 16 ways, which I then used inside a case statement when assigning according to the decimal value held by the DIP switch. Note that in the following table, segA was seg[0], or the least significant bit of the seven_segment array inside of the module; I initially had an issue debugging where I reversed the values on accident, and it created some odd shapes on the seven-segment matrix.\n\n\n\n\n\n\nExpandable Table\n\n\n\n\n\n\n\n\nTable 4: Table of Switches Mapped to Segments\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ns[3]\ns[2]\ns[2]\ns[0]\n0x___\nsegA\nsegB\nsegC\nsegD\nsegE\nsegF\nsegG\n\n\n\n\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n0\n0\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n\n\n0\n0\n1\n0\n2\n0\n0\n1\n0\n0\n1\n0\n\n\n0\n0\n1\n1\n3\n0\n0\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n0\n4\n1\n0\n0\n1\n1\n0\n0\n\n\n0\n1\n0\n1\n5\n0\n1\n0\n0\n1\n0\n0\n\n\n0\n1\n1\n0\n6\n0\n1\n0\n0\n0\n0\n0\n\n\n0\n1\n1\n1\n7\n0\n0\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n8\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n0\n0\n1\n9\n0\n0\n0\n0\n1\n0\n0\n\n\n1\n0\n1\n0\n“A”\n0\n0\n0\n1\n0\n0\n0\n\n\n1\n0\n1\n1\n“b”\n1\n1\n0\n0\n0\n0\n0\n\n\n1\n1\n0\n0\n“C”\n0\n1\n1\n0\n0\n0\n1\n\n\n1\n1\n0\n1\n“d”\n1\n0\n0\n0\n0\n1\n0\n\n\n1\n1\n1\n0\n“E”\n0\n1\n1\n0\n0\n0\n0\n\n\n1\n1\n1\n1\n“F”\n0\n1\n1\n1\n0\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\nIn all, the combinational logic for this program was very straight forward. The next challenge came when mapping pins to the GPIO pins, and subsequent mapping to each individual segment on the matrix. The two modules for controlling the LEDs and the seven-segment matrix were both placed into a module called “lab01.sv”. On a top layer, the Python file “top.sv” generated a clock using an instatiation of an HSOSC module, which it fed into an instance of lab01.\n\n\n\n\nTo confirm that the system worked, a very basic testbench was written that ran through every potential arrangement of the 4-Pin system, checking expected LED values and seven-segment outputs. The value of led[2] was ignored in this testbench, as it was assumed to be working given that it had worked in the previous lab, and is extremely difficult to check (with my current knowledge as of September 2024) within a Questa Testbench.\nWhen writing a testbench, I ran into several problems with using test vectors, to the point where I initially just wanted to program a for-loop to check my results. However, I realized after multiple hours of debugging and talking with Kavi that I had saved the file as the wrong type of text file, and resultantly my code couldn’t find the file (not for lack of me putting the textfile in every place)\n\n\n\n\n\n\nCan’t Find *.tv File\n\n\n\nBecause Windows doesn’t show the full extension, it wasn’t until I was looking through Windows via Terminal that I saw that the .tv file was, in fact, not a .tv file but a .tv.rtf file; this meant that when the program looked for the file that it wanted to run to test the vectors, it was unable to load it, even if the pathing to the text file was correct. Be very careful in Windows that the extension you see in the Finder window may not be the complete extension.\n\n\nThe final test bench that I made controlled the four bit input of the switches, and the cross checked the output of top with the values I knew ought to be in the led and seven segment array. The simulation takes a long time to run: I believe in order for it to complete all test vectors, I need to use the command run 1000000 (with six 0’s) in order to see the full thing and confirm that it is working. I removed $finish from the initial testbench file I was using as a baseline, as I wanted to be able to see the finished Waveform generator in Questa.\n\nThis final design meets all the requirements for this lab. The bits are arranged in increasing order, left to right, on the DIP switches, and correspond to the LED’s when everything is oriented the same way (i.e. the seven segment array is facing the correct direction, and the ribbon cable keeps everything close to the development board) without any twisting. Listing the requirements, and going over each one, we see that: 1. The development board is fully assembled and all its components are soldered. This was confirmed for the screw panel as well as the GPIO pins using a multimeter in lab. 2. There are three verilog modules written, one that serves at the top wrapper module, and two the serve to individually control the LEDs and control the 7-segment display 3. The FPGA has been programmed to run with this Verilog code. 4. The 7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF 5. All digits for the board are unique, with no repeats 6. The DIP switches are sequentially ordered, with P37 being the highest order and P32 the lowest. This is true for both the LED logic and the seven segment logic. 7. The LEDs display the specified logic operations properly. 8. I have provided calculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions, as 1.2V/220ohms = about 20 mA, which is within the device’s marked operating current. 9. I have generated a ModelSim (or specifically Questa) simulation with an automatic test bench that walks through each potential switch combination and ensures that the design is working properly. 10. Finally, I have performed the necessary calcualtions to ensure that all digits, specifically of the seven-segment array, are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "projects/e-155_website/labs/lab1/lab1.html#suggestions-for-future-improvements",
    "href": "projects/e-155_website/labs/lab1/lab1.html#suggestions-for-future-improvements",
    "title": "Lab 1 Writeup",
    "section": "Suggestions for Future Improvements",
    "text": "Suggestions for Future Improvements\nOverall, this lab was a very good introduction for MicroP’s, and really gets the ball rolling so that the student can get back into the frame of mind they were accustomed to in E85. Overall, I think very few edits should be made to this laboratory. However, if I had to suggest a change, I believe the main one would be that the lab writeup should include, at some point, a reference to the MCU board, in case the lab user either skipped the section or forgot about it. In particular, since the MCU will be used in the future, it seems important that the user demonstrate that they know how to use it before it is used to a much greater degree further into the semester.\nAdditionally, a reference to an example of a block diagram within the References page would have aided in clearing up exactly what was expected to be seen in the first lab writeup, as I had many questions that needed to be answered in person, and couldn’t be found online."
  },
  {
    "objectID": "projects/e-155_website/labs/lab6/lab6.html",
    "href": "projects/e-155_website/labs/lab6/lab6.html",
    "title": "Lab 6 Writeup",
    "section": "",
    "text": "Hours Spent: 49.5, Mapped with Toggl Track ### Introduction\nThe goal of this laboratory is to introduce us to the Internet of Things, and begin using serial peripheral interconnects using a DS1722 digital temperature sensors (which communicates via SPI) and a ESP8266 board (which sets up a WIFI network through which users can program HTML files).\nThe final system creates a webpages where the current temperature is displayed and is updated when the page is refreshed. The system must additionally display the state of an on-board LED on the STM32L432KCU microcontroller.\n\n\nThe main goal of this project was focused on configuring the registers of the STM32L432KCU board. The design uses CMSIS library device templates, but writes its own SPI library, which is configurable. This class is later used by the DS1722 class to talk to the DS1722 chip, which takes digital temperature measurements of the surrounding area. This device can be configured to be adjusted using 8, 9, 10, 11, or 12 bits.\nAll of these states can then be configured from within an http webserver, which is set up via an ESP8266 chip (Lab6ESP_19).\nThe webpage displays:\n\nThe current temperature is displayed using ºC.\nThe state of an LED that is set on the board.\n\nThe DS1722 chip is communicated with after being sent a SPI input with one of four instructions:\n\n0x00, 0x01, 0x02 -&gt; Reading the configuration, the lower configuration of bits, the higher configuration of bits\n0x80 -&gt; Write to the configuration bits\n\nThe “configuration” of the chip is of particular interest, because this is how control over the number of bits being sent into the device is determiend; although the chip’s SPI will always put out 16 bits, the actual data of these bits differs depending on the configuration. As seen in Table 1, the layout of the bits scales by powers of two; an 8 bit resolution will resultantly be able to determine the temperature with 1ºC of resolution, and 12 bit resolution will be determined with 0.0625ºC of resolution.\n\n\n\nTable 1: main.c Global Variabless\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber Bits\nBit 0\nBit 1\nBit 2\nBit 3\nBit 4\nBit 5\nBit 6\nBit 7\nBit 8\nBit 9\nBit 10\nBit 11\nBit 12\nBit 13\nBit 14\nBit 15\n\n\n\n\n8-bits\n\\(-2^{7}\\)\n\\(2^{6}\\)\n\\(2^{5}\\)\n\\(2^{4}\\)\n\\(2^{3}\\)\n\\(2^{2}\\)\n\\(2^{1}\\)\n\\(2^{0}\\)\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n12-bits\n\\(-2^{7}\\)\n\\(2^{6}\\)\n\\(2^{5}\\)\n\\(2^{4}\\)\n\\(2^{3}\\)\n\\(2^{2}\\)\n\\(2^{1}\\)\n\\(2^{0}\\)\n\\(2^{-1}\\)\n\\(2^{-2}\\)\n\\(2^{-3}\\)\n\\(2^{-4}\\)\n0\n0\n0\n0\n\n\n\n\n\n\nThe first 8 bits are found in the 0x02h (hexidecimal 02, binary 0000_0000_0000_0010) register, and the last are found in 0x01h register.\nAs a result, there are a total of 5 potential writing commands (configuring the chip to output 8, 9, 10, 11, or 12 bits), and three read commands (read the configuration, the lowest order eight bits, and the highest order eight bits)\n\n\n\nFor this lab, I wrote a total of four new files, and within these files several new methods.\n\n\nThe files for SPI are called STM32L432KC_SPI.c and STM32L432KC_SPI.h.\nWithin these files, there are two main functions; initSPI and spiSendReceive.\n\n\nThis function takes in three inputs (integers br, cpol, and cpha), and configures the STM32L432KCU’s SPI function. In this case, there are two potential ways of controlling whether or not the SPI is transmitting (the Chip Enable [CE] /Chip Select [CS] line), which is either controlling the chip using the software, or by using a GPIO output separate from the SPI modules. In this case, I set the chip select to be hardware, as NSS is difficult to configure on top of the rest of the project.\nThe initSPI will do the following internally:\n\nEnable all necessary GPIO pins (connect them to the RCC - Reset and Clock Control )\nEnable the SPI within the RCC\nConfigure the GPIO’s Alternate Function #5 (which sets GPIO pins to be connected to SPI)\nSet the baud rate (I set it to be 256th of the incoming frequency, in this case the PCLK is 16 MHz, so the final baud rate is \\(\\frac{16 MHz}{256}=62500 Hz\\))\nSet the polarity and the phase of the clock. The polarity defines where the clock is supposed to start - in the case that it’s - (as it is in this program), the clock starts at 0. The phase defines where data captures happen - so in this case, where I’ve assigned the phase to be 1, the clock will read the output of its SPI line on the second part of the clock - since the clock starts idle, the first change (0) would be where we’d write to the SPI, and the falling edge would be where the SPI would read. This will accurately communicate with the DS chip, which is configured to write on the second edge of the clock (in this way, the DS writes while we’re reading, and we write while the chip is reading). The DS wants the phase to be set to 1, and the chip actually automatically sets itself to read and write at the right edge of the clock.\nSet the SS output to be enabled\nSet FRXTH to generate a receiving event when the FIFO level is 8 bits (i.e. when the buffer has 8 bits, the program will send 8 bits, as opposed to sending 16 bits at once).\nTurn everything else off - including a CRC polynomial calculation, the FRF (we want to use two lines for SPI), and the data-mode of the system (BIDI).\nFinally, enable the SPI once everything has been configured.\n\n\n\n\nSPI operates by shifting out old data and replacing it with new data in a FIFO (first-in first-out) stack. A good way of thinking about this is an eight-seat roller coaster; a bunch of people line up, and the first eight people that arrive get sent off all at once when the roller coaster leaves. When the roller coaster gets back (this is where things are slightly different), all eight people get off, and trail one after another out of the roller coaster, while the next eight people file in behind them Figure 1.\n\n\n\n\n\n\n\n\n\nFirst, the function guarantees that the transmit is empty, then put the character you are sending (the variable send), and then waiting until the receive is empty before returning the character currently in the FIFO stack.\nOf particular note is how pointers and volatile characters are used in this program. The character that is being set inside the SPI1’s DR should be volatile, since it should be possible for this character to change depending on the input value.\nTo make sure that this was a volatile character, we need to cast the character at the SPI1-&gt;DR into a volatile char. This is impossible unless we use a pointer to the specific address where the DR was placed in the microcontroller; if we cast the DR value directly to a character, we’d actually be casting the address for SDR into a volatile char, not the value inside of it. As a result, the final value needs to look like *((volatile char *) (&SPI1-&gt;DR)) = send;.\n\n\n\n\n\n\nConfigures the DS1722 with the requisite number of bits. To do this, we first send the signal 1000_0000_0000_0000, or 0x80, to the DS1722 chip using the SPI. We then send an 8 bit signal following this, which details how to configure the device. This is detailed in Figure 2 of the DS1722 Datasheet\n\n\n\n\n\n\n\n\n\nThe main important string inside this configuration are the three bits at address 1, 2, and 3 that define the number of bits used for resolution within the DS1722. The bits are defined in Table 2.\n\n\n\nTable 2: Lab 6 Table Bits\n\n\n\n\n\nResolution in Bits\nBits in Configuration [3:1]\n\n\n\n\n8\n0b’000\n\n\n9\n0b’001\n\n\n10\n0b’010\n\n\n11\n0b’011\n\n\n12\n0b’1xx\n\n\n\n\n\n\n\n\n\nThere are two things that needs to happen to read the temperature coming out of the DS1722: first, we need all the bits stored in register 1 and 2, and second we need to combine the bits together to read the proper temperature.\nThe system sends two addresses, and after each address sent, sends 8 additional bits to get the address readout. One example of this signal can be seen in Figure 3. In this image, the output from the chip can be seen in D0 (the selected bar in red), the enabling chip is D1 (the second line), the third line is the address being sent to the DS1722 bit stream, and the fourth line is the clock sent from the SPI.\nThis specific transmittion, in addition, shows an example of the configuration code explained in configSensor.\n\n\n\n\n\n\n\n\n\n\n\n\nThe module has one final “read” capability, which can be used to confirm the current bit-resolution of the device. This is done by sending the hex signal 0x00, to which the chip will put out a bit code resembling the write configuration code previously used in configSensor. Although not used in the final program, it would prove useful if the previous state of the sensor was not stored.\n\n\n\n\nPrior to running the entire program, I confirmed that the SPI on my board was working using a logic analyzer. Below is the output.\n\nEach of the lines were attached in the following way:\n\nD0: Chip Enable\nD1: SPI Clock\nD2: SPI MISO\nD3: SPI MOSI\n\nThis configuration was used during initial set up to confirm that all terminals were plugged in correctly, and all signals were being received in the right order.\n\n\n\n\nThe schematic for this program (Figure 4) shows the connections between the DS1722, the ESP8266, and the MCU board. I’d like to draw some additional attention to the pulldown resistor at the MISO signal, which is necessary if you want to receive actual data, as the DS1722 chip will not automatically pull this signal to 0 while it is transmitting a signal (the system requires a pulldown resistor).\n\n\n\n\n\n\n\n\n\n\n\n\nThe final configuration was tested for accuracy using a VNA logic analyzer that was run both without the USART control required for configuring the DSP reading, and with the USART control.\n\n\nTesting while using the USART was first done when my USART finally able to connect, and my board was able to communicate via Wifi. I needed to see if the system was able to boot up properly, and more specifically if the configuration was working. I took a screen capture of the configuration and recalculation of the temperature (which used the average of 100 temperature readouts taken from the DS1722 chip). The image that covers a larger time span (left) shows this long stream of SPI transmissions. The image on the right depicts the very start of this string: first, the system takes a read out (which was used in the debugging process within a printf statement to confirm that the SPI was communicating). Next, the system writes a configuration to the system and taking its first readout; the Chip Enable (D1) turns on, and then off briefly before turning back on again to perform a temperature measurement; this is done by the SPI sending out 0x02 (see the D2 LNA line), sending 0x00 while it collects the DS1722’s output, and then sending 0x01 before waiting another 0x00.\nThe temperature read out is repeated 100 times, which is why the broader image on the left has so many repeated pulses; after the initial configuration stream, the system reruns the readTemp function 100 times to get the average temperature.\n\n\n\n\n\n\n\n\n\n\n\n\nIn the future, I’d like to get the SPI working with NSS, and I’d also like to program the system to incorporate the chip-enable pins within the SPI functions themselves rather than externally. At the moment, I configure the enabling pins within my main.c file, because the system appeared to break my USART functionality when I set it within the SPI program. In the future, I’d like to troubleshoot this issue and be able to run my program functions without worrying about enabling and disabling pins (which should be possible, but seemed to somehow be broken).\nI think this Lab was exceptionally good for making sure that I understood the in’s and out’s of the Reference Manual. In meticulously setting up everything necessary for the SPI bus, I likely read Chapter 40 at least twenty times to make sure I understood every connection, enabler, and register that configures the SPI on the STM32L432KCU. Although I still needed pointers and some aid along the way, I can confidently say that a lot of this project was based on new skills I acquired through this course, and I learned a lot of resilience and persistance of mind that I didn’t have originally, which was one of my primary goals this semester.\n\n\n\nIn conclusion, I was successfully able to complete this lab with a working USART and SPI bus link, which communicates via an http link via a Wifi source and allows a user configuration capabilities and insight into a board that they may not be able to see.\nAs an additional little fun-thing, here’s a video of my system running on wifi - although you can’t see it, my board’s LED at PB3 is turning on and off with the LED button, and I am viewing the SPI interactions using an oscilloscope’s logic analyzer. Additionally, in order to help see the decimals better, I heat up the DS1722 at one point using my finger, and confirm that my (hand’s) temperature is about 2ºC hotter than the rest of the room, which helps to explain why I’m always cold while programming in the digital lab."
  },
  {
    "objectID": "projects/e-155_website/labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface-spi",
    "href": "projects/e-155_website/labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface-spi",
    "title": "Lab 6 Writeup",
    "section": "",
    "text": "Hours Spent: 49.5, Mapped with Toggl Track ### Introduction\nThe goal of this laboratory is to introduce us to the Internet of Things, and begin using serial peripheral interconnects using a DS1722 digital temperature sensors (which communicates via SPI) and a ESP8266 board (which sets up a WIFI network through which users can program HTML files).\nThe final system creates a webpages where the current temperature is displayed and is updated when the page is refreshed. The system must additionally display the state of an on-board LED on the STM32L432KCU microcontroller.\n\n\nThe main goal of this project was focused on configuring the registers of the STM32L432KCU board. The design uses CMSIS library device templates, but writes its own SPI library, which is configurable. This class is later used by the DS1722 class to talk to the DS1722 chip, which takes digital temperature measurements of the surrounding area. This device can be configured to be adjusted using 8, 9, 10, 11, or 12 bits.\nAll of these states can then be configured from within an http webserver, which is set up via an ESP8266 chip (Lab6ESP_19).\nThe webpage displays:\n\nThe current temperature is displayed using ºC.\nThe state of an LED that is set on the board.\n\nThe DS1722 chip is communicated with after being sent a SPI input with one of four instructions:\n\n0x00, 0x01, 0x02 -&gt; Reading the configuration, the lower configuration of bits, the higher configuration of bits\n0x80 -&gt; Write to the configuration bits\n\nThe “configuration” of the chip is of particular interest, because this is how control over the number of bits being sent into the device is determiend; although the chip’s SPI will always put out 16 bits, the actual data of these bits differs depending on the configuration. As seen in Table 1, the layout of the bits scales by powers of two; an 8 bit resolution will resultantly be able to determine the temperature with 1ºC of resolution, and 12 bit resolution will be determined with 0.0625ºC of resolution.\n\n\n\nTable 1: main.c Global Variabless\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber Bits\nBit 0\nBit 1\nBit 2\nBit 3\nBit 4\nBit 5\nBit 6\nBit 7\nBit 8\nBit 9\nBit 10\nBit 11\nBit 12\nBit 13\nBit 14\nBit 15\n\n\n\n\n8-bits\n\\(-2^{7}\\)\n\\(2^{6}\\)\n\\(2^{5}\\)\n\\(2^{4}\\)\n\\(2^{3}\\)\n\\(2^{2}\\)\n\\(2^{1}\\)\n\\(2^{0}\\)\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n12-bits\n\\(-2^{7}\\)\n\\(2^{6}\\)\n\\(2^{5}\\)\n\\(2^{4}\\)\n\\(2^{3}\\)\n\\(2^{2}\\)\n\\(2^{1}\\)\n\\(2^{0}\\)\n\\(2^{-1}\\)\n\\(2^{-2}\\)\n\\(2^{-3}\\)\n\\(2^{-4}\\)\n0\n0\n0\n0\n\n\n\n\n\n\nThe first 8 bits are found in the 0x02h (hexidecimal 02, binary 0000_0000_0000_0010) register, and the last are found in 0x01h register.\nAs a result, there are a total of 5 potential writing commands (configuring the chip to output 8, 9, 10, 11, or 12 bits), and three read commands (read the configuration, the lowest order eight bits, and the highest order eight bits)\n\n\n\nFor this lab, I wrote a total of four new files, and within these files several new methods.\n\n\nThe files for SPI are called STM32L432KC_SPI.c and STM32L432KC_SPI.h.\nWithin these files, there are two main functions; initSPI and spiSendReceive.\n\n\nThis function takes in three inputs (integers br, cpol, and cpha), and configures the STM32L432KCU’s SPI function. In this case, there are two potential ways of controlling whether or not the SPI is transmitting (the Chip Enable [CE] /Chip Select [CS] line), which is either controlling the chip using the software, or by using a GPIO output separate from the SPI modules. In this case, I set the chip select to be hardware, as NSS is difficult to configure on top of the rest of the project.\nThe initSPI will do the following internally:\n\nEnable all necessary GPIO pins (connect them to the RCC - Reset and Clock Control )\nEnable the SPI within the RCC\nConfigure the GPIO’s Alternate Function #5 (which sets GPIO pins to be connected to SPI)\nSet the baud rate (I set it to be 256th of the incoming frequency, in this case the PCLK is 16 MHz, so the final baud rate is \\(\\frac{16 MHz}{256}=62500 Hz\\))\nSet the polarity and the phase of the clock. The polarity defines where the clock is supposed to start - in the case that it’s - (as it is in this program), the clock starts at 0. The phase defines where data captures happen - so in this case, where I’ve assigned the phase to be 1, the clock will read the output of its SPI line on the second part of the clock - since the clock starts idle, the first change (0) would be where we’d write to the SPI, and the falling edge would be where the SPI would read. This will accurately communicate with the DS chip, which is configured to write on the second edge of the clock (in this way, the DS writes while we’re reading, and we write while the chip is reading). The DS wants the phase to be set to 1, and the chip actually automatically sets itself to read and write at the right edge of the clock.\nSet the SS output to be enabled\nSet FRXTH to generate a receiving event when the FIFO level is 8 bits (i.e. when the buffer has 8 bits, the program will send 8 bits, as opposed to sending 16 bits at once).\nTurn everything else off - including a CRC polynomial calculation, the FRF (we want to use two lines for SPI), and the data-mode of the system (BIDI).\nFinally, enable the SPI once everything has been configured.\n\n\n\n\nSPI operates by shifting out old data and replacing it with new data in a FIFO (first-in first-out) stack. A good way of thinking about this is an eight-seat roller coaster; a bunch of people line up, and the first eight people that arrive get sent off all at once when the roller coaster leaves. When the roller coaster gets back (this is where things are slightly different), all eight people get off, and trail one after another out of the roller coaster, while the next eight people file in behind them Figure 1.\n\n\n\n\n\n\n\n\n\nFirst, the function guarantees that the transmit is empty, then put the character you are sending (the variable send), and then waiting until the receive is empty before returning the character currently in the FIFO stack.\nOf particular note is how pointers and volatile characters are used in this program. The character that is being set inside the SPI1’s DR should be volatile, since it should be possible for this character to change depending on the input value.\nTo make sure that this was a volatile character, we need to cast the character at the SPI1-&gt;DR into a volatile char. This is impossible unless we use a pointer to the specific address where the DR was placed in the microcontroller; if we cast the DR value directly to a character, we’d actually be casting the address for SDR into a volatile char, not the value inside of it. As a result, the final value needs to look like *((volatile char *) (&SPI1-&gt;DR)) = send;.\n\n\n\n\n\n\nConfigures the DS1722 with the requisite number of bits. To do this, we first send the signal 1000_0000_0000_0000, or 0x80, to the DS1722 chip using the SPI. We then send an 8 bit signal following this, which details how to configure the device. This is detailed in Figure 2 of the DS1722 Datasheet\n\n\n\n\n\n\n\n\n\nThe main important string inside this configuration are the three bits at address 1, 2, and 3 that define the number of bits used for resolution within the DS1722. The bits are defined in Table 2.\n\n\n\nTable 2: Lab 6 Table Bits\n\n\n\n\n\nResolution in Bits\nBits in Configuration [3:1]\n\n\n\n\n8\n0b’000\n\n\n9\n0b’001\n\n\n10\n0b’010\n\n\n11\n0b’011\n\n\n12\n0b’1xx\n\n\n\n\n\n\n\n\n\nThere are two things that needs to happen to read the temperature coming out of the DS1722: first, we need all the bits stored in register 1 and 2, and second we need to combine the bits together to read the proper temperature.\nThe system sends two addresses, and after each address sent, sends 8 additional bits to get the address readout. One example of this signal can be seen in Figure 3. In this image, the output from the chip can be seen in D0 (the selected bar in red), the enabling chip is D1 (the second line), the third line is the address being sent to the DS1722 bit stream, and the fourth line is the clock sent from the SPI.\nThis specific transmittion, in addition, shows an example of the configuration code explained in configSensor.\n\n\n\n\n\n\n\n\n\n\n\n\nThe module has one final “read” capability, which can be used to confirm the current bit-resolution of the device. This is done by sending the hex signal 0x00, to which the chip will put out a bit code resembling the write configuration code previously used in configSensor. Although not used in the final program, it would prove useful if the previous state of the sensor was not stored.\n\n\n\n\nPrior to running the entire program, I confirmed that the SPI on my board was working using a logic analyzer. Below is the output.\n\nEach of the lines were attached in the following way:\n\nD0: Chip Enable\nD1: SPI Clock\nD2: SPI MISO\nD3: SPI MOSI\n\nThis configuration was used during initial set up to confirm that all terminals were plugged in correctly, and all signals were being received in the right order.\n\n\n\n\nThe schematic for this program (Figure 4) shows the connections between the DS1722, the ESP8266, and the MCU board. I’d like to draw some additional attention to the pulldown resistor at the MISO signal, which is necessary if you want to receive actual data, as the DS1722 chip will not automatically pull this signal to 0 while it is transmitting a signal (the system requires a pulldown resistor).\n\n\n\n\n\n\n\n\n\n\n\n\nThe final configuration was tested for accuracy using a VNA logic analyzer that was run both without the USART control required for configuring the DSP reading, and with the USART control.\n\n\nTesting while using the USART was first done when my USART finally able to connect, and my board was able to communicate via Wifi. I needed to see if the system was able to boot up properly, and more specifically if the configuration was working. I took a screen capture of the configuration and recalculation of the temperature (which used the average of 100 temperature readouts taken from the DS1722 chip). The image that covers a larger time span (left) shows this long stream of SPI transmissions. The image on the right depicts the very start of this string: first, the system takes a read out (which was used in the debugging process within a printf statement to confirm that the SPI was communicating). Next, the system writes a configuration to the system and taking its first readout; the Chip Enable (D1) turns on, and then off briefly before turning back on again to perform a temperature measurement; this is done by the SPI sending out 0x02 (see the D2 LNA line), sending 0x00 while it collects the DS1722’s output, and then sending 0x01 before waiting another 0x00.\nThe temperature read out is repeated 100 times, which is why the broader image on the left has so many repeated pulses; after the initial configuration stream, the system reruns the readTemp function 100 times to get the average temperature.\n\n\n\n\n\n\n\n\n\n\n\n\nIn the future, I’d like to get the SPI working with NSS, and I’d also like to program the system to incorporate the chip-enable pins within the SPI functions themselves rather than externally. At the moment, I configure the enabling pins within my main.c file, because the system appeared to break my USART functionality when I set it within the SPI program. In the future, I’d like to troubleshoot this issue and be able to run my program functions without worrying about enabling and disabling pins (which should be possible, but seemed to somehow be broken).\nI think this Lab was exceptionally good for making sure that I understood the in’s and out’s of the Reference Manual. In meticulously setting up everything necessary for the SPI bus, I likely read Chapter 40 at least twenty times to make sure I understood every connection, enabler, and register that configures the SPI on the STM32L432KCU. Although I still needed pointers and some aid along the way, I can confidently say that a lot of this project was based on new skills I acquired through this course, and I learned a lot of resilience and persistance of mind that I didn’t have originally, which was one of my primary goals this semester.\n\n\n\nIn conclusion, I was successfully able to complete this lab with a working USART and SPI bus link, which communicates via an http link via a Wifi source and allows a user configuration capabilities and insight into a board that they may not be able to see.\nAs an additional little fun-thing, here’s a video of my system running on wifi - although you can’t see it, my board’s LED at PB3 is turning on and off with the LED button, and I am viewing the SPI interactions using an oscilloscope’s logic analyzer. Additionally, in order to help see the decimals better, I heat up the DS1722 at one point using my finger, and confirm that my (hand’s) temperature is about 2ºC hotter than the rest of the room, which helps to explain why I’m always cold while programming in the digital lab."
  },
  {
    "objectID": "projects/e-155_website/labs/lab5/lab5.html",
    "href": "projects/e-155_website/labs/lab5/lab5.html",
    "title": "Lab 5 Writeup",
    "section": "",
    "text": "Hours Spent: 23.2, Mapped with Toggl Track\n\n\nIn this lab, a STM32L432KCU Microcontroller Unit (the MCU) was used to to read and print out the frequency of a 25GA-370 DC Motor. This lab made use of the STM32xx’s ability to plan responses to interrupts on the board, which in turn can be used to determine the direction and speed of a given motor based on the encoding of a given set of pins. This lab was framed to teach how to use interrupts and how to make use of Segger Embedded Studio’s printf functions.\n\n\n\nThis lab requires the use of a TS-25GA370 DC motor. This motor has two separate voltage supplies (Figure 1): one that goes up to 12 V, and is responsible for rotating the motor itself, and the other is the encoder, which requires 5V, and is responsible for sending 5V signals out of the encoder pins, which can be read within this lab. There are two encoder pins that the motor sends out, pin A and pin B. These pins are offset by pi/2 radians, meaning that they behave similar to sine-cosine behavior, or to those that are familiar with it, IQ data in radio. Such a setup enables us to reconstruct received signals with only two data points, depending on whether the signals are rising or falling relative to each other at any given point.\n\n\n\n\n\n\n\n\n\n\n\nI learned my lesson about timers after Lab 4, where I repeatedly tried changing the frequency of my timer only to run calculations for the accuracy of a frequency and realize that the itmer was wrong. Instead of going through the same pain this time, I chose instead to calculate beforehand the exact frequencies I would need to read out of my board so that I could properly set the timer’s prescaling.\nFirstly, I set up every scenario I would potentially run into within this lab in order to understand what cases I would need to check on the motors for absolute accuracy. I drew all eight of them, as seen in Figure 2, and determined that a full “period” of oscillation would actually be four interrupt signals received equal spacing apart. I decided that the best way to deduce frequency, as a result, would be to take the average of some past number of signals in order to determine the current speed of the motor.\n\n\n\n\n\n\n\n\n\nI found two patterns separately that would help me determine both the speed and the frequency of the motor. Firstly, the motor has 12 “signals” that it sends to A, and the same number to B. As a result, every rotation there are a total of 12 pulses supplied by the motor via the quad encoder pins (Figure 1). Additionally, since the gear reduction inside the motor is 10:1, there will be 120 pulses received per every actual rotation of the external pin. Resultantly, whatever readout I would get from one channel (i.e. readin A, for example) would represent 1/120 of a total rotation.\nAs for the forwards or backwards spin, after drawing a step by step look at what would happen to A and B when the motor was rotating forwards versus backwards (Figure 3), I was able to construct a table (Figure 4) that described the behavior I was seeing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter this, I worked backwards to find the maximum and minimum frequencies that I would be required to collect considering the planned interrupts of my timer.\nThe datasheet for the motor states that the motor can run between 10-600 rpm. When calculated into rotations per second, or more specifically the number of signals per second you get the following function:\n\\[\n10 rpm * \\frac{120 pulses (A and B)}{1 rotation} * \\frac{1 minute}{60 seconds} = \\frac{20 pulses}{1 second}\n\\]\nThis would mean that, in order to get the minimum number of samples possible to see this frequency, I would need to be able to sample at at least 40 Hz. For the sake of safety, I additionally said that I should be able to see up to 8Hz (i.e. one full period of an A and B signal rising and falling).\nFor the maximum frequency of 600 rpm, I pretended we were instead going to measure maximum 800 rpm. This meant, according to the math seend above, that I would need to sample at a rate of 3200 pulses every second in order to not miss any of the samples I was expecting to see.\nWith this in mind, I began deciding on the timer that I wanted to design; most timers on the system are already based off of the HCLK clock, or th 4MHz clock, that already exists in the system. I started first by figuring out how if, at minimum, I wanted to be able to to read out a 8Hz signal, I would need such a time period between Timer ticks that filling the entire ARR array of a timer would take longer than it would take to receive an 8Hz tick. To do so, I computed the period of 8Hz (\\(1/8\\) of a second) and then multiplied it by 65535, or \\(2^{16} - 1\\), which is the maximum value that can be reached with the ARR variable. I then took the inverse of this to find that the maximum frequency I could possible do, while still being able to sample the 8Hz signal, was 524,280 Hz.\nAs a result, I found that the general range in which I would be safely able to sample the rotations of the motor were between 3200 and 524280 Hz. Of these, I decided that it would good to have a clock frequency of 300,000.\n\n\n\nMy intention within this project was to build a running average that I could use to measure the average speed of the motor. To do so, every interrupt the code would increment the index of a given array (either moving forwards or back to the beginning depending on its location), and the interrupt would call two functions to determine what was happening. I intended to use pins PA6 and PA9 for this system, since both pins are able to withstand 5V of power (pages 52-54, Table 14, of the STM32L432KC Datasheet). In addition, these pins are already connected to the same interrupt pathway, which meant that I would only need to control one interrupt handler to understand what was going on in either pin at a given time.\n\n\n\nSegger Embedded Studio 8.16a was used to program all modules. In order to make sure I knew what needed to be done to handle an interrupt, I constructed a smaller project for creating an interrupt with a button, which would toggle and LED on and off.\nTo control an interrupt, there are X main steps:\n\nEnable the SYSCFG clock to get to your desired pin, and enable your pin.\n\ngpioEnable(GPIO_PORT_A); pinMode(PA5, GPIO_INPUT); RCC-&gt;APB2ENR |= (1&lt;&lt;0);\n\nSet the configuration of the EXTI control register to the right value. This can be done using the SYSCFG structure that has come with the given STM32 headers. For those that noticed, the array of the EXTICR is indexed from 0, not from 1, even thought the names of the variables are indexed from 1: as a result, if I want to control the EXTI Control Register 2, I have to call SYSCFG-&gt;EXTICR[1], since the bits at [2] would actually be for control register 3.\n\nSYSCFG-&gt;EXTICR[1] &= ~_VAL2FLD(SYSCFG_EXTICR2_EXTI5, 0b111);\n\nEnable global interrupts via the code __enable_irq();\nConfigure the code so that the triggers arrive on the right spots. First, I configure the GPIO pin I would be using to trigger the LED (PA5) to be read as if it were intended ot be used for an interrupt request. I then set it such that it would trigger an interrupt only on the falling trigger, not the rising edge.\n\nEXTI-&gt;IMR1 |= _VAL2FLD(EXTI_IMR1_IM5, 0b1);\n\n// 2. Disable rising edge trigger\nEXTI-&gt;RTSR1 &= ~_VAL2FLD(EXTI_RTSR1_RT5, 0b1);\n\n// 3. Enable falling edge trigger\nEXTI-&gt;FTSR1 |= _VAL2FLD(EXTI_FTSR1_FT5, 0b1);\n\nFinally, turn on the EXTI interrupt from within the Nested Vector Interrupt Controller (NVIC), specifically via the ISER register.\n\nNVIC-&gt;ISER[0] |= (1 &lt;&lt; EXTI9_5_IRQn);\nI then set up my button so that it was a pull-up resistor, and then set the DIP Switch button to pull it down to 0 when it was pressed. I was able to confirm, in this way, how interrupts worked via GPIO pins, and was able to expand this into my final code.\n\n\n\nMy code consists primarily of only a c file and a header file this time (main.c and main.h).\n\nmain.c: a C file that initializes and configures all the addresses and registers as required by the system. Additionally provides helper functions for the main that will be triggered or used by the triggered function EXTI9_5_IRQHandler to control the current array that is tracking the frequency.\nmain.h: Assigns the A and B input pins from the motor, as well as labels two timers (TIM2 and TIM6, specifically) as the clocks that will find the frequency or will be used for printing and delaying between prints.\n\nSince I only wanted to update the printout statements every second, I used the delay_millis with Timer 6 to wait for the requisite amount of time before running again.\n\n\nI configured my main file with a set of variables that could be used for two purposes; first, to keep track of the current number of ticks for the frequency, and second, to help the system work at extremely low frequencies. The variables are listed in the table below, with corresponding functionalities next to them (Table 1)\n\n\n\nTable 1: main.c Global Variabless\n\n\n\n\n\n\n\n\n\nVariable Name\nPurpose\n\n\n\n\nvolatile int arrA[5]\nAn array of counts: keeps track of how many counts have passed between each tick on the motor via TIM2-&gt;CNT; only changed when pin A triggers an interrupt\n\n\nvolatile int arrB[5]\nAn array of counts, like arrA. The only difference is that it is changed when pin B is triggered\n\n\nvolatile int idxA\nThe index that is set to next be changed in arrA when the system is triggered by an input from pin A\n\n\nvolatile int idxB\nThe index that is set to next be changed in arrB when the system is triggered by an input from pin B\n\n\nint hav_ent\nWhether or not we have entered an interrupt statement within the current loop of TIM6 (i.e., has an interrupt been triggered in the past second). This is used to determine whether or not the motor is actually spinning, and stalls the system for ten seconds until it determines that there is no signal.\n\n\nvolatile int curr_count_avg\nIs recalcualted every loop of the timer cycle. Finds the average amount of counts between an A to B signal or a B to A signal by averaging the values of arrA and arrB.\n\n\nvolatile int forwards\nChanged within the interrupt loops. Determines whether the system is moving forwards or backwards (i.e. clockwise or counterclockwise)\n\n\nvolatile int first_time_loop_A\nUsed at the very beginning of the system. Waits for the user to start moving the motor before it tries calculating average time.\n\n\nvolatile int first_time_loop_B\nThe same as first_time_loop_A, except this time triggered by an interrupt from encoder pin B.\n\n\ndouble frequency\nThe frequency of the system itself. It is equivalent to \\(\\frac{30000}{4 * curr_count_avg * 120}\\), since the samples have been collected at 30000 Hz.\n\n\n\n\n\n\nThis design is set to trigger on every edge of the potential interrupts that we’d see from pins A or B. The additional calculations confirm that it will be able to read both extremely low signals, and the fastest possible signals from the motor (i.e. the 10Hz signal when it is powered at 12 V).\n\n\n\nThis code also makes use of the &lt;stdio.h&gt; header library, as well as the _write function that comes with the the printf library. This library (if you forget to import it or weren’t aware that you needed to when initializing your project) can be added to your *.emProject file, as depicted below (Figure 5).\n\n\n\n\n\n\n\n\n\nThe printf statement applies, as far as I see, only to the Debug Terminal. Resultantly, when running your code in in Debug mode, and chose to play by itself (the green arrow), you will see the terminal consistently update depending on what’s in your printf statements. In my case, I chose to update based on a variety of factors, mainly being\n\nWhether or not we had just started the program\nWhether the signal was arriving extremely slowly\nWhether the motor was turned on or not (if it had already run)\nHow fast and in what direction the motor was moving.\n\nAll of these print statements I set to be called by the main function through a series of if statemeents.\n\n\n\n\n\nConsider that you were trying to toggle an LED pin; inside of a simple while loop, you could simply check to see if a button was pressed, and set the LED. But if that while loop contains additional code, all of a sudden it is possible that the button could be asynchronously pressed, and you would completely miss the trigger to turn the LED on. This is the primary motivation for using interrupts with your MCU.\nFor this code, in particular, we must keep in mind that the print statement is updating every 1 Hz, we won’t be able to check how fast the motor is running using this timer accurately. The most we could likely do would be to wait one millisecond, and check to see if we have an input, and do this method 1000 times. But the problem is that sometimes, waiting a millisecond could take longer than another because of the interrupt, or because of other processes on the chip. As a result, the program would inconsistently update its timer value (i.e. the updates wouldn’t always happen every second, and may take more time to arrive if the interrupts or if additional system processes are happening faster). Additionally consider what happens if you want to do more than just check for the motor interrupt - maybe this was a system that was measuring temperature underwater on a submarine, and the motors just need to be checked every so often to make sure that they aren’t stuttering or we haven’t hit a wall. In that case, there would be far more items to check off via manual polling, and it may sometimes take far to long to reach the frequency readouts; if that’s the case, they either wouldn’t be accurate, or would be missed altogether. Since motors rely on square waves, if you happen to sample the wave when it’s at 0, it will appear as if the motor isn’t on; it is only through consistently tracking when the motor changes its value that you can caccurately measure its frequency, and this is why interrupts are so useful.\n\n\n\nThe final layout for this program can be seen in Figure 6.\n\n\n\n\n\n\n\n\n\nThe program prints values every second. These values are determined after 1 second of waiting, and are calculated using the arrA and arrB vectors, which have the number of counts between each interrupt saved for the past 5 interrupts. At the very beginning of main’s while loop for this system, the variable hav_ent is set to 0; if it remains 0 the entire time, that means that there has been no interrupt within the 1 second delay, and the system enters a stall state. To allow for extremely slow frequencies, the system will wait for 10 beats; if hav_ent has not been set by this time, then the program assumes that the motor is not running, and prints out a variable saying as much.\n\n\n\nAll that was required for the setup of this lab was the TS-25GA370 DC Motor and pins to read the input (PA6 and PA9), as well as to supply 5V and GND to the encoder pins on the motor. The motor was supplied separately with between 0-12V, as demonstrated in the schematic (Figure 7)\n\n\n\n\n\n\nFigure 7: Schematic Diagram\n\n\n\nPins PA6 and PA9 were chosen, individually, becuase they are able to withstand 5 V of power as opposed to other pins that can only take in 3.3 V. This is detailed further in Table 14 (STM32L432xx pin definitions) in the STM32L432xx Datasheet.\n\n\n\nTo make sure that this system could initially run, I used the demos Python proram “interrupt_button.c”, which still remains in the project even though it is excluded from the build. I could easily use this button configuration to confirm that my interrupts were set up correctly, which aided a large part in debugging.\n\n\n\nIn conclusion, this lab was a success in configuring an MCU board to use interrupts for measuring the velocity of a motor. It additionally provided information about the incorporation of printf statements within a program, which will prove helpful in later labs for debugging purposes.\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed with the use of an oscilloscope or a callibration plot that accounts for the voltage to spin rate of the motor.\nI spent a total of 23.2 hours working on this lab, with roughly three of them spent on the lab writeup, and two spent building the initial diagram of what signals I anticipated to see with the spinning motor."
  },
  {
    "objectID": "projects/e-155_website/labs/lab5/lab5.html#lab-5-interrupts",
    "href": "projects/e-155_website/labs/lab5/lab5.html#lab-5-interrupts",
    "title": "Lab 5 Writeup",
    "section": "",
    "text": "Hours Spent: 23.2, Mapped with Toggl Track\n\n\nIn this lab, a STM32L432KCU Microcontroller Unit (the MCU) was used to to read and print out the frequency of a 25GA-370 DC Motor. This lab made use of the STM32xx’s ability to plan responses to interrupts on the board, which in turn can be used to determine the direction and speed of a given motor based on the encoding of a given set of pins. This lab was framed to teach how to use interrupts and how to make use of Segger Embedded Studio’s printf functions.\n\n\n\nThis lab requires the use of a TS-25GA370 DC motor. This motor has two separate voltage supplies (Figure 1): one that goes up to 12 V, and is responsible for rotating the motor itself, and the other is the encoder, which requires 5V, and is responsible for sending 5V signals out of the encoder pins, which can be read within this lab. There are two encoder pins that the motor sends out, pin A and pin B. These pins are offset by pi/2 radians, meaning that they behave similar to sine-cosine behavior, or to those that are familiar with it, IQ data in radio. Such a setup enables us to reconstruct received signals with only two data points, depending on whether the signals are rising or falling relative to each other at any given point.\n\n\n\n\n\n\n\n\n\n\n\nI learned my lesson about timers after Lab 4, where I repeatedly tried changing the frequency of my timer only to run calculations for the accuracy of a frequency and realize that the itmer was wrong. Instead of going through the same pain this time, I chose instead to calculate beforehand the exact frequencies I would need to read out of my board so that I could properly set the timer’s prescaling.\nFirstly, I set up every scenario I would potentially run into within this lab in order to understand what cases I would need to check on the motors for absolute accuracy. I drew all eight of them, as seen in Figure 2, and determined that a full “period” of oscillation would actually be four interrupt signals received equal spacing apart. I decided that the best way to deduce frequency, as a result, would be to take the average of some past number of signals in order to determine the current speed of the motor.\n\n\n\n\n\n\n\n\n\nI found two patterns separately that would help me determine both the speed and the frequency of the motor. Firstly, the motor has 12 “signals” that it sends to A, and the same number to B. As a result, every rotation there are a total of 12 pulses supplied by the motor via the quad encoder pins (Figure 1). Additionally, since the gear reduction inside the motor is 10:1, there will be 120 pulses received per every actual rotation of the external pin. Resultantly, whatever readout I would get from one channel (i.e. readin A, for example) would represent 1/120 of a total rotation.\nAs for the forwards or backwards spin, after drawing a step by step look at what would happen to A and B when the motor was rotating forwards versus backwards (Figure 3), I was able to construct a table (Figure 4) that described the behavior I was seeing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter this, I worked backwards to find the maximum and minimum frequencies that I would be required to collect considering the planned interrupts of my timer.\nThe datasheet for the motor states that the motor can run between 10-600 rpm. When calculated into rotations per second, or more specifically the number of signals per second you get the following function:\n\\[\n10 rpm * \\frac{120 pulses (A and B)}{1 rotation} * \\frac{1 minute}{60 seconds} = \\frac{20 pulses}{1 second}\n\\]\nThis would mean that, in order to get the minimum number of samples possible to see this frequency, I would need to be able to sample at at least 40 Hz. For the sake of safety, I additionally said that I should be able to see up to 8Hz (i.e. one full period of an A and B signal rising and falling).\nFor the maximum frequency of 600 rpm, I pretended we were instead going to measure maximum 800 rpm. This meant, according to the math seend above, that I would need to sample at a rate of 3200 pulses every second in order to not miss any of the samples I was expecting to see.\nWith this in mind, I began deciding on the timer that I wanted to design; most timers on the system are already based off of the HCLK clock, or th 4MHz clock, that already exists in the system. I started first by figuring out how if, at minimum, I wanted to be able to to read out a 8Hz signal, I would need such a time period between Timer ticks that filling the entire ARR array of a timer would take longer than it would take to receive an 8Hz tick. To do so, I computed the period of 8Hz (\\(1/8\\) of a second) and then multiplied it by 65535, or \\(2^{16} - 1\\), which is the maximum value that can be reached with the ARR variable. I then took the inverse of this to find that the maximum frequency I could possible do, while still being able to sample the 8Hz signal, was 524,280 Hz.\nAs a result, I found that the general range in which I would be safely able to sample the rotations of the motor were between 3200 and 524280 Hz. Of these, I decided that it would good to have a clock frequency of 300,000.\n\n\n\nMy intention within this project was to build a running average that I could use to measure the average speed of the motor. To do so, every interrupt the code would increment the index of a given array (either moving forwards or back to the beginning depending on its location), and the interrupt would call two functions to determine what was happening. I intended to use pins PA6 and PA9 for this system, since both pins are able to withstand 5V of power (pages 52-54, Table 14, of the STM32L432KC Datasheet). In addition, these pins are already connected to the same interrupt pathway, which meant that I would only need to control one interrupt handler to understand what was going on in either pin at a given time.\n\n\n\nSegger Embedded Studio 8.16a was used to program all modules. In order to make sure I knew what needed to be done to handle an interrupt, I constructed a smaller project for creating an interrupt with a button, which would toggle and LED on and off.\nTo control an interrupt, there are X main steps:\n\nEnable the SYSCFG clock to get to your desired pin, and enable your pin.\n\ngpioEnable(GPIO_PORT_A); pinMode(PA5, GPIO_INPUT); RCC-&gt;APB2ENR |= (1&lt;&lt;0);\n\nSet the configuration of the EXTI control register to the right value. This can be done using the SYSCFG structure that has come with the given STM32 headers. For those that noticed, the array of the EXTICR is indexed from 0, not from 1, even thought the names of the variables are indexed from 1: as a result, if I want to control the EXTI Control Register 2, I have to call SYSCFG-&gt;EXTICR[1], since the bits at [2] would actually be for control register 3.\n\nSYSCFG-&gt;EXTICR[1] &= ~_VAL2FLD(SYSCFG_EXTICR2_EXTI5, 0b111);\n\nEnable global interrupts via the code __enable_irq();\nConfigure the code so that the triggers arrive on the right spots. First, I configure the GPIO pin I would be using to trigger the LED (PA5) to be read as if it were intended ot be used for an interrupt request. I then set it such that it would trigger an interrupt only on the falling trigger, not the rising edge.\n\nEXTI-&gt;IMR1 |= _VAL2FLD(EXTI_IMR1_IM5, 0b1);\n\n// 2. Disable rising edge trigger\nEXTI-&gt;RTSR1 &= ~_VAL2FLD(EXTI_RTSR1_RT5, 0b1);\n\n// 3. Enable falling edge trigger\nEXTI-&gt;FTSR1 |= _VAL2FLD(EXTI_FTSR1_FT5, 0b1);\n\nFinally, turn on the EXTI interrupt from within the Nested Vector Interrupt Controller (NVIC), specifically via the ISER register.\n\nNVIC-&gt;ISER[0] |= (1 &lt;&lt; EXTI9_5_IRQn);\nI then set up my button so that it was a pull-up resistor, and then set the DIP Switch button to pull it down to 0 when it was pressed. I was able to confirm, in this way, how interrupts worked via GPIO pins, and was able to expand this into my final code.\n\n\n\nMy code consists primarily of only a c file and a header file this time (main.c and main.h).\n\nmain.c: a C file that initializes and configures all the addresses and registers as required by the system. Additionally provides helper functions for the main that will be triggered or used by the triggered function EXTI9_5_IRQHandler to control the current array that is tracking the frequency.\nmain.h: Assigns the A and B input pins from the motor, as well as labels two timers (TIM2 and TIM6, specifically) as the clocks that will find the frequency or will be used for printing and delaying between prints.\n\nSince I only wanted to update the printout statements every second, I used the delay_millis with Timer 6 to wait for the requisite amount of time before running again.\n\n\nI configured my main file with a set of variables that could be used for two purposes; first, to keep track of the current number of ticks for the frequency, and second, to help the system work at extremely low frequencies. The variables are listed in the table below, with corresponding functionalities next to them (Table 1)\n\n\n\nTable 1: main.c Global Variabless\n\n\n\n\n\n\n\n\n\nVariable Name\nPurpose\n\n\n\n\nvolatile int arrA[5]\nAn array of counts: keeps track of how many counts have passed between each tick on the motor via TIM2-&gt;CNT; only changed when pin A triggers an interrupt\n\n\nvolatile int arrB[5]\nAn array of counts, like arrA. The only difference is that it is changed when pin B is triggered\n\n\nvolatile int idxA\nThe index that is set to next be changed in arrA when the system is triggered by an input from pin A\n\n\nvolatile int idxB\nThe index that is set to next be changed in arrB when the system is triggered by an input from pin B\n\n\nint hav_ent\nWhether or not we have entered an interrupt statement within the current loop of TIM6 (i.e., has an interrupt been triggered in the past second). This is used to determine whether or not the motor is actually spinning, and stalls the system for ten seconds until it determines that there is no signal.\n\n\nvolatile int curr_count_avg\nIs recalcualted every loop of the timer cycle. Finds the average amount of counts between an A to B signal or a B to A signal by averaging the values of arrA and arrB.\n\n\nvolatile int forwards\nChanged within the interrupt loops. Determines whether the system is moving forwards or backwards (i.e. clockwise or counterclockwise)\n\n\nvolatile int first_time_loop_A\nUsed at the very beginning of the system. Waits for the user to start moving the motor before it tries calculating average time.\n\n\nvolatile int first_time_loop_B\nThe same as first_time_loop_A, except this time triggered by an interrupt from encoder pin B.\n\n\ndouble frequency\nThe frequency of the system itself. It is equivalent to \\(\\frac{30000}{4 * curr_count_avg * 120}\\), since the samples have been collected at 30000 Hz.\n\n\n\n\n\n\nThis design is set to trigger on every edge of the potential interrupts that we’d see from pins A or B. The additional calculations confirm that it will be able to read both extremely low signals, and the fastest possible signals from the motor (i.e. the 10Hz signal when it is powered at 12 V).\n\n\n\nThis code also makes use of the &lt;stdio.h&gt; header library, as well as the _write function that comes with the the printf library. This library (if you forget to import it or weren’t aware that you needed to when initializing your project) can be added to your *.emProject file, as depicted below (Figure 5).\n\n\n\n\n\n\n\n\n\nThe printf statement applies, as far as I see, only to the Debug Terminal. Resultantly, when running your code in in Debug mode, and chose to play by itself (the green arrow), you will see the terminal consistently update depending on what’s in your printf statements. In my case, I chose to update based on a variety of factors, mainly being\n\nWhether or not we had just started the program\nWhether the signal was arriving extremely slowly\nWhether the motor was turned on or not (if it had already run)\nHow fast and in what direction the motor was moving.\n\nAll of these print statements I set to be called by the main function through a series of if statemeents.\n\n\n\n\n\nConsider that you were trying to toggle an LED pin; inside of a simple while loop, you could simply check to see if a button was pressed, and set the LED. But if that while loop contains additional code, all of a sudden it is possible that the button could be asynchronously pressed, and you would completely miss the trigger to turn the LED on. This is the primary motivation for using interrupts with your MCU.\nFor this code, in particular, we must keep in mind that the print statement is updating every 1 Hz, we won’t be able to check how fast the motor is running using this timer accurately. The most we could likely do would be to wait one millisecond, and check to see if we have an input, and do this method 1000 times. But the problem is that sometimes, waiting a millisecond could take longer than another because of the interrupt, or because of other processes on the chip. As a result, the program would inconsistently update its timer value (i.e. the updates wouldn’t always happen every second, and may take more time to arrive if the interrupts or if additional system processes are happening faster). Additionally consider what happens if you want to do more than just check for the motor interrupt - maybe this was a system that was measuring temperature underwater on a submarine, and the motors just need to be checked every so often to make sure that they aren’t stuttering or we haven’t hit a wall. In that case, there would be far more items to check off via manual polling, and it may sometimes take far to long to reach the frequency readouts; if that’s the case, they either wouldn’t be accurate, or would be missed altogether. Since motors rely on square waves, if you happen to sample the wave when it’s at 0, it will appear as if the motor isn’t on; it is only through consistently tracking when the motor changes its value that you can caccurately measure its frequency, and this is why interrupts are so useful.\n\n\n\nThe final layout for this program can be seen in Figure 6.\n\n\n\n\n\n\n\n\n\nThe program prints values every second. These values are determined after 1 second of waiting, and are calculated using the arrA and arrB vectors, which have the number of counts between each interrupt saved for the past 5 interrupts. At the very beginning of main’s while loop for this system, the variable hav_ent is set to 0; if it remains 0 the entire time, that means that there has been no interrupt within the 1 second delay, and the system enters a stall state. To allow for extremely slow frequencies, the system will wait for 10 beats; if hav_ent has not been set by this time, then the program assumes that the motor is not running, and prints out a variable saying as much.\n\n\n\nAll that was required for the setup of this lab was the TS-25GA370 DC Motor and pins to read the input (PA6 and PA9), as well as to supply 5V and GND to the encoder pins on the motor. The motor was supplied separately with between 0-12V, as demonstrated in the schematic (Figure 7)\n\n\n\n\n\n\nFigure 7: Schematic Diagram\n\n\n\nPins PA6 and PA9 were chosen, individually, becuase they are able to withstand 5 V of power as opposed to other pins that can only take in 3.3 V. This is detailed further in Table 14 (STM32L432xx pin definitions) in the STM32L432xx Datasheet.\n\n\n\nTo make sure that this system could initially run, I used the demos Python proram “interrupt_button.c”, which still remains in the project even though it is excluded from the build. I could easily use this button configuration to confirm that my interrupts were set up correctly, which aided a large part in debugging.\n\n\n\nIn conclusion, this lab was a success in configuring an MCU board to use interrupts for measuring the velocity of a motor. It additionally provided information about the incorporation of printf statements within a program, which will prove helpful in later labs for debugging purposes.\n\n\n\nIn conclusion, all of the program works properly in simulation and in hardware, and can be confirmed with the use of an oscilloscope or a callibration plot that accounts for the voltage to spin rate of the motor.\nI spent a total of 23.2 hours working on this lab, with roughly three of them spent on the lab writeup, and two spent building the initial diagram of what signals I anticipated to see with the spinning motor."
  },
  {
    "objectID": "projects/e-155_website/labs/lab3/lab3.html",
    "href": "projects/e-155_website/labs/lab3/lab3.html",
    "title": "Lab 3 Writeup",
    "section": "",
    "text": "Hours Spent: 56 hours, Mapped with Toggl Track\n\n\nThe main point of this laboratory was to use asynchronous components and a finite state machine to control a keypad connected to an FPGA. The Finite state machine would keep track of both the values of the states, as well as have a recorded memory of both the most recent and the last pin pressed. The difficulties of this lab lay within creating a way to handle metastability; in order to ensure that no random metastability occured within the system while it was running, you need to have a set of flip flops through which you run the column input.\n\n\n\nI first began by drawing a rudimentary FSM chart:\n\nThis is based on the fundamental logic that there should be four parts to this problem: 1. A section of the code/hardware that sends a voltage through each row as it goes, waiting to detect a signal. If it does detect something, it sends us to the next state.\n\nA section of the code/hardware that logs the corresponding rows and columns so that we can compute what the letter we need to light up is\nA section of the code/hardware that cycles for about 1ms to prevent bounceback caused by any of the keys\nA section of the code/hardware that waits until the original button (or what I coined the RX Signal) that was pressed is no longer pressed down (i.e. can’t say “nothing is pressed”, but rather that the original button is no longer pressed); thus, you wait till the RX signal stops.\n\nI additionally decided to define a row state machine, although this would reside within the actual program as combinational logic, not as a module.\n\n\n\n\n\n\n\n\n\n\n\nSome challenges with this lab are implementing a way to handle metastability; in this case, it was necessary to add a set of flip flops about the column input logic so that asyncronous signals could become synchronous; in my case, I chose to send the columns through two flipflops. I integrated this step within my FSM block, after I had initially made the logic for it, which resulted in the large amount of code that it contains; in the future, I’d like to trim this FSM block down so that it looks simpler and shows the outputs and inputs easier to the causal viewer. However, for now the flip flops have been implemented to run right after the waiting period, within the “LOG” state; the LOG state will wait for two cycles of flip flops, before taking the output of the flip flop (mat_stab), and using it as if it were the column. During this process, the intial row that the column was saved to has been stored, and I am powering it so that the upcoming TILL_RX_STOP step can run.\nMy debouncing approach is likely more rudimentary than it could be: I could additionally have added a way to track how many one’s in a row the machine had received, and use that to determine if the button was actually pushed. This would have required a longer loop, but would likely have been more accurate, as currently some a quick tap of the key makes it repeat (even though I’ve made the CYCLE stage extremely long relatively speaking). I think that the looking at the 1’s strategy would be very effective for eliminating debouncing. I think that in particular, I could have implemented more flip-flops to really make sure that the state was what the board originally thought it was.\n\n\n\nUsing my initial approach as well as some blocking of the modules that I would need for this program, I was then able to construct a finalized FSM with defined output variables.\nThis gives the following diagram and set of tables for inputs and outputs.\n\n\n\n\nTable 1: State Transition Table\n\n\n\n\n\nstate\nscenario/inputs\nnext_state\noutput values: row, past_letter, curr_letter, state, waiter\n\n\n\n\nWAIT\ncol == 0\nWAIT\nrow = ROW (see the row state machine), past_letter remains, curr_letter remains, state = WAIT, waiter = 0\n\n\nWAIT\ncol != 0\nLOG\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = WAIT, next_waiter = 2^19\n\n\nLOG\nmat_stab != (4’b0001 or 4’b0010 or 4’b0100 or 4’b1000)\nWAIT\nrow = R_RESET (see the row state machine), next_past_letter = curr_letter, next_curr_letter = next_letter (output of letter_receiver module), state = LOG, next_waiter = waiter\n\n\nLOG\nmat_stab == (4’b0001 or 4’b0010 or 4’b0100 or 4’b1000)\nCYCLE\nnext_row = row (see the row state machine), past_letter remains, curr_letter remains, state = WAIT, waiter = waiter - 1\n\n\nCYCLE\nwaiter != 0\nCYCLE\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = waiter - 1\n\n\nCYCLE\nwaiter == 0\nTX_RX_STOP\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = 0\n\n\nTILL_RX_STOP\ncol[col_index] != 0\nTILL_RX_STOP\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0\n\n\nTILL_RX_STOP\ncol[col_index] == 0\nLOG\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0\n\n\n\n\n\n\nI have additionally depicted below what the table for the row states looks like.\n\n\n\nTable 2: State Transition Table for the Row States\n\n\n\n\n\nrow\nscenario/inputs\nnext_row\n\n\n\n\nR_RESET\nX\nR_0\n\n\nR_0\ncol == 0\nR_1\n\n\nR_1\ncol == 0\nR_2\n\n\nR_2\ncol == 0\nR_3\n\n\nR_3\ncol == 0\nR_0\n\n\nR_X\ncol != 0\nR_X\n\n\n\n\n\n\nCurrently in the works, I decided to try revamping my FSM so that I wasn’t doing everything at once inside of my FSM function; it initially made the most sense to me to try doing it in one place, but this made it hard to see all of the logic that was happening to an outside observer (i.e. Kavi)\n\n\n\n\nMy final product of code looks like the following. The program primarily consists of the top module, which contains the clock, the lab03 module, which holds the fsm and the dual segment display modules, and finally the individual modules inside them. Describing them below,\n\nlab03_fsm: uses an internal flipflop from my flop_me module and a combinational logic block called letter_receiver to iterate through the defined states and return the desired values of interest.\ndual_seven_seg: the same as from lab02, where it uses multiplexing to light up both of the arrays with two defined numbers; this time, the numbers are supplied by the fsm.\nflop_me: a flip flop of some defined length that runs every time within the function in order to solve any metastability that may be present with a button push.\nletter_receiver: a combinational logic block that combines the saved indices of the rows and columns in order to solve for whatever letter/number was pressed. This is how I get the next_letter variable within my finite state machine.\n\n\nI confirmed using Questa that I was able to get the right values for all potential row inputs that I would have by iterating through the fsm (see the testbench below)\n\nIn order to form a comprehensive test, I initially begin by making sure that every row can be cycled through while we reside inside the Waiting state. No column was entered, and the testbench was used to track that the past letters, current letters, and finally the row cycling; since this is the waiting state, and nothing’s been pressed, the rows should cycle, and the output letters (0 and 0) stay the same (Figure 2)\n\n\n\n\n\n\n\n\n\nAfter this has been done, the system is then reset. This is confirmed by the testbench, and then the testbench enters a long for-loop that is used to confirm that every letter can be received and updated. For each loop of the table, the row and column are updated; the letter that has been generated is confirmed to be correct in the testbench, as well as the current lit rows and columns. The FSM additionally outputs its state, which is not used in the lab03 overall, but is used in the testbench to confirm that the proper state has also been entered. These cycles run through every row and every potential combination of row and column (Figure 3).\n\n\n\n\n\n\n\n\n\nWhen we zoom out in full, we can confirm that all letters can be reached, and that they can be stored (Figure 4).\n\n\n\n\n\n\n\n\n\nNext, I made another test bench to test my lab03 module as a whole, which looks like the following;\n\n\n\n\n\n\n\n\n\nThis testbench acts very similar to the fsm testbench, but in this case it confirms that the segment oscillates back and forth between the past letter and the current letter. Similar to the previous testbench for the fsm, the values were compared with expected values in the test bench, and when no errors were thrown, and the for-loop was completed without any errors or red lines becoming apparent, the testbench was considered a success.\nAs can be seen in Figure 5, the full test could be run, and the expected oscillations between segments occured as lab03 was run.\nIn both of these cases, I used a testbench to initialize and push inputs into the modules, and made sure that the expected values matched what I anticipated (indicated by no errors appearing in the terminal window).\nThe final schematic of my system was very simple to make. I used four GPIO pins from the FPGA E155 adapter board as an output into the rows, and four GPIO pins from this same board as inputs. Of additional note, becuase I considered 1’s as “high” on my board, I turned off the pull-up resistors inside the column pins, and implemented pulldown resistors of 47kOhm impedance on my board, with the knowledge that the keypad’s resistors range between 60 and 200 Ohms (found by testing in lab with an oscilloscope); resultantly, any voltage drop caused by the voltage-divider setup I had made would be negligable over the keypad, and would allow for proper reading of the signal. All other parts of this schematic, as a reader may likely recognize, are the same as from Lab2; the seven segment display as well as it PNP transistors are all plugged into the same pins, and depend on the same inputs.\n\n\n\n\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed. The main issue encountered in this lab were the following: * Implementation of pull-down resistors, and turning off the pull-up resistors within the keypads. * Implementation of a clock division that prevented the double-readout of a button push, which caused keys that sometimes held values a bit longer (on my keypad, keys E, 7, and 2) to be falsely read as a second input.\nIf future development desired, I’d like to add more flipflops, as well as simplify the state machine layout within Verilog to make debugging easier and make it more understandable to new viewers; potentially if I have time over winter break, I’ll do that and make it extremely nice looking so that it looks better in GitHub.\n\n\n\nThis lab was extremely difficult. I recommend in the future sending out a post about where the keypads are in the beginning of lab, because many people had a hard time finding them: I’d additionally warn people about how some of the keypads don’t match their anticipated row and column values, and that people should plan on bringing in multimeters in order to test which buttons are connected where. Finally, I’d suggest that people start by thinking about the flip flops, and don’t ignore them until later on; it became much harder to implement once I had my program set up, and if I had had the ability to go back and redo it with the knowledge that multipathing would require me to wait periods of time within a module, etc., I likely would have set it up nicer and it would have been in separate modules.\nAdditionally, I believe a note should be put somewhere about the speed of the clock, and to consider that as well when implementing your code. Although it is something that can be realized with the aid of an oscilloscope, it didn’t cross my mind because I was so fixated on the bugs that may be causing the issue. It may be nice to put a mention, maybe even a vague sentence, somewhere that says to keep an eye on not only the timing issues of your circuit, but in what time scale your circuit is running - that way it doesn’t spell out the answer, but still is informative to people like me who get stuck."
  },
  {
    "objectID": "projects/e-155_website/labs/lab3/lab3.html#lab-3-keypad-scanner",
    "href": "projects/e-155_website/labs/lab3/lab3.html#lab-3-keypad-scanner",
    "title": "Lab 3 Writeup",
    "section": "",
    "text": "Hours Spent: 56 hours, Mapped with Toggl Track\n\n\nThe main point of this laboratory was to use asynchronous components and a finite state machine to control a keypad connected to an FPGA. The Finite state machine would keep track of both the values of the states, as well as have a recorded memory of both the most recent and the last pin pressed. The difficulties of this lab lay within creating a way to handle metastability; in order to ensure that no random metastability occured within the system while it was running, you need to have a set of flip flops through which you run the column input.\n\n\n\nI first began by drawing a rudimentary FSM chart:\n\nThis is based on the fundamental logic that there should be four parts to this problem: 1. A section of the code/hardware that sends a voltage through each row as it goes, waiting to detect a signal. If it does detect something, it sends us to the next state.\n\nA section of the code/hardware that logs the corresponding rows and columns so that we can compute what the letter we need to light up is\nA section of the code/hardware that cycles for about 1ms to prevent bounceback caused by any of the keys\nA section of the code/hardware that waits until the original button (or what I coined the RX Signal) that was pressed is no longer pressed down (i.e. can’t say “nothing is pressed”, but rather that the original button is no longer pressed); thus, you wait till the RX signal stops.\n\nI additionally decided to define a row state machine, although this would reside within the actual program as combinational logic, not as a module.\n\n\n\n\n\n\n\n\n\n\n\nSome challenges with this lab are implementing a way to handle metastability; in this case, it was necessary to add a set of flip flops about the column input logic so that asyncronous signals could become synchronous; in my case, I chose to send the columns through two flipflops. I integrated this step within my FSM block, after I had initially made the logic for it, which resulted in the large amount of code that it contains; in the future, I’d like to trim this FSM block down so that it looks simpler and shows the outputs and inputs easier to the causal viewer. However, for now the flip flops have been implemented to run right after the waiting period, within the “LOG” state; the LOG state will wait for two cycles of flip flops, before taking the output of the flip flop (mat_stab), and using it as if it were the column. During this process, the intial row that the column was saved to has been stored, and I am powering it so that the upcoming TILL_RX_STOP step can run.\nMy debouncing approach is likely more rudimentary than it could be: I could additionally have added a way to track how many one’s in a row the machine had received, and use that to determine if the button was actually pushed. This would have required a longer loop, but would likely have been more accurate, as currently some a quick tap of the key makes it repeat (even though I’ve made the CYCLE stage extremely long relatively speaking). I think that the looking at the 1’s strategy would be very effective for eliminating debouncing. I think that in particular, I could have implemented more flip-flops to really make sure that the state was what the board originally thought it was.\n\n\n\nUsing my initial approach as well as some blocking of the modules that I would need for this program, I was then able to construct a finalized FSM with defined output variables.\nThis gives the following diagram and set of tables for inputs and outputs.\n\n\n\n\nTable 1: State Transition Table\n\n\n\n\n\nstate\nscenario/inputs\nnext_state\noutput values: row, past_letter, curr_letter, state, waiter\n\n\n\n\nWAIT\ncol == 0\nWAIT\nrow = ROW (see the row state machine), past_letter remains, curr_letter remains, state = WAIT, waiter = 0\n\n\nWAIT\ncol != 0\nLOG\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = WAIT, next_waiter = 2^19\n\n\nLOG\nmat_stab != (4’b0001 or 4’b0010 or 4’b0100 or 4’b1000)\nWAIT\nrow = R_RESET (see the row state machine), next_past_letter = curr_letter, next_curr_letter = next_letter (output of letter_receiver module), state = LOG, next_waiter = waiter\n\n\nLOG\nmat_stab == (4’b0001 or 4’b0010 or 4’b0100 or 4’b1000)\nCYCLE\nnext_row = row (see the row state machine), past_letter remains, curr_letter remains, state = WAIT, waiter = waiter - 1\n\n\nCYCLE\nwaiter != 0\nCYCLE\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = waiter - 1\n\n\nCYCLE\nwaiter == 0\nTX_RX_STOP\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = 0\n\n\nTILL_RX_STOP\ncol[col_index] != 0\nTILL_RX_STOP\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0\n\n\nTILL_RX_STOP\ncol[col_index] == 0\nLOG\nnext_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0\n\n\n\n\n\n\nI have additionally depicted below what the table for the row states looks like.\n\n\n\nTable 2: State Transition Table for the Row States\n\n\n\n\n\nrow\nscenario/inputs\nnext_row\n\n\n\n\nR_RESET\nX\nR_0\n\n\nR_0\ncol == 0\nR_1\n\n\nR_1\ncol == 0\nR_2\n\n\nR_2\ncol == 0\nR_3\n\n\nR_3\ncol == 0\nR_0\n\n\nR_X\ncol != 0\nR_X\n\n\n\n\n\n\nCurrently in the works, I decided to try revamping my FSM so that I wasn’t doing everything at once inside of my FSM function; it initially made the most sense to me to try doing it in one place, but this made it hard to see all of the logic that was happening to an outside observer (i.e. Kavi)\n\n\n\n\nMy final product of code looks like the following. The program primarily consists of the top module, which contains the clock, the lab03 module, which holds the fsm and the dual segment display modules, and finally the individual modules inside them. Describing them below,\n\nlab03_fsm: uses an internal flipflop from my flop_me module and a combinational logic block called letter_receiver to iterate through the defined states and return the desired values of interest.\ndual_seven_seg: the same as from lab02, where it uses multiplexing to light up both of the arrays with two defined numbers; this time, the numbers are supplied by the fsm.\nflop_me: a flip flop of some defined length that runs every time within the function in order to solve any metastability that may be present with a button push.\nletter_receiver: a combinational logic block that combines the saved indices of the rows and columns in order to solve for whatever letter/number was pressed. This is how I get the next_letter variable within my finite state machine.\n\n\nI confirmed using Questa that I was able to get the right values for all potential row inputs that I would have by iterating through the fsm (see the testbench below)\n\nIn order to form a comprehensive test, I initially begin by making sure that every row can be cycled through while we reside inside the Waiting state. No column was entered, and the testbench was used to track that the past letters, current letters, and finally the row cycling; since this is the waiting state, and nothing’s been pressed, the rows should cycle, and the output letters (0 and 0) stay the same (Figure 2)\n\n\n\n\n\n\n\n\n\nAfter this has been done, the system is then reset. This is confirmed by the testbench, and then the testbench enters a long for-loop that is used to confirm that every letter can be received and updated. For each loop of the table, the row and column are updated; the letter that has been generated is confirmed to be correct in the testbench, as well as the current lit rows and columns. The FSM additionally outputs its state, which is not used in the lab03 overall, but is used in the testbench to confirm that the proper state has also been entered. These cycles run through every row and every potential combination of row and column (Figure 3).\n\n\n\n\n\n\n\n\n\nWhen we zoom out in full, we can confirm that all letters can be reached, and that they can be stored (Figure 4).\n\n\n\n\n\n\n\n\n\nNext, I made another test bench to test my lab03 module as a whole, which looks like the following;\n\n\n\n\n\n\n\n\n\nThis testbench acts very similar to the fsm testbench, but in this case it confirms that the segment oscillates back and forth between the past letter and the current letter. Similar to the previous testbench for the fsm, the values were compared with expected values in the test bench, and when no errors were thrown, and the for-loop was completed without any errors or red lines becoming apparent, the testbench was considered a success.\nAs can be seen in Figure 5, the full test could be run, and the expected oscillations between segments occured as lab03 was run.\nIn both of these cases, I used a testbench to initialize and push inputs into the modules, and made sure that the expected values matched what I anticipated (indicated by no errors appearing in the terminal window).\nThe final schematic of my system was very simple to make. I used four GPIO pins from the FPGA E155 adapter board as an output into the rows, and four GPIO pins from this same board as inputs. Of additional note, becuase I considered 1’s as “high” on my board, I turned off the pull-up resistors inside the column pins, and implemented pulldown resistors of 47kOhm impedance on my board, with the knowledge that the keypad’s resistors range between 60 and 200 Ohms (found by testing in lab with an oscilloscope); resultantly, any voltage drop caused by the voltage-divider setup I had made would be negligable over the keypad, and would allow for proper reading of the signal. All other parts of this schematic, as a reader may likely recognize, are the same as from Lab2; the seven segment display as well as it PNP transistors are all plugged into the same pins, and depend on the same inputs.\n\n\n\n\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed. The main issue encountered in this lab were the following: * Implementation of pull-down resistors, and turning off the pull-up resistors within the keypads. * Implementation of a clock division that prevented the double-readout of a button push, which caused keys that sometimes held values a bit longer (on my keypad, keys E, 7, and 2) to be falsely read as a second input.\nIf future development desired, I’d like to add more flipflops, as well as simplify the state machine layout within Verilog to make debugging easier and make it more understandable to new viewers; potentially if I have time over winter break, I’ll do that and make it extremely nice looking so that it looks better in GitHub.\n\n\n\nThis lab was extremely difficult. I recommend in the future sending out a post about where the keypads are in the beginning of lab, because many people had a hard time finding them: I’d additionally warn people about how some of the keypads don’t match their anticipated row and column values, and that people should plan on bringing in multimeters in order to test which buttons are connected where. Finally, I’d suggest that people start by thinking about the flip flops, and don’t ignore them until later on; it became much harder to implement once I had my program set up, and if I had had the ability to go back and redo it with the knowledge that multipathing would require me to wait periods of time within a module, etc., I likely would have set it up nicer and it would have been in separate modules.\nAdditionally, I believe a note should be put somewhere about the speed of the clock, and to consider that as well when implementing your code. Although it is something that can be realized with the aid of an oscilloscope, it didn’t cross my mind because I was so fixated on the bugs that may be causing the issue. It may be nice to put a mention, maybe even a vague sentence, somewhere that says to keep an eye on not only the timing issues of your circuit, but in what time scale your circuit is running - that way it doesn’t spell out the answer, but still is informative to people like me who get stuck."
  },
  {
    "objectID": "projects/e-155_website/posts/008_post_2024-10-22.html",
    "href": "projects/e-155_website/posts/008_post_2024-10-22.html",
    "title": "The World of Epic the Musical",
    "section": "",
    "text": "The World of Epic the Musical\nI think one of the greatest things that’s come out of the internet is the ability to avoid major coorporations, and really find something human in a sea of extreme corporate safety. Take a look at modern Marvel movies, for example; if there was one thing to notice from these movies, its that the most recnt movies have become stale and sad because they rely too much on what they know will work: big bad guy, the heroes save the day, normally with some catchy one liners. They lack the characterization of earlier movies, and that is in part because they are so successful that they no longer feel the need to take risks - and this comes at the cost of the community that will support the movies in the future.\nThere isn’t a community for movies like “Wish” (Disney). There isn’t a community for movies like “Thor: Love and Thunder”, and I think that there’s a lot of hatred and ambiguity around the Star Wars Sequels. Ignoring the fact that the common thread here is Disney, what is more interesting is that often times the failing grace of the movies isn’t the cost or the spectacle, but the characterizations and the chances/risks taken. I think nothing stands as more of an example of how this goes over with audiences than the 200 million sunk cost into Sony’s “Concord” FPS game, which was taken off of the game store basically a week after its launch because no one was playing it (think 700 players online, in an industry where the norm is to have tens of thousands of players). Why? Because there was nothing new about the game, in an extremely oversaturated market (I’ll leave some really good youtube videos below talking about why Concord failed so spectacularly).\nThis was a preface for why I think “Epic: The Musical” is so good. It’s a musical about the Odyssey. Is it accurate to the Odyssey? Not really. It isn’t able to recontextualize a lot of the historical context that played into the story - for example, it can’t carry across the weight of the cyclops’ killing of the men being so, so bad by Greek standards, because we don’t understand in modern day that back during the times when the Odyssey was prominant, guests were ALWAYS given gifts or some sort of welcome (i.e., the cyclops represents a lack of refinement, humanity, and honor that we simply can’t contextualize with a modern lens). But that’s not important, what IS important is that it took the risk to begin with of adapting material as complex and fun as the Odyssey. And it does it with CHARACTER.\nThis character is what allows a community to foster, and nowhere do we see that more than in the artist community. Artists like Wolfy the Witch, Tamatama, gigi, and more (all on Youtube) make animatics (story boards for animations, basically) have created a backdrop for the insane work and catchy songs written for a purely CONCEPTUAL musical. This isn’t going to be on Broadway, and it doesn’t have to be. It’s something being made, purely for fun, that’s created a growing community of artists online. And you don’t need to chose just one interpretation as “canonical” for the animatics, you can chose your own adventure. Similar to the SCP Foundation, for example, this is an entirely fan-made project for something that is entirely fan-made. In the modern day, when so many major studios and organizations are dependent on nostalgia or past products, its so refreshing to see something new; something that is able to bring together communities, rather than drive them into the ground.\nEpic the Musical is a modern epic, in many ways; it is a way of passing along a story, in a new form albeit, but it has reached so many more people in this way than it ever would have if it had stayed as a poem. I really encourage anyone who wants to understand what WILL succeed in modern day to take a look at communities like the one for Jorge Rivera-Herrans’ work, because the passion and drive behind a project, in the end, is what makes the project good; rather than driven by money or success, you should be driven by making a story that you care about. Passion will always lead to success - and that’s what we should really keep in mind.\nYoutube Recommendations:\nConcord:\n\nConcord Died for a Reason\nPro Character Designer Breaks Down, Fixes Concord Character Designs\nDeath of a Game: Concord\nConcord: The Biggest Failure in Gaming\n\nEpic the Musical Animatic Recommendations\n\nThe Horse and the Infant & Just a Man, gigi\nRuthlessness, Tamatama\nRuthlessness, AnniFlama\nRuthlessness, gigi\nScylla, gigi\nLove in Paradise, Duvetbox\nSuffering, gigi\nSuffering, Duvetbox\nGod Games, AnniFlama\nGod Games, SixofClovers\nGod Games, Mumda\nLegendary, Rochi\nLittle Wolf, Duvetbox\nWe’ll be Fine, gigi"
  },
  {
    "objectID": "projects/e-155_website/posts/004_post_2024-09-16.html",
    "href": "projects/e-155_website/posts/004_post_2024-09-16.html",
    "title": "Where is the Time?",
    "section": "",
    "text": "So about Time\nI’ve been running low on sleep recently, and its not for lack of trying. I have a reason for it – mainly being that there just aren’t enough hours in the day to do all the schoolwork I need to do. Forget socialization, or not feeling like doing things – I’m doing so much all the time and it still doesn’t cut down the massive tidal wave hurtling towards me.\nI think that school is, generally, like a tsunami – at least that’s how I’ve explained it to people. You see the signs of it coming long before it does, and dealing with it is a terrible time. Specifically, it’s like facing off against a tsunami with a small little bucket, and you’re told by the captain “you got it buddy, I believe in you” – in my case, the captain is my past self who put me in this situation.\nSo how do we deal with the stress of it all? How do we work towards still succeeding while trying to do everything? Some may say that you should take a break – I think that’s perfectly valid. I actually love throwing myself into work, but I find that I tend to procrastinate on some work by doing others. I recommend, then, that everyone gets a way to track their time and how much time they’re spending for any one thing, whether its to distribute classwork better or whether its to actually see your friends every Saturday.\nHere are some solutions I’ve found; feel free to try them in your own time:\n\nSet up a set time that you’ll meet with your friend, and make sure you tell them its time limited\nWhen you do a silent study session with a friend, bring something to read; if you’re doing something that requires complex math problems, for example, you may need help or start making exclamations that will take away from work.\nUse Toggl Tap! I found this recently through MicroP’s, and its quite useful for budgeting my time and making sure I’m not procrastinating too much on any one thing."
  },
  {
    "objectID": "projects/e-155_website/posts/006_post_2024-10-08.html",
    "href": "projects/e-155_website/posts/006_post_2024-10-08.html",
    "title": "The Swamp that Stands Between",
    "section": "",
    "text": "The Swamp That Stands Between: Engineering and (Riddle) Art\nTying back to what I’ve previously written, let’s talk about how art and engineering are blurred.\nThis past week, I used the same board I use for MicroP’s to create an art project for my art course “Myth Mystics Matter”, where we’ve been exploring the origin or knowledge, and why there are different standards of knowledge: the “ways of knowing”, as we say. In on of our readings, by Bruno Letour, we explored the differences in the definition of knowledge as defined by Hobbes and Boyle (I highly recommend reading “We have Never Been Modern”; it may be extremely dense and academic, but it provides a lot of interesting ideas and thought processes not readily apparent to us who don’t normally think about the philosophical).\nThe main point Latour made in his essay was that some of the many ways of defining knowledge were fleshed out by Hobbes and Boyle in the 16th and 17th century. Dumbing down what we read to the extreme (which is not dumbed down from my perspective, its just a small snippet of what I was able to understand from these papers) Hobbes stated that in order to avoid complete chaos and war, we need to have one defining body saying what is knowledge, and what is not. Boyle stated that knowledge should be communally agreed upon by a group of people; only by observing what’s happening can what is known be fully determined.\nFor the project, I designed two small breadboards with a set of LEDs. One board I decided would act as Hobbes, the other as Boyle. The Hobbes board had the “LEAD_PIN” pin to blink some ASCII code, and then it along with its four companion “FOLLOW_PIN”s would repeat that same ASCII code. For the Boyle board, I made it so that a network of LED’s would spell out the ASCII code, before blinking the ASCII code on all LED’s at once.\nWhat was most interesting from this project was how my classmates interpreted my work. I think a lot of the “art” in my project came from the mystique of it; not understadning what I was flashing, not understanding what bits were flashing, and finally not knowing the background on which I had based my idea. In my own way, I had successuflly shown how chaos occurs without a central understanding of knowledge, whether defined by a group or by an individual.\nThe ASCII that I chose to encode was from a court case (this one) about Netlist vs. the CCIA; mainly, Texas and Virgina tried passing legislation on what information was allowed to be spread on the internet; i.e., controlling knowledge. I encoded the introduction of an article discussing this topic, and it was quite funny seeing everyone trying to figure out what was happening.\nI also found it exciting to see how my peers started decoding the ASCII code as it appeared, and how interpretations varied so much depending on their background. They liked different colors, focused on different lights, and understood the board in a variety of different ways, and I loved seeing their enthusiasm really show itself throughout the cold read and resultant discussion."
  },
  {
    "objectID": "projects/e-155_website/posts/007_post_2024-10-12.html",
    "href": "projects/e-155_website/posts/007_post_2024-10-12.html",
    "title": "Control and Randomness",
    "section": "",
    "text": "How Do we Know When to Control\nCollege students vs Authority is a debate as old as time. For some reason, the administration has a distinct distaste for the property damage and lawsuits that students are prone to cause. Students, on the other hand, have limited time to make youthful, spur of the moment mistakes. Maybe they stole a chicken for a scavenger hunt (don’t worry, they gave it back unharmed the next day), or maybe they found a sign on campus, dug it up, and gave it a new home in their dorm room. Either way, there are some conflicts between authority and college students, and I think it’s definitely changed over time.\nI hear about the pranks that Mudd students used to pull: buying pigs and releasing them in the Scripps Dining Hall, shooting watermelons using surgical wire (shooting it so far that it accidentally hit someone on a bike on a different campus). And all of this I don’t think admin would even come close to letting us do now. As time passes, safety regulations improve, and administration starts getting in more trouble when things happen.\nSo what ends up happening? We go from students creating long term, nostalgic stories (like using chemistry and a hatred for shiny metal to rust an ugly statue overnight) to students not doing anything and losing some of the culture. Admin takes advantage of the nostalgic stories, and brags about its prank culture and student body, but doesn’t acknowledge that the student body has been prevented from forming new stories.\nI would say that control makes sense, especially as you notice how a lack of control could harm people. Maybe laws have changed since the 60s (they definitely have), and so we just can’t afford to allow people to be put in danger anymore. But maybe we also don’t allow for enough randomness now. Maybe we focus on controlling small things, that have little impact, that don’t need to be focused on. But we should really start considering as well how the climate around randomness has changed, and maybe its just a fact that we can’t afford to be as “random” as we were before.\nI don’t have a consensus on it, and I think no one really does. It’s something that has to be decided on as a society, an acclimation of individuals and experiences. So I’ll leave this one up in the air, and let this blog post serve as a conversation starter."
  },
  {
    "objectID": "projects/e-155_website/posts/001_post_2024-08-28.html",
    "href": "projects/e-155_website/posts/001_post_2024-08-28.html",
    "title": "Is ‘Smart’ Really a Thing?",
    "section": "",
    "text": "Is “Smart” really a thing?\nI have a distinct memory from my time in elementary school of realizing that being smart is a very relative thing. The fact is, even elementary school students can understand that there’s a grey area when it comes to “intellectual prowess”: it is weird, in that way, that we try to decide and define who is smart and who isn’t. Sometimes, there are outliers of course - no one would ever really try to fight me if I said that Einstein was a genius. And yet, to me “smart” remains a very loaded word.\nThe main aspect of “smartness” I was thinking about in lower school was smartness in a multitude of categories: even if I may be book smart, for example, I have a very difficult time understanding people, and when it comes to social interactions I’m relatively hopeless. Smartness, from my perspective, ought to be considered more like (and forgive my references here) a Dungeons and Dragons character sheet rather than as some individual thing that measures solely how much someone has memorized flash card.\nAs a society, we’ve definitely been moving in the correct direction – standardized testing becoming optional for many schools is one of the first steps to recognizing the multitude of “smart” categories of students, and it will likely bring about a great degree of change for the better in multiple institutions. There obviously remains a long path to this recognition, however, and to that extent I’ve come up with a few paths I think might be able to be followed. The primary goal of these paths, or initiatives, would be to actively support the “smartness” of students not only in their intelligence, but in their five other categories as well (although I will mainly want to focus on Constitution, Wisdom, and Charisma).\nFor those unitiated in Dungeons and Dragons, I’ve provided a short, handy example of each of the six stats explained using tomatoes.\n\n\n\nImage of Tomato DnD Chart\n\n\nBased off of the DnD chart:\n\n(Constitution): How often has there been a friend that is just inherently in tune with their own body? This applies particularly to athletes and to dancers; the reason why I’d say that this falls under my terminology for “smart” is that this is a skill, based in understanding, that must be incessently worked at. Over time, you need enough experience with moving, working out, or playing games to understand yourself. The best way that we might begin incorporating a greater degree of respect for this “smartness” would likely be similar to the gym classes we have now; however, it relies on the coaches or teachers leading these activities encouraging learning about physical improvement, and applauding personal growth (not just natural skill)\n(Wisdom): This is street smarts, and although it can’t really be taught, it is always good to introduce new material to kids in class. I think running small sessions of activities that have unexpected or unrecognizable projects would aid in improving “wisdom smartness”.\n(Charisma): This one is quite important, and quite often overlooked. Charisma is a trait that is often built up from a very young age, and I know that I for one struggle with it. This smartness was my primary inspiration for thinking this in elementary school; knowing social interactions, when to speak, what is funny to say, when to say it, is difficult. As adults we’ve honed in on proper timing in converstaions, or proper topics to discuss, but as children most of the time this is only learned through peer-to-peer interaction. I’d say that in this case, the problem is less about teaching Charisma “smartness” and more about acknowledging it; potentially in school, especially lower levels of schooling, taking time to acknowledge feats of charisma, or running small programs where students share what they admire about how other people interact with them. The main point here is cognizance of the importance of social awareness.\n\nThere’s something to be said for teachers and mentors being involved outside of the classroom. I think at the end of the day, what I really wanted to get across with this post is the fact that students should acknowledge a variety of talents that they have, not just the ones that they demonstrate via memorization or in class."
  },
  {
    "objectID": "projects/e-155_website/blog.html",
    "href": "projects/e-155_website/blog.html",
    "title": "Blog",
    "section": "",
    "text": "The World of Epic the Musical\n\n\n\n\n\n\nblogpost\n\n\n\nHow community makes success\n\n\n\n\n\nOct 22, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nControl and Randomness\n\n\n\n\n\n\nblogpost\n\n\n\nHow do we work with control and randomness when it comes to college administrations\n\n\n\n\n\nOct 12, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nThe Swamp that Stands Between\n\n\n\n\n\n\nblogpost\n\n\n\nArt and Engineering v2\n\n\n\n\n\nOct 8, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nThe Swamp that Stands Between\n\n\n\n\n\n\nblogpost\n\n\n\nCircus and Physics\n\n\n\n\n\nOct 1, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nWhere is the Time?\n\n\n\n\n\n\nblogpost\n\n\n\n\n\n\n\n\n\nSep 16, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nWorldbuilding while on the Move\n\n\n\n\n\n\nblogpost\n\n\n\nMaking time where there isn’t any to build your fantasy world\n\n\n\n\n\nSep 10, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nThe Swamp That Stands Between\n\n\n\n\n\n\nblogpost\n\n\n\nHow do art and engineering entangle with each other? And where do we draw the line?\n\n\n\n\n\nSep 5, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nE155: Learning Goals\n\n\n\n\n\n\nblogpost\n\n\n\nExplaining my initial learning goals for MicroPs\n\n\n\n\n\nAug 29, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nIs ‘Smart’ Really a Thing?\n\n\n\n\n\n\nblogpost\n\n\n\nExamining what it means to be smart, and strategies to respect alternative forms of it within the classroom\n\n\n\n\n\nAug 23, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\n\n\n\n\n\n\nA Discussion on ‘Nerd Culture’\n\n\n\n\n\n\nblogpost\n\n\n\nWhy its easier to fit in with people that never have\n\n\n\n\n\nAug 23, 2024\n\n\nZoe Worrall\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Zoe Worrall’s Website",
    "section": "",
    "text": "Mae g’ovannen! My name is Zoe Worrall, and I am currently a senior Engineering Major at Harvey Mudd College.\nAlthough I have experience with a broad range of engineering topics including materials engineering, continuum mechanics, and manufacturing, my primary interests lie in signal processing, radio frequency, and optical systems.\n\n\nMudd’s general Engineering gives its students a strong background in a variety of subjects, but what has clicked with me the most in my schooling has been electrical engineering, especially through research.\nWhether it was working under PI Dr. Jason Gallicchio on software defined radio, or with research of in-vivo imaging systems in the Harvey Mudd Biophotonics Lab with Dr. Joshua Brake, I’ve learned to work with electromagnetic waves, their generation, and their processing.\n\n\n\n\n\n\nMy favorite courses at HMC have included E&M, Data Structures for C++, Digital Design and Computer Architecture, analog circuit design, and Systems Engineering."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Zoe Worrall’s Website",
    "section": "",
    "text": "Mae g’ovannen! My name is Zoe Worrall, and I am currently a senior Engineering Major at Harvey Mudd College.\nAlthough I have experience with a broad range of engineering topics including materials engineering, continuum mechanics, and manufacturing, my primary interests lie in signal processing, radio frequency, and optical systems.\n\n\nMudd’s general Engineering gives its students a strong background in a variety of subjects, but what has clicked with me the most in my schooling has been electrical engineering, especially through research.\nWhether it was working under PI Dr. Jason Gallicchio on software defined radio, or with research of in-vivo imaging systems in the Harvey Mudd Biophotonics Lab with Dr. Joshua Brake, I’ve learned to work with electromagnetic waves, their generation, and their processing.\n\n\n\n\n\n\nMy favorite courses at HMC have included E&M, Data Structures for C++, Digital Design and Computer Architecture, analog circuit design, and Systems Engineering."
  },
  {
    "objectID": "index.html#engineering",
    "href": "index.html#engineering",
    "title": "Zoe Worrall’s Website",
    "section": "",
    "text": "Mudd’s general Engineering gives its students a strong background in a variety of subjects, but what has clicked with me the most in my schooling has been electrical engineering, especially through research.\nWhether it was working under PI Dr. Jason Gallicchio on software defined radio, or with research of in-vivo imaging systems in the Harvey Mudd Biophotonics Lab with Dr. Joshua Brake, I’ve learned to work with electromagnetic waves, their generation, and their processing."
  },
  {
    "objectID": "index.html#art",
    "href": "index.html#art",
    "title": "Zoe Worrall’s Website",
    "section": "Art",
    "text": "Art\nIn addition to majoring in Engineering, I am also pursuing a concentration in Studio Art."
  }
]