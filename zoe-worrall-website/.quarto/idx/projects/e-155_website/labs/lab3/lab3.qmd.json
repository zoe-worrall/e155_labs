{"title":"Lab 3 Writeup","markdown":{"yaml":{"title":"Lab 3 Writeup","author":"Zoe Worrall  - zworrall@g.hmc.edu","image":"images/4x4Kepad.png","date":"September 9, 2024","format":{"html":{"other-links":[{"text":"E155 FA Development Board","href":"https://pages.hmc.edu/brake/class/e155/fa23/assets/doc/E155%20Development%20Board%20Schematic.pdf"},{"text":"E155 Breadboard Adapter v4","href":"https://hmc-e155.github.io/assets/doc/E155%20Breadboard%20Adapter%20Schematic.pdf"},{"text":"Lab 3 Github Files","href":"https://github.com/zoe-worrall/e155_labs/tree/main/fpga/radiant_project/lab03"},{"text":"PNP Transistor Datasheet","href":"https://hmc-e155.github.io/assets/doc/2N3906-D.pdf"}]}},"categories":["labreport"]},"headingText":"Lab 3: Keypad Scanner","containsRefs":false,"markdown":"\n\n\n*Hours Spent: 56 hours, Mapped with Toggl Track*\n\n### Introduction\n\nThe main point of this laboraotry was to use asynchronous components and a finite state machine to control a keypad connected to an FPGA. The Finite state machine would keep track of both the values of the states, as well as have a recorded memory of both the most recent and the last pin pressed. The difficulties of this lab lay within creating a way to handle metastability; in order to ensure that no random metastability occured within the system while it was running, you need to have a set of flip flops through which you run the column input.\n\n### General Approach\n\nI first began by drawing a rudimentary FSM chart:\n\n![](images/Screenshot%202024-09-17%20at%202.31.42%E2%80%AFPM.png)\n\nThis is based on the fundamental logic that there should be four parts to this problem:\n1. A section of the code/hardware that sends a voltage through each row as it goes, **waiting** to detect a signal. If it does detect something, it sends us to the next state.\n2. A section of the code/hardware that **logs** the corresponding rows and columns so that we can compute what the letter we need to light up is\n3. A section of the code/hardware that **cycles** for about 1ms to prevent bounceback caused by any of the keys\n4. A section of the code/hardware that waits until the original button (or what I coined the RX Signal) that was pressed is no longer pressed down (i.e. can't say \"nothing is pressed\", but rather that the original button is no longer pressed); thus, you wait **till the RX signal stops**.\n\nI additionally decided to define a row state machine, although this would reside within the actual program as combinational logic, not as a module.\n\n![](images/row_fsm.png){#fig-row_state_machine}\n\n\n#### Metastability\n\nSome challenges with this lab are implementing a way to handle metastability; in this case, it was necessary to add a set of flip flops about the column input logic so that asyncronous signals could become synchronous; in my case, I chose to send the columns through two flipflops. I integrated this step within my FSM block, after I had initially made the logic for it, which resulted in the large amount of code that it contains; in the future, I'd like to trim this FSM block down so that it looks simpler and shows the outputs and inputs easier to the causal viewer. However, for now the flip flops have been implemented to run right after the waiting period, within the \"LOG\" state; the LOG state will wait for two cycles of flip flops, before taking the output of the flip flop (mat_stab), and using it as if it were the column. During this process, the intial row that the column was saved to has been stored, and I am powering it so that the upcoming TILL_RX_STOP step can run.\n\nMy debouncing approach is likely more rudimentary than it could be: I could additionally have added a way to track how many one's in a row the machine had received, and use that to determine if the button was actually pushed. This would have required a longer loop, but would likely have been more accurate, as currently some a quick tap of the key makes it repeat (even though I've made the CYCLE stage extremely long relatively speaking). I think that the looking at the 1's strategy would be very effective for eliminating debouncing. I think that in particular, I could have implemented more flip-flops to really make sure that the state was what the board originally thought it was.\n\n#### Drawing Charts\nUsing my initial approach as well as some blocking of the modules that I would need for this program, I was then able to construct a finalized FSM with defined output variables.\n\nThis gives the following diagram and set of tables for inputs and outputs.\n\n![](images/finite_state_mach.png)\n\n| state | scenario/inputs | next_state | output values: row, past_letter, curr_letter, state, waiter | \n|-------|-----------------|------------|-------------------------------------------------------------|\n| WAIT  | col == 0 |  WAIT      | row = ROW (see the [row state machine](@fig-row_state_machine)), past_letter remains, curr_letter remains, state = WAIT, waiter = 0 | \n| WAIT  | col != 0 |  LOG       | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = WAIT, next_waiter = 2^19 | \n| LOG   | mat_stab != (4'b0001 | 4'b0010 | 4'b0100 | 4'b1000) | WAIT | row = R_RESET (see the [row state machine](@fig-row_state_machine)), next_past_letter = curr_letter, next_curr_letter = next_letter (output of letter_receiver module), state = LOG, next_waiter = waiter |\n| LOG   | mat_stab == (4'b0001 | 4'b0010 | 4'b0100 | 4'b1000) | CYCLE | next_row = row (see the [row state machine](@fig-row_state_machine)), past_letter remains, curr_letter remains, state = WAIT, waiter = waiter - 1 |\n| CYCLE | waiter != 0 | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = waiter - 1 |\n| CYCLE | waiter == 0 | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0 |\n| TILL_RX_STOP | col[col_index] != 0 | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0  |\n| TILL_RX_STOP | col[col_index] == 0 | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0  |\n\n: **State Transition Table** {#tbl-state_trans_model}\n\nI have additionally depicted below what the table for the row states looks like.\n\n| row   | scenario/inputs | next_row |\n|-------|-----------------|----------|\n| R_RESET  | X   |  R_0    |\n| R_0  | col == 0  |  R_1   |\n| R_1  | col == 0  |  R_2   |\n| R_2  | col == 0  |  R_3   |\n| R_3  | col == 0  |  R_0   |\n| R_X  | col != 0  |  R_X   |\n \n :  **State Transition Table for the Row States** {#tbl-state_trans_model}\n\n\n**Currently in the works, I decided to try revamping my FSM so that I wasn't doing everything at once inside of my FSM function; it initially made the most sense to me to try doing it in one place, but this made it hard to see all of the logic that was happening to an outside observer (i.e. Kavi)**\n\n### Modules\n\nMy final product of code looks like the following. The program primarily consists of the top module, which contains the clock, the lab03 module, which holds the fsm and the dual segment display modules, and finally the individual modules inside them. Describing them below,\n\n* **lab03_fsm**: uses an internal flipflop from my flop_me module and a combinational logic block called letter_receiver to iterate through the defined states and return the desired values of interest.\n* **dual_seven_seg**: the same as from lab02, where it uses multiplexing to light up both of the arrays with two defined numbers; this time, the numbers are supplied by the fsm.\n* **flop_me**: a flip flop of some defined length that runs every time within the function in order to solve any metastability that may be present with a button push.\n* **letter_receiver**: a combinational logic block that combines the saved indices of the rows and columns in order to solve for whatever letter/number was pressed. This is how I get the next_letter variable within my finite state machine.\n\n![](images/block_diagram.png)\n\nI confirmed using Questa that I was able to get the right values for all potential row inputs that I would have by iterating through the fsm (see the testbench below)\n\n![](images/fsm_testbench.png)\n\nIn order to form a comprehensive test, I initially begin by making sure that every row can be cycled through while we reside inside the Waiting state. No column was entered, and the testbench was used to track that the past letters, current letters, and finally the row cycling; since this is the waiting state, and nothing's been pressed, the rows should cycle, and the output letters (0 and 0) stay the same (@fig-cyclingrows)\n\n![](images/fsm_cycling_rows_testbench.png){#fig-cyclingrows}\n\nAfter this has been done, the system is then reset. This is confirmed by the testbench, and then the testbench enters a long for-loop that is used to confirm that every letter can be received and updated. For each loop of the table, the row and column are updated; the letter that has been generated is confirmed to be correct in the testbench, as well as the current lit rows and columns. The FSM additionally outputs its state, which is not used in the lab03 overall, but is used in the testbench to confirm that the proper state has also been entered. These cycles run through every row and every potential combination of row and column (@fig-forloop).\n\n![](images/fsm_testbench_smal.png){#fig-forloop}\n\nWhen we zoom out in full, we can confirm that all letters can be reached, and that they can be stored (@fig-fullrun).\n\n![](images/fsm_testbench.png){#fig-fullrun}\n\nNext, I made another test bench to test my lab03 module as a whole, which looks like the following;\n\n![](images/lab03_testbench.png){#fig-lab03Test}\n\nThis testbench acts very similar to the fsm testbench, but in this case it confirms that the segment oscillates back and forth between the past letter and the current letter. Similar to the previous testbench for the fsm, the values were compared with expected values in the test bench, and when no errors were thrown, and the for-loop was completed without any errors or red lines becoming apparent, the testbench was considered a success.\n\nAs can be seen in @fig-lab03Test, the full test could be run, and the expected oscillations between segments occured as lab03 was run. \n\nIn both of these cases, I used a testbench to initialize and push inputs into the modules, and made sure that the expected values matched what I anticipated (indicated by no errors appearing in the terminal window).\n\nThe final schematic of my system was very simple to make. I used four GPIO pins from the FPGA E155 adapter board as an output into the rows, and four GPIO pins from this same board as inputs. Of additional note, becuase I considered 1's as \"high\" on my board, I turned off the pull-up resistors inside the column pins, and implemented pulldown resistors of 47kOhm impedance on my board, with the knowledge that the keypad's resistors range between 60 and 200 Ohms (found by testing in lab with an oscilloscope); resultantly, any voltage drop caused by the voltage-divider setup I had made would be negligable over the keypad, and would allow for proper reading of the signal. All other parts of this schematic, as a reader may likely recognize, are the same as from Lab2; the seven segment display as well as it PNP transistors are all plugged into the same pins, and depend on the same inputs.\n\n![](images/schematic_lab3.png)\n\n![](images/4x4Kepad.png)\n\n### Results and Discussion\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed. The main issue encountered in this lab were the following:\n* Implementation of pull-down resistors, and turning off the pull-up resistors within the keypads.\n* Implementation of a clock division that prevented the double-readout of a button push, which caused keys that sometimes held values a bit longer (on my keypad, keys E, 7, and 2) to be falsely read as a second input.\n\nIf future development desired, I'd like to add more flipflops, as well as simplify the state machine layout within Verilog to make debugging easier and make it more understandable to new viewers; potentially if I have time over winter break, I'll do that and make it extremely nice looking so that it looks better in GitHub.\n\n### Conclusion\n\nThis lab was extremely difficult. I recommend in the future sending out a post about where the keypads are in the beginning of lab, because many people had a hard time finding them: I'd additionally warn people about how some of the keypads don't match their anticipated row and column values, and that people should plan on bringing in multimeters in order to test which buttons are connected where. Finally, I'd suggest that people start by thinking about the flip flops, and don't ignore them until later on; it became much harder to implement once I had my program set up, and if I had had the ability to go back and redo it with the knowledge that multipathing would require me to wait periods of time within a module, etc., I likely would have set it up nicer and it would have been in separate modules.\n\nAdditionally, I believe a note should be put somewhere about the speed of the clock, and to consider that as well when implementing your code. Although it is something that can be realized with the aid of an oscilloscope, it didn't cross my mind because I was so fixated on the bugs that may be causing the issue. It may be nice to put a mention, maybe even a vague sentence, somewhere that says to keep an eye on not only the timing issues of your circuit, but in what time scale your circuit is running - that way it doesn't spell out the answer, but still is informative to people like me who get stuck.","srcMarkdownNoYaml":"\n\n\n## Lab 3: Keypad Scanner\n*Hours Spent: 56 hours, Mapped with Toggl Track*\n\n### Introduction\n\nThe main point of this laboraotry was to use asynchronous components and a finite state machine to control a keypad connected to an FPGA. The Finite state machine would keep track of both the values of the states, as well as have a recorded memory of both the most recent and the last pin pressed. The difficulties of this lab lay within creating a way to handle metastability; in order to ensure that no random metastability occured within the system while it was running, you need to have a set of flip flops through which you run the column input.\n\n### General Approach\n\nI first began by drawing a rudimentary FSM chart:\n\n![](images/Screenshot%202024-09-17%20at%202.31.42%E2%80%AFPM.png)\n\nThis is based on the fundamental logic that there should be four parts to this problem:\n1. A section of the code/hardware that sends a voltage through each row as it goes, **waiting** to detect a signal. If it does detect something, it sends us to the next state.\n2. A section of the code/hardware that **logs** the corresponding rows and columns so that we can compute what the letter we need to light up is\n3. A section of the code/hardware that **cycles** for about 1ms to prevent bounceback caused by any of the keys\n4. A section of the code/hardware that waits until the original button (or what I coined the RX Signal) that was pressed is no longer pressed down (i.e. can't say \"nothing is pressed\", but rather that the original button is no longer pressed); thus, you wait **till the RX signal stops**.\n\nI additionally decided to define a row state machine, although this would reside within the actual program as combinational logic, not as a module.\n\n![](images/row_fsm.png){#fig-row_state_machine}\n\n\n#### Metastability\n\nSome challenges with this lab are implementing a way to handle metastability; in this case, it was necessary to add a set of flip flops about the column input logic so that asyncronous signals could become synchronous; in my case, I chose to send the columns through two flipflops. I integrated this step within my FSM block, after I had initially made the logic for it, which resulted in the large amount of code that it contains; in the future, I'd like to trim this FSM block down so that it looks simpler and shows the outputs and inputs easier to the causal viewer. However, for now the flip flops have been implemented to run right after the waiting period, within the \"LOG\" state; the LOG state will wait for two cycles of flip flops, before taking the output of the flip flop (mat_stab), and using it as if it were the column. During this process, the intial row that the column was saved to has been stored, and I am powering it so that the upcoming TILL_RX_STOP step can run.\n\nMy debouncing approach is likely more rudimentary than it could be: I could additionally have added a way to track how many one's in a row the machine had received, and use that to determine if the button was actually pushed. This would have required a longer loop, but would likely have been more accurate, as currently some a quick tap of the key makes it repeat (even though I've made the CYCLE stage extremely long relatively speaking). I think that the looking at the 1's strategy would be very effective for eliminating debouncing. I think that in particular, I could have implemented more flip-flops to really make sure that the state was what the board originally thought it was.\n\n#### Drawing Charts\nUsing my initial approach as well as some blocking of the modules that I would need for this program, I was then able to construct a finalized FSM with defined output variables.\n\nThis gives the following diagram and set of tables for inputs and outputs.\n\n![](images/finite_state_mach.png)\n\n| state | scenario/inputs | next_state | output values: row, past_letter, curr_letter, state, waiter | \n|-------|-----------------|------------|-------------------------------------------------------------|\n| WAIT  | col == 0 |  WAIT      | row = ROW (see the [row state machine](@fig-row_state_machine)), past_letter remains, curr_letter remains, state = WAIT, waiter = 0 | \n| WAIT  | col != 0 |  LOG       | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = WAIT, next_waiter = 2^19 | \n| LOG   | mat_stab != (4'b0001 | 4'b0010 | 4'b0100 | 4'b1000) | WAIT | row = R_RESET (see the [row state machine](@fig-row_state_machine)), next_past_letter = curr_letter, next_curr_letter = next_letter (output of letter_receiver module), state = LOG, next_waiter = waiter |\n| LOG   | mat_stab == (4'b0001 | 4'b0010 | 4'b0100 | 4'b1000) | CYCLE | next_row = row (see the [row state machine](@fig-row_state_machine)), past_letter remains, curr_letter remains, state = WAIT, waiter = waiter - 1 |\n| CYCLE | waiter != 0 | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = CYCLE, next_waiter = waiter - 1 |\n| CYCLE | waiter == 0 | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0 |\n| TILL_RX_STOP | col[col_index] != 0 | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0  |\n| TILL_RX_STOP | col[col_index] == 0 | next_row = row, next_past_letter = past_letter , next_curr_letter = curr_letter, state = TILL_RX_STOP, next_waiter = 0  |\n\n: **State Transition Table** {#tbl-state_trans_model}\n\nI have additionally depicted below what the table for the row states looks like.\n\n| row   | scenario/inputs | next_row |\n|-------|-----------------|----------|\n| R_RESET  | X   |  R_0    |\n| R_0  | col == 0  |  R_1   |\n| R_1  | col == 0  |  R_2   |\n| R_2  | col == 0  |  R_3   |\n| R_3  | col == 0  |  R_0   |\n| R_X  | col != 0  |  R_X   |\n \n :  **State Transition Table for the Row States** {#tbl-state_trans_model}\n\n\n**Currently in the works, I decided to try revamping my FSM so that I wasn't doing everything at once inside of my FSM function; it initially made the most sense to me to try doing it in one place, but this made it hard to see all of the logic that was happening to an outside observer (i.e. Kavi)**\n\n### Modules\n\nMy final product of code looks like the following. The program primarily consists of the top module, which contains the clock, the lab03 module, which holds the fsm and the dual segment display modules, and finally the individual modules inside them. Describing them below,\n\n* **lab03_fsm**: uses an internal flipflop from my flop_me module and a combinational logic block called letter_receiver to iterate through the defined states and return the desired values of interest.\n* **dual_seven_seg**: the same as from lab02, where it uses multiplexing to light up both of the arrays with two defined numbers; this time, the numbers are supplied by the fsm.\n* **flop_me**: a flip flop of some defined length that runs every time within the function in order to solve any metastability that may be present with a button push.\n* **letter_receiver**: a combinational logic block that combines the saved indices of the rows and columns in order to solve for whatever letter/number was pressed. This is how I get the next_letter variable within my finite state machine.\n\n![](images/block_diagram.png)\n\nI confirmed using Questa that I was able to get the right values for all potential row inputs that I would have by iterating through the fsm (see the testbench below)\n\n![](images/fsm_testbench.png)\n\nIn order to form a comprehensive test, I initially begin by making sure that every row can be cycled through while we reside inside the Waiting state. No column was entered, and the testbench was used to track that the past letters, current letters, and finally the row cycling; since this is the waiting state, and nothing's been pressed, the rows should cycle, and the output letters (0 and 0) stay the same (@fig-cyclingrows)\n\n![](images/fsm_cycling_rows_testbench.png){#fig-cyclingrows}\n\nAfter this has been done, the system is then reset. This is confirmed by the testbench, and then the testbench enters a long for-loop that is used to confirm that every letter can be received and updated. For each loop of the table, the row and column are updated; the letter that has been generated is confirmed to be correct in the testbench, as well as the current lit rows and columns. The FSM additionally outputs its state, which is not used in the lab03 overall, but is used in the testbench to confirm that the proper state has also been entered. These cycles run through every row and every potential combination of row and column (@fig-forloop).\n\n![](images/fsm_testbench_smal.png){#fig-forloop}\n\nWhen we zoom out in full, we can confirm that all letters can be reached, and that they can be stored (@fig-fullrun).\n\n![](images/fsm_testbench.png){#fig-fullrun}\n\nNext, I made another test bench to test my lab03 module as a whole, which looks like the following;\n\n![](images/lab03_testbench.png){#fig-lab03Test}\n\nThis testbench acts very similar to the fsm testbench, but in this case it confirms that the segment oscillates back and forth between the past letter and the current letter. Similar to the previous testbench for the fsm, the values were compared with expected values in the test bench, and when no errors were thrown, and the for-loop was completed without any errors or red lines becoming apparent, the testbench was considered a success.\n\nAs can be seen in @fig-lab03Test, the full test could be run, and the expected oscillations between segments occured as lab03 was run. \n\nIn both of these cases, I used a testbench to initialize and push inputs into the modules, and made sure that the expected values matched what I anticipated (indicated by no errors appearing in the terminal window).\n\nThe final schematic of my system was very simple to make. I used four GPIO pins from the FPGA E155 adapter board as an output into the rows, and four GPIO pins from this same board as inputs. Of additional note, becuase I considered 1's as \"high\" on my board, I turned off the pull-up resistors inside the column pins, and implemented pulldown resistors of 47kOhm impedance on my board, with the knowledge that the keypad's resistors range between 60 and 200 Ohms (found by testing in lab with an oscilloscope); resultantly, any voltage drop caused by the voltage-divider setup I had made would be negligable over the keypad, and would allow for proper reading of the signal. All other parts of this schematic, as a reader may likely recognize, are the same as from Lab2; the seven segment display as well as it PNP transistors are all plugged into the same pins, and depend on the same inputs.\n\n![](images/schematic_lab3.png)\n\n![](images/4x4Kepad.png)\n\n### Results and Discussion\n\nAs shown in the two test bench simulations above, the program is able to receive the desired outputs. When observed in the lab, with hardware, the correct behavior can be similarly observed. The main issue encountered in this lab were the following:\n* Implementation of pull-down resistors, and turning off the pull-up resistors within the keypads.\n* Implementation of a clock division that prevented the double-readout of a button push, which caused keys that sometimes held values a bit longer (on my keypad, keys E, 7, and 2) to be falsely read as a second input.\n\nIf future development desired, I'd like to add more flipflops, as well as simplify the state machine layout within Verilog to make debugging easier and make it more understandable to new viewers; potentially if I have time over winter break, I'll do that and make it extremely nice looking so that it looks better in GitHub.\n\n### Conclusion\n\nThis lab was extremely difficult. I recommend in the future sending out a post about where the keypads are in the beginning of lab, because many people had a hard time finding them: I'd additionally warn people about how some of the keypads don't match their anticipated row and column values, and that people should plan on bringing in multimeters in order to test which buttons are connected where. Finally, I'd suggest that people start by thinking about the flip flops, and don't ignore them until later on; it became much harder to implement once I had my program set up, and if I had had the ability to go back and redo it with the knowledge that multipathing would require me to wait periods of time within a module, etc., I likely would have set it up nicer and it would have been in separate modules.\n\nAdditionally, I believe a note should be put somewhere about the speed of the clock, and to consider that as well when implementing your code. Although it is something that can be realized with the aid of an oscilloscope, it didn't cross my mind because I was so fixated on the bugs that may be causing the issue. It may be nice to put a mention, maybe even a vague sentence, somewhere that says to keep an eye on not only the timing issues of your circuit, but in what time scale your circuit is running - that way it doesn't spell out the answer, but still is informative to people like me who get stuck."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"lab3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.45","theme":"jolla","font-family":"Times New Roman","smooth-scroll":true,"grid":{"sidebar-width":"0px","body-width":"1000px","margin-width":"250px"},"title":"Lab 3 Writeup","author":"Zoe Worrall  - zworrall@g.hmc.edu","image":"images/4x4Kepad.png","date":"September 9, 2024","categories":["labreport"],"other-links":[{"text":"E155 FA Development Board","href":"https://pages.hmc.edu/brake/class/e155/fa23/assets/doc/E155%20Development%20Board%20Schematic.pdf"},{"text":"E155 Breadboard Adapter v4","href":"https://hmc-e155.github.io/assets/doc/E155%20Breadboard%20Adapter%20Schematic.pdf"},{"text":"Lab 3 Github Files","href":"https://github.com/zoe-worrall/e155_labs/tree/main/fpga/radiant_project/lab03"},{"text":"PNP Transistor Datasheet","href":"https://hmc-e155.github.io/assets/doc/2N3906-D.pdf"}]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}