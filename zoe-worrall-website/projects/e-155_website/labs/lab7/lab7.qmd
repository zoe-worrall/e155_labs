---
title: Lab 7 Writeup
author: Zoe Worrall  - zworrall@g.hmc.edu
date: November 1, 2024

format:
  html:
    other-links:
      - text: "E155 Breadboard Adapter v4"
        href: https://hmc-e155.github.io/assets/doc/E155%20Breadboard%20Adapter%20Schematic.pdf
      - text: "Lab 7 Github Files"
        href: https://github.com/zoe-worrall/e155_labs/tree/main/mcu/lab05
      - text: "STM32L432xx Reference Manual"
        href: https://www.st.com/resource/en/reference_manual/rm0394-stm32l41xxx42xxx43xxx44xxx45xxx46xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf
      - text: "STM32L432xx Datasheet"
        href: https://www.st.com/resource/en/datasheet/stm32l432kb.pdf
        
categories:
  - labreport
---
## Lab 5: Interrupts
*Hours Spent: 74 hours, Mapped with Toggl Track*

### Introduction

In this lab, a STM32L432KCU Microcontroller Unit (the MCU) was used to send and receive SPI signals to the Upduino FPGA board. Unfortunately, after troubleshooting on the interconnection between the working FPGA board and the MCU board for fourteen hours, I could not get my FPGA to communicate with my MCU using SPI, and as a result this lab has been left only at Proficiency Level.

This lab requires the user to implement the AES-128 (or the Advanced Encryption Standard) program. The complexity of this lab (should have been) mainly focused on the simulation aspects the encryption standard. As described in the following sections, this encryption standard follows a few definitive steps in order to convert an input string of 128 bits into a newly encoded form - similar to how we communicate with the internet now, with a given key a user can decode and encode a string however they want to prevent unwanted eyes viewing the initial message.

Although I got the simulation working after a multitude of debugging efforts, I was unable to get the project working and communicating on hardware, unfortunately.

### AES-128's Structure

To help myself write the functions necessary for this program, I began by drawing out all of the functions for the program so that I knew what to do within Lattice Radiant. There are, fundamentally 5 functions in this program, one of which uses two small "semi-functions", I will term them. These are listed below:

1. AddRoundKey(state, w_round[3:0]) - Combines the input "state" with a "word" that then converts all of the states inside the "state" listt into a `state_prime` variable.

2. MixColumns(state) -- Recombines a set of columns using a predefined matrix of hexadecimal values.

3. SubBytes -- Uses a function called "sbox" to substitute every word within a matrix with another word. This matrix is unique and causes a high degree of randomness within the completed function.

4. ShiftRows -- Considering state as a matrix, shifts all the state values over by one two the left (including wrap around) depending on which row the state is.

5. KeyExpansion -- Defines a new list of words based on a supplied key. For each "round" of the function, new words are created, which are used in other functions to adjust the state.

Overall, these functions all come together as described in the pseudocode __.

I drew out each progran, and will go into furhter detail with each of the following diagram.

![](images/diagram)

#### AddRoundKey(state, w_round)



#### MixColumns(state)

#### KeyExpansion()

##### SubWord

##### RotWord

#### ShiftRows(state)

#### SubBytes()


### Final Setup

The final design can be represented in the following block diagram. As can be seen in the block diagram, sbox has two potential functions; sbox and sbox_sync. In this case, we need to have a synchronized sbox_sync because there is not enough memory on the FPGA to store the sbox memory before transmitting it. As a result, we need a way to synchronize the sbox in order to prevent its memory from being stored at the same time as other functions so that enough memory is given to the network. This problem with memory mapping can be seen in the image below, where an error message is called due to a Synthesis Error.

As can be seen in the diagram below, despite using synchronized sbox values, all of the RAM on the FPGA is still used by the program and overflows such that most of the registers on the board are used.


### Test Bench Trials

The test bench trials did function properly for both the SPI and the CORE; in order to test both of these, however, a series of smaller test benches needed to be crafted to test each function. These were made using the defined table of AES functions as defined in the PDF.

For each function, a set of vectors for the state input and state output were made, and the program was run to confirm that the right value was received. Since there are no such thing as edge cases in many of these functions, I didn't construct any fringe case scenarios for this problem.

### Hardware Trials

I faced considerable problems with the hardware set up for this lab; I believe that this was, in part, due to a problem with my PB4 and PB5, which are shorted together due to soldering issues. With my Lab 6, I was able to avoid this issue using PB12 and PA11, but due to some of the requisites of this lab, and the time constraints on my own part, I was unable to complete this aspect of the project.


### Results and Discussion


### Conclusion

